<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üéÆ Sk√°kac√≠ hra</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: #1a1a1a;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      max-width: 900px;
      width: 100%;
    }

    .header {
      text-align: center;
      margin-bottom: 20px;
    }

    .header h1 {
      font-size: 2rem;
      font-weight: 600;
      color: #e0e0e0;
      margin-bottom: 10px;
    }

    .game-wrapper {
      background-color: #2a2a2a;
      border: 1px solid #404040;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    .stats {
      display: flex;
      justify-content: space-between;
      margin-bottom: 15px;
      gap: 15px;
    }

    .stat-box {
      background-color: #404040;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 10px 20px;
      flex: 1;
      text-align: center;
    }

    .stat-label {
      font-size: 0.8rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 5px;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 600;
      color: #6aa6fd;
    }

    #gameCanvas {
      width: 100%;
      height: 500px;
      background-color: #1a1a1a;
      border: 2px solid #404040;
      border-radius: 4px;
      display: block;
    }

    .controls {
      margin-top: 20px;
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
    }

    .btn {
      background-color: #6aa6fd;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      transition: all 0.2s ease;
      flex: 1;
      min-width: 150px;
    }

    .btn:hover {
      background-color: #5694f0;
      transform: translateY(-2px);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn.secondary {
      background-color: #404040;
      border: 1px solid #555;
    }

    .btn.secondary:hover {
      background-color: #4a4a4a;
    }

    .instructions {
      background-color: #2a2a2a;
      border: 1px solid #404040;
      border-radius: 8px;
      padding: 20px;
      margin-top: 20px;
    }

    .instructions h3 {
      color: #6aa6fd;
      margin-bottom: 15px;
      font-size: 1.1rem;
    }

    .instructions ul {
      list-style: none;
      padding: 0;
    }

    .instructions li {
      padding: 8px 0;
      border-bottom: 1px solid #404040;
      color: #bbb;
    }

    .instructions li:last-child {
      border-bottom: none;
    }

    .instructions strong {
      color: #e0e0e0;
      margin-right: 10px;
    }

    .game-over-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #2a2a2a;
      border: 2px solid #6aa6fd;
      border-radius: 8px;
      padding: 30px;
      text-align: center;
      display: none;
      z-index: 100;
      min-width: 300px;
    }

    .game-over-overlay.show {
      display: block;
    }

    .game-over-overlay h2 {
      color: #6aa6fd;
      margin-bottom: 20px;
      font-size: 2rem;
    }

    .game-over-overlay .final-score {
      font-size: 1.5rem;
      color: #e0e0e0;
      margin-bottom: 20px;
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .emoji {
      display: inline-block;
      animation: bounce 1s infinite;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üéÆ Sk√°kac√≠ hra</h1>
    </div>

    <div class="game-wrapper">
      <div class="stats">
        <div class="stat-box">
          <div class="stat-label">Sk√≥re</div>
          <div class="stat-value" id="score">0</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">≈Ωivoty</div>
          <div class="stat-value" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Level</div>
          <div class="stat-value" id="level">1</div>
        </div>
      </div>

      <div style="position: relative;">
        <canvas id="gameCanvas"></canvas>
        <div class="game-over-overlay" id="gameOverOverlay">
          <h2>üéÆ Game Over!</h2>
          <div class="final-score">Koneƒçn√© sk√≥re: <span id="finalScore">0</span></div>
          <button class="btn" onclick="restartGame()">üîÑ Hr√°t znovu</button>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="startBtn" onclick="startGame()">‚ñ∂Ô∏è Start</button>
        <button class="btn secondary" onclick="togglePause()">‚è∏Ô∏è Pauza</button>
        <button class="btn secondary" onclick="restartGame()">üîÑ Restart</button>
      </div>
    </div>

    <div class="instructions">
      <h3>üìã Ovl√°d√°n√≠ a pravidla</h3>
      <ul>
        <li><strong>≈†ipka vlevo/vpravo nebo A/D:</strong> Pohyb</li>
        <li><strong>Mezern√≠k nebo ≈°ipka nahoru:</strong> Skok</li>
        <li><strong>P:</strong> Pauza</li>
        <li><strong>ü™ô Zlat√© mince:</strong> +10 bod≈Ø</li>
        <li><strong>üëæ Nep≈ô√°tel√©:</strong> Vyhnout se nebo skoƒçit na nƒõ pro +50 bod≈Ø</li>
        <li><strong>Postupuj levelama:</strong> Ka≈æd√Ωch 200 bod≈Ø = nov√Ω level (rychlej≈°√≠ hra)</li>
        <li><strong>C√≠l:</strong> Z√≠skej co nejv√≠ce bod≈Ø bez ztr√°ty v≈°ech ≈æivot≈Ø!</li>
      </ul>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Nastaven√≠ velikosti canvasu
    function resizeCanvas() {
      canvas.width = canvas.offsetWidth;
      canvas.height = 500;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Barevn√© sch√©ma z p≈ô√≠lohy
    const colors = {
      bg: '#1a1a1a',
      platform: '#404040',
      player: '#6aa6fd',
      enemy: '#ff8888',
      coin: '#ffd700',
      text: '#e0e0e0',
      accent: '#6aa6fd'
    };

    // Hern√≠ promƒõnn√©
    let gameState = {
      running: false,
      paused: false,
      score: 0,
      lives: 3,
      level: 1,
      gameOver: false
    };

    // Hr√°ƒç
    const player = {
      x: 100,
      y: 300,
      width: 30,
      height: 40,
      velocityX: 0,
      velocityY: 0,
      speed: 5,
      jumpPower: 15,
      grounded: false,
      direction: 1 // 1 = vpravo, -1 = vlevo
    };

    // Fyzika
    const gravity = 0.6;
    const friction = 0.8;

    // Platformy
    let platforms = [];
    
    // Nep≈ô√°tel√©
    let enemies = [];
    
    // Mince
    let coins = [];

    // Kl√°vesy
    const keys = {};

    // Inicializace levelu
    function initLevel() {
      platforms = [
        { x: 0, y: canvas.height - 30, width: canvas.width, height: 30 } // Podlaha
      ];

      // Parametry pro generov√°n√≠ platforem
      const maxJumpHeight = 140; // Maxim√°ln√≠ v√Ω≈°ka, kam hr√°ƒç m≈Ø≈æe skoƒçit
      const maxJumpDistance = 200; // Maxim√°ln√≠ horizont√°ln√≠ vzd√°lenost
      const minPlatformWidth = 80;
      const maxPlatformWidth = 200;
      const platformHeight = 15;
      const platformCount = 8 + gameState.level * 2; // V√≠ce platforem s vy≈°≈°√≠m levelem
      
      // Generov√°n√≠ n√°hodn√Ωch platforem
      let lastPlatform = platforms[0]; // Zaƒç√≠n√°me od podlahy
      
      for (let i = 0; i < Math.min(platformCount, 20); i++) {
        let attempts = 0;
        let newPlatform;
        let valid = false;
        
        // Pokus√≠me se naj√≠t validn√≠ pozici pro platformu
        while (!valid && attempts < 50) {
          attempts++;
          
          // N√°hodn√° ≈°√≠≈ôka platformy
          const width = minPlatformWidth + Math.random() * (maxPlatformWidth - minPlatformWidth);
          
          // V√Ω≈°ka relativnƒõ k posledn√≠ platformƒõ (ne p≈ô√≠li≈° vysoko)
          const heightDiff = -Math.random() * maxJumpHeight * 0.8;
          const y = Math.max(100, Math.min(lastPlatform.y + heightDiff, canvas.height - 100));
          
          // Horizont√°ln√≠ pozice (dosa≈æiteln√° vzd√°lenost)
          const distanceFromLast = (Math.random() - 0.3) * maxJumpDistance;
          let x = lastPlatform.x + lastPlatform.width / 2 + distanceFromLast - width / 2;
          
          // Omezen√≠ na canvas
          x = Math.max(50, Math.min(x, canvas.width - width - 50));
          
          newPlatform = { x, y, width, height: platformHeight };
          
          // Kontrola, ≈æe se nep≈ôekr√Ωv√° s existuj√≠c√≠mi platformami
          valid = true;
          for (let j = 1; j < platforms.length; j++) {
            if (checkPlatformOverlap(newPlatform, platforms[j])) {
              valid = false;
              break;
            }
          }
          
          // Kontrola dosa≈æitelnosti (nen√≠ p≈ô√≠li≈° daleko ani vysoko)
          const horizontalDist = Math.abs(newPlatform.x + newPlatform.width / 2 - 
                                         (lastPlatform.x + lastPlatform.width / 2));
          const verticalDist = Math.abs(newPlatform.y - lastPlatform.y);
          
          if (horizontalDist > maxJumpDistance || verticalDist > maxJumpHeight) {
            valid = false;
          }
        }
        
        if (valid) {
          platforms.push(newPlatform);
          // Obƒças zmƒõnit referenƒçn√≠ platformu pro vƒõt≈°√≠ variabilitu
          if (Math.random() > 0.3 || i === 0) {
            lastPlatform = newPlatform;
          }
        }
      }
      
      // P≈ôid√°n√≠ nƒõkolika n√°hodn√Ωch platforem po cel√© plo≈°e pro pokroƒçilej≈°√≠ hr√°ƒçe
      for (let i = 0; i < 3 + gameState.level; i++) {
        const width = minPlatformWidth + Math.random() * (maxPlatformWidth - minPlatformWidth);
        const x = Math.random() * (canvas.width - width);
        const y = 80 + Math.random() * (canvas.height - 200);
        
        const bonusPlatform = { x, y, width, height: platformHeight };
        
        // Kontrola p≈ôekryt√≠
        let overlaps = false;
        for (let j = 0; j < platforms.length; j++) {
          if (checkPlatformOverlap(bonusPlatform, platforms[j])) {
            overlaps = true;
            break;
          }
        }
        
        if (!overlaps) {
          platforms.push(bonusPlatform);
        }
      }

      // Generov√°n√≠ nep≈ô√°tel (pouze na platform√°ch, ne na podlaze)
      enemies = [];
      const enemyCount = 3 + gameState.level;
      const validPlatforms = platforms.filter((p, idx) => idx > 0 && p.width >= 60);
      
      for (let i = 0; i < Math.min(enemyCount, validPlatforms.length); i++) {
        const platform = validPlatforms[Math.floor(Math.random() * validPlatforms.length)];
        const enemyWidth = 30;
        const safeX = platform.x + 20 + Math.random() * Math.max(20, platform.width - 60);
        
        enemies.push({
          x: safeX,
          y: platform.y - 30,
          width: enemyWidth,
          height: 30,
          velocityX: (1 + gameState.level * 0.2) * (Math.random() > 0.5 ? 1 : -1),
          platformIndex: platforms.indexOf(platform),
          platform: platform
        });
      }

      // Generov√°n√≠ minc√≠ (rozm√≠stƒõn√© n√°hodnƒõ nad platformami)
      coins = [];
      const coinCount = 10 + gameState.level * 3;
      const coinPlatforms = platforms.filter((p, idx) => idx > 0);
      
      for (let i = 0; i < Math.min(coinCount, coinPlatforms.length * 3); i++) {
        const platform = coinPlatforms[Math.floor(Math.random() * coinPlatforms.length)];
        const coinX = platform.x + 10 + Math.random() * Math.max(10, platform.width - 30);
        const coinY = platform.y - 40 - Math.random() * 80;
        
        coins.push({
          x: coinX,
          y: Math.max(50, coinY),
          width: 20,
          height: 20,
          collected: false,
          rotation: 0
        });
      }

      // Reset pozice hr√°ƒçe na zaƒç√°tek (nad podlahou)
      player.x = 100;
      player.y = canvas.height - 100;
      player.velocityX = 0;
      player.velocityY = 0;
    }
    
    // Kontrola p≈ôekryt√≠ platforem
    function checkPlatformOverlap(p1, p2) {
      const margin = 30; // Minim√°ln√≠ mezera mezi platformami
      return p1.x < p2.x + p2.width + margin &&
             p1.x + p1.width + margin > p2.x &&
             p1.y < p2.y + p2.height + margin &&
             p1.y + p1.height + margin > p2.y;
    }

    // Vykreslen√≠ hr√°ƒçe
    function drawPlayer() {
      // Tƒõlo hr√°ƒçe
      ctx.fillStyle = colors.player;
      ctx.fillRect(player.x, player.y, player.width, player.height);
      
      // Oƒçi
      ctx.fillStyle = colors.text;
      const eyeY = player.y + 10;
      if (player.direction === 1) {
        ctx.fillRect(player.x + 18, eyeY, 6, 6);
      } else {
        ctx.fillRect(player.x + 6, eyeY, 6, 6);
      }
      
      // Nohy
      ctx.fillStyle = colors.accent;
      ctx.fillRect(player.x + 5, player.y + player.height, 8, 3);
      ctx.fillRect(player.x + player.width - 13, player.y + player.height, 8, 3);
    }

    // Vykreslen√≠ platforem
    function drawPlatforms() {
      ctx.fillStyle = colors.platform;
      platforms.forEach(platform => {
        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        // Horn√≠ zv√Ωraznƒõn√≠
        ctx.fillStyle = '#555';
        ctx.fillRect(platform.x, platform.y, platform.width, 2);
        ctx.fillStyle = colors.platform;
      });
    }

    // Vykreslen√≠ nep≈ô√°tel
    function drawEnemies() {
      enemies.forEach(enemy => {
        ctx.fillStyle = colors.enemy;
        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
        
        // Oƒçi
        ctx.fillStyle = '#fff';
        ctx.fillRect(enemy.x + 6, enemy.y + 8, 6, 6);
        ctx.fillRect(enemy.x + enemy.width - 12, enemy.y + 8, 6, 6);
        
        // Zuby
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 3; i++) {
          ctx.fillRect(enemy.x + 6 + i * 8, enemy.y + enemy.height - 6, 4, 6);
        }
      });
    }

    // Vykreslen√≠ minc√≠
    function drawCoins() {
      coins.forEach(coin => {
        if (!coin.collected) {
          ctx.save();
          ctx.translate(coin.x + coin.width / 2, coin.y + coin.height / 2);
          ctx.rotate(coin.rotation);
          ctx.fillStyle = colors.coin;
          ctx.fillRect(-coin.width / 2, -coin.height / 2, coin.width, coin.height);
          
          // St≈ôedov√Ω kruh
          ctx.fillStyle = '#ffa500';
          ctx.beginPath();
          ctx.arc(0, 0, 6, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
          coin.rotation += 0.05;
        }
      });
    }

    // Detekce kolize
    function checkCollision(rect1, rect2) {
      return rect1.x < rect2.x + rect2.width &&
             rect1.x + rect1.width > rect2.x &&
             rect1.y < rect2.y + rect2.height &&
             rect1.y + rect1.height > rect2.y;
    }

    // Update hr√°ƒçe
    function updatePlayer() {
      // Pohyb vlevo/vpravo
      if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
        player.velocityX = -player.speed;
        player.direction = -1;
      } else if (keys['ArrowRight'] || keys['d'] || keys['D']) {
        player.velocityX = player.speed;
        player.direction = 1;
      } else {
        player.velocityX *= friction;
      }

      // Skok
      if ((keys[' '] || keys['ArrowUp']) && player.grounded) {
        player.velocityY = -player.jumpPower;
        player.grounded = false;
      }

      // Gravitace
      player.velocityY += gravity;

      // Aplikace rychlosti
      player.x += player.velocityX;
      player.y += player.velocityY;

      // Omezen√≠ na okraje pl√°tna
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

      // Kontrola p√°du mimo obrazovku
      if (player.y > canvas.height) {
        loseLife();
      }

      // Kontrola koliz√≠ s platformami
      player.grounded = false;
      platforms.forEach(platform => {
        if (checkCollision(player, platform)) {
          if (player.velocityY > 0 && player.y + player.height - player.velocityY <= platform.y) {
            // P≈ôist√°n√≠ na platformƒõ
            player.y = platform.y - player.height;
            player.velocityY = 0;
            player.grounded = true;
          }
        }
      });
    }

    // Update nep≈ô√°tel
    function updateEnemies() {
      enemies.forEach(enemy => {
        enemy.x += enemy.velocityX;
        
        // Odraz od okraj≈Ø platformy
        const platform = enemy.platform;
        if (platform) {
          if (enemy.x < platform.x || enemy.x + enemy.width > platform.x + platform.width) {
            enemy.velocityX *= -1;
            // Oprava pozice, aby nep≈ô√≠tel nez≈Østal mimo platformu
            enemy.x = Math.max(platform.x, Math.min(enemy.x, platform.x + platform.width - enemy.width));
          }
        }

        // Kontrola kolize s hr√°ƒçem
        if (checkCollision(player, enemy)) {
          // Pokud hr√°ƒç skoƒçil na nep≈ô√≠tele shora
          if (player.velocityY > 0 && player.y + player.height - 20 < enemy.y) {
            // Zabit√≠ nep≈ô√≠tele
            enemies.splice(enemies.indexOf(enemy), 1);
            player.velocityY = -10; // Odraz
            updateScore(50);
          } else {
            // Hr√°ƒç dostal z√°sah
            loseLife();
          }
        }
      });
    }

    // Update minc√≠
    function updateCoins() {
      coins.forEach(coin => {
        if (!coin.collected && checkCollision(player, coin)) {
          coin.collected = true;
          updateScore(10);
        }
      });
    }

    // Aktualizace sk√≥re
    function updateScore(points) {
      gameState.score += points;
      document.getElementById('score').textContent = gameState.score;
      
      // Level up ka≈æd√Ωch 200 bod≈Ø
      const newLevel = Math.floor(gameState.score / 200) + 1;
      if (newLevel > gameState.level) {
        gameState.level = newLevel;
        document.getElementById('level').textContent = gameState.level;
        initLevel();
      }
    }

    // Ztr√°ta ≈æivota
    function loseLife() {
      if (gameState.lives <= 0) return;
      
      gameState.lives--;
      const hearts = '‚ù§Ô∏è'.repeat(Math.max(0, gameState.lives));
      document.getElementById('lives').textContent = hearts || 'üíÄ';
      
      if (gameState.lives > 0) {
        // Reset pozice hr√°ƒçe na zaƒç√°tek
        player.x = 100;
        player.y = canvas.height - 100;
        player.velocityX = 0;
        player.velocityY = 0;
      } else {
        endGame();
      }
    }

    // Konec hry
    function endGame() {
      gameState.gameOver = true;
      gameState.running = false;
      document.getElementById('finalScore').textContent = gameState.score;
      document.getElementById('gameOverOverlay').classList.add('show');
    }

    // Hlavn√≠ hern√≠ smyƒçka
    function gameLoop() {
      if (!gameState.running || gameState.paused) return;

      // Vyƒçi≈°tƒõn√≠ canvasu
      ctx.fillStyle = colors.bg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Update
      updatePlayer();
      updateEnemies();
      updateCoins();

      // Vykreslen√≠
      drawPlatforms();
      drawCoins();
      drawEnemies();
      drawPlayer();

      // Vykreslen√≠ pauzy
      if (gameState.paused) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = colors.text;
        ctx.font = '48px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('PAUZA', canvas.width / 2, canvas.height / 2);
      }

      requestAnimationFrame(gameLoop);
    }

    // Start hry
    function startGame() {
      if (gameState.running) return;
      
      gameState.running = true;
      gameState.paused = false;
      gameState.gameOver = false;
      gameState.score = 0;
      gameState.lives = 3;
      gameState.level = 1;
      
      document.getElementById('score').textContent = '0';
      document.getElementById('lives').textContent = '‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è';
      document.getElementById('level').textContent = '1';
      document.getElementById('gameOverOverlay').classList.remove('show');
      document.getElementById('startBtn').textContent = '‚ñ∂Ô∏è Bƒõ≈æ√≠...';
      
      initLevel();
      gameLoop();
    }

    // Restart hry
    function restartGame() {
      gameState.running = false;
      document.getElementById('startBtn').textContent = '‚ñ∂Ô∏è Start';
      startGame();
    }

    // Pauza
    function togglePause() {
      if (!gameState.running || gameState.gameOver) return;
      gameState.paused = !gameState.paused;
      if (!gameState.paused) {
        gameLoop();
      }
    }

    // Ovl√°d√°n√≠ kl√°vesnic√≠
    window.addEventListener('keydown', (e) => {
      keys[e.key] = true;
      
      if (e.key === 'p' || e.key === 'P') {
        togglePause();
      }
      
      // Prevence scrollov√°n√≠ p≈ôi pou≈æit√≠ ≈°ipek
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
        e.preventDefault();
      }
    });

    window.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    // Inicializace levelu p≈ôi naƒçten√≠
    initLevel();
    
    // Vykreslen√≠ √∫vodn√≠ obrazovky
    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawPlatforms();
    drawCoins();
    drawEnemies();
    drawPlayer();
    
    ctx.fillStyle = colors.accent;
    ctx.font = 'bold 36px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('üéÆ Stiskni START!', canvas.width / 2, canvas.height / 2 - 50);
    ctx.font = '20px Arial';
    ctx.fillStyle = colors.text;
    ctx.fillText('Pou≈æij ≈°ipky nebo WASD pro pohyb, mezern√≠k pro skok', canvas.width / 2, canvas.height / 2);
  </script>
</body>
</html>
