<!DOCTYPE html>
<html lang="cs" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üå≥ Heritage - Genealogick√° aplikace</title>
    
    <!-- Extern√≠ knihovny pro export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        /* --- CSS VARIABLES & THEME --- */
        :root {
            --primary: #4caf50;
            --primary-hover: #43a047;
            --danger: #e53935;
            --male-color: #64b5f6;
            --female-color: #f06292;
            --other-color: #ba68c8;
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --surface-hover: #2c2c2c;
            --border-color: #333;
            --text-main: #e0e0e0;
            --text-muted: #9e9e9e;
            --shadow: 0 4px 6px rgba(0,0,0,0.3);
            --radius: 8px;
            --sidebar-width: 340px;
            --header-height: 50px;
        }

        [data-theme="light"] {
            --bg-color: #f5f5f5;
            --surface-color: #ffffff;
            --surface-hover: #f0f0f0;
            --border-color: #ddd;
            --text-main: #212121;
            --text-muted: #616161;
            --shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        * { box-sizing: border-box; outline: none; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: var(--bg-color); color: var(--text-main); overflow: hidden; }

        /* --- LAYOUT --- */
        .app-container { display: flex; width: 100%; height: 100%; }
        
        /* SIDEBAR */
        .sidebar {
            width: var(--sidebar-width);
            background: var(--surface-color);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            z-index: 10;
            transition: transform 0.3s ease;
        }
        .sidebar-header { padding: 15px; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; }
        .app-title { font-weight: 700; font-size: 1.1rem; display: flex; align-items: center; gap: 8px; }
        
        /* TABS */
        .tabs { display: flex; border-bottom: 1px solid var(--border-color); }
        .tab-btn { flex: 1; padding: 12px; background: none; border: none; color: var(--text-muted); cursor: pointer; transition: 0.2s; border-bottom: 2px solid transparent; }
        .tab-btn.active { color: var(--primary); border-bottom-color: var(--primary); font-weight: 600; }
        .tab-btn:hover { background: var(--surface-hover); }

        /* CONTENT AREA IN SIDEBAR */
        .tab-content { flex: 1; overflow-y: auto; padding: 15px; display: none; }
        .tab-content.active { display: block; }

        /* PERSON LIST */
        .search-bar { width: 100%; padding: 10px; background: var(--bg-color); border: 1px solid var(--border-color); border-radius: var(--radius); color: var(--text-main); margin-bottom: 10px; }
        .person-list-item {
            padding: 10px; margin-bottom: 8px; background: var(--bg-color); border-radius: var(--radius); border: 1px solid var(--border-color);
            cursor: pointer; display: flex; align-items: center; gap: 10px; transition: 0.2s;
        }
        .person-list-item:hover { border-color: var(--primary); transform: translateX(2px); }
        .gender-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
        .gender-male { background: var(--male-color); }
        .gender-female { background: var(--female-color); }
        .gender-other { background: var(--other-color); }
        
        /* STATS CARDS */
        .stat-card { background: var(--bg-color); padding: 15px; border-radius: var(--radius); margin-bottom: 15px; border: 1px solid var(--border-color); }
        .stat-title { font-size: 0.85rem; color: var(--text-muted); margin-bottom: 5px; text-transform: uppercase; letter-spacing: 0.5px; }
        .stat-value { font-size: 1.5rem; font-weight: bold; }
        .progress-bar { height: 6px; background: #333; border-radius: 3px; margin-top: 8px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--primary); transition: width 0.5s; }

        /* SETTINGS */
        .setting-group { margin-bottom: 20px; }
        .setting-label { display: block; margin-bottom: 8px; color: var(--text-muted); font-size: 0.9rem; }
        .btn { width: 100%; padding: 10px; border: none; border-radius: var(--radius); cursor: pointer; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 8px; transition: 0.2s; margin-bottom: 8px; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-hover); }
        .btn-danger { background: rgba(229, 57, 53, 0.1); color: var(--danger); border: 1px solid var(--danger); }
        .btn-danger:hover { background: var(--danger); color: white; }
        .btn-outline { background: transparent; border: 1px solid var(--border-color); color: var(--text-main); }
        .btn-outline:hover { border-color: var(--primary); color: var(--primary); }
        .btn-warning { background: rgba(255, 152, 0, 0.1); color: #ff9800; border: 1px solid #ff9800; }
        .btn-warning:hover { background: #ff9800; color: white; }
        
        select, input[type="text"], input[type="date"], textarea {
            width: 100%; padding: 10px; background: var(--bg-color); border: 1px solid var(--border-color);
            border-radius: var(--radius); color: var(--text-main); margin-bottom: 10px;
        }

        /* CANVAS AREA */
        .main-area { flex: 1; position: relative; overflow: hidden; background-color: var(--bg-color); transition: opacity 0.3s ease; }
        canvas { display: block; cursor: grab; }
        canvas:active { cursor: grabbing; }

        /* OVERLAYS & CONTROLS */
        .canvas-controls { position: absolute; top: 20px; right: 20px; display: flex; flex-direction: column; gap: 10px; }
        .control-btn { width: 40px; height: 40px; border-radius: 50%; background: var(--surface-color); border: 1px solid var(--border-color); color: var(--text-main); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; box-shadow: var(--shadow); }
        .control-btn:hover { color: var(--primary); border-color: var(--primary); }

        .minimap-container {
            position: absolute; bottom: 20px; right: 20px; width: 200px; height: 150px;
            background: var(--surface-color); border: 1px solid var(--border-color); border-radius: var(--radius);
            box-shadow: var(--shadow); overflow: hidden; opacity: 0.9;
        }
        .minimap-canvas { width: 100%; height: 100%; cursor: crosshair; }

        .zoom-level { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 15px; font-size: 0.8rem; pointer-events: none; }

        /* MODAL */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7);
            z-index: 100; display: none; align-items: center; justify-content: center; backdrop-filter: blur(3px);
        }
        .modal { background: var(--surface-color); width: 600px; max-width: 90%; max-height: 90vh; border-radius: var(--radius); border: 1px solid var(--border-color); display: flex; flex-direction: column; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
        .modal-header { padding: 15px 20px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; font-weight: bold; font-size: 1.2rem; }
        .modal-body { padding: 20px; overflow-y: auto; }
        .modal-footer { padding: 15px 20px; border-top: 1px solid var(--border-color); display: flex; justify-content: flex-end; gap: 10px; }
        
        .form-row { display: flex; gap: 10px; }
        .form-group { flex: 1; }
        .form-label { display: block; margin-bottom: 5px; color: var(--text-muted); font-size: 0.85rem; }

        /* TUTORIAL */
        .tutorial-overlay {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: var(--primary); color: white; padding: 10px 20px; border-radius: 20px;
            box-shadow: var(--shadow); font-weight: 500; opacity: 0; pointer-events: none; transition: opacity 0.5s;
        }

        /* NOTIFICATIONS */
        .notification {
            position: fixed; top: 20px; right: 20px; padding: 12px 20px; border-radius: var(--radius);
            color: white; z-index: 1000; box-shadow: var(--shadow); transition: transform 0.3s ease;
            transform: translateX(150%); max-width: 300px;
        }
        .notification-info { background: var(--primary); }
        .notification-success { background: #4caf50; }
        .notification-error { background: var(--danger); }
        .notification.show { transform: translateX(0); }

        /* ANOMALIES LIST */
        .anomaly-item {
            padding: 12px; margin-bottom: 10px; background: var(--bg-color); 
            border-radius: var(--radius); border-left: 4px solid #ff9800;
        }
        .anomaly-item.error { border-left-color: var(--danger); }
        .anomaly-item.warning { border-left-color: #ff9800; }
        .anomaly-item.info { border-left-color: var(--primary); }
        .anomaly-person { font-weight: bold; color: var(--text-main); margin-bottom: 5px; }
        .anomaly-desc { font-size: 0.9rem; color: var(--text-muted); }
        .anomaly-solution { margin-top: 8px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; font-size: 0.9rem; }
        .anomaly-actions { margin-top: 8px; display: flex; gap: 8px; }
        .anomaly-count { 
            display: inline-block; background: var(--danger); color: white; 
            padding: 2px 8px; border-radius: 12px; font-size: 0.8rem; margin-left: 8px;
        }

        /* RESPONSIVE */
        @media (max-width: 768px) {
            .sidebar { position: absolute; height: 100%; transform: translateX(-100%); box-shadow: 5px 0 15px rgba(0,0,0,0.5); }
            .sidebar.open { transform: translateX(0); }
            .mobile-toggle { display: flex !important; }
            .minimap-container { display: none; }
        }
        .mobile-toggle { display: none; position: absolute; top: 15px; left: 15px; z-index: 50; background: var(--surface-color); border: 1px solid var(--border-color); width: 40px; height: 40px; border-radius: var(--radius); align-items: center; justify-content: center; cursor: pointer; }
    </style>
</head>
<body>

    <!-- Mobile Toggle -->
    <button class="mobile-toggle" id="mobileMenuBtn" onclick="toggleSidebar()">‚ò∞</button>

    <div class="app-container">
        <!-- SIDEBAR -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="app-title">üå≥ Heritage <small style="font-weight:400; color:var(--text-muted); font-size: 0.8em;">v2.0 Advanced Check</small></div>
            </div>

            <div class="tabs">
                <button class="tab-btn active" onclick="switchTab('people')">üë• Osoby</button>
                <button class="tab-btn" onclick="switchTab('stats')">üìä Statistiky</button>
                <button class="tab-btn" onclick="switchTab('settings')">‚öôÔ∏è Nastaven√≠</button>
            </div>

            <!-- TAB: PEOPLE -->
            <div id="tab-people" class="tab-content active">
                <button class="btn btn-primary" onclick="openPersonModal()">‚ûï Nov√° osoba</button>
                <input type="text" class="search-bar" id="searchBox" placeholder="üîç Hledat jm√©no..." oninput="scheduleRenderPersonList()">
                <div class="setting-label" style="display:flex; justify-content:space-between;">
                    <span>Filtry</span>
                    <small id="listCount">0 osob</small>
                </div>
                <div id="personListContainer">
                    <!-- Items rendered by JS -->
                </div>
            </div>

            <!-- TAB: STATS -->
            <div id="tab-stats" class="tab-content">
                <div class="stat-card">
                    <div class="stat-title">Celkem v rodokmenu</div>
                    <div class="stat-value" id="statTotal">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">Pomƒõr pohlav√≠</div>
                    <div style="display:flex; justify-content:space-between; font-size:0.9rem; margin-bottom:5px;">
                        <span style="color:var(--male-color)">Mu≈æi <span id="statMale">0</span></span>
                        <span style="color:var(--female-color)">≈Ωeny <span id="statFemale">0</span></span>
                    </div>
                    <div class="progress-bar" style="background: var(--female-color)">
                        <div class="progress-fill" id="statGenderBar" style="width: 50%; background: var(--male-color)"></div>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">Generace & Vƒõk</div>
                    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
                        <div>
                            <div class="stat-value" style="font-size:1.2rem;" id="statGenerations">0</div>
                            <small class="text-muted">Generac√≠</small>
                        </div>
                        <div>
                            <div class="stat-value" style="font-size:1.2rem;" id="statAvgAge">0</div>
                            <small class="text-muted">Pr≈Øm. vƒõk</small>
                        </div>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">Nejƒçastƒõj≈°√≠ jm√©no</div>
                    <div class="stat-value" style="font-size:1.2rem;" id="statCommonName">-</div>
                </div>
            </div>

            <!-- TAB: SETTINGS -->
            <div id="tab-settings" class="tab-content">
                <div class="setting-group">
                    <div class="setting-label">Vzhled aplikace</div>
                    <button class="btn btn-outline" onclick="toggleTheme()">üåì P≈ôepnout Light/Dark</button>
                </div>

                <div class="setting-group">
                    <div class="setting-label">Zobrazen√≠ na kartƒõ osoby</div>
                    <label style="display:flex; align-items:center; gap:10px; margin-bottom:5px; cursor:pointer;">
                        <input type="checkbox" id="viewDates" checked onchange="updateViewSettings()">
                        <span>üìÖ Data narozen√≠/√∫mrt√≠</span>
                    </label>
                    <label style="display:flex; align-items:center; gap:10px; margin-bottom:5px; cursor:pointer;">
                        <input type="checkbox" id="viewNames" checked onchange="updateViewSettings()">
                        <span>üìù Jm√©na a p≈ô√≠jmen√≠</span>
                    </label>
                    <label style="display:flex; align-items:center; gap:10px; margin-bottom:5px; cursor:pointer;">
                        <input type="checkbox" id="viewIcons" checked onchange="updateViewSettings()">
                        <span>üíç Ikony vztah≈Ø</span>
                    </label>
                    <label style="display:flex; align-items:center; gap:10px; margin-bottom:5px; cursor:pointer;">
                        <input type="checkbox" id="viewIds" onchange="updateViewSettings()">
                        <span>üÜî ID (Ladƒõn√≠)</span>
                    </label>
                </div>
                
                <div class="setting-group">
                    <div class="setting-label">Zobrazen√≠ stromu</div>
                    <label style="display:flex; align-items:center; gap:10px; margin-bottom:10px; cursor:pointer;">
                        <input type="checkbox" id="snapToGrid" onchange="toggleSnap()">
                        <span>üß≤ P≈ôichyt√°vat k m≈ô√≠≈æce (Snap)</span>
                    </label>
                    <button class="btn btn-outline" onclick="snapAllToGrid()">üìè Zarovnat v≈°e k m≈ô√≠≈æce</button>
                    <button class="btn btn-outline" onclick="alignGenerationsY()">üìê Zarovnat generace (Y)</button>
                    <button class="btn btn-outline" onclick="autoLayout()">üîÑ Automatick√© uspo≈ô√°d√°n√≠ (Smart)</button>
                    <button class="btn btn-outline" onclick="resetView()">üéØ Centrovat pohled</button>
                </div>

                <div class="setting-group">
                    <div class="setting-label">üéØ Pivot osoba (ko≈ôen rodokmenu)</div>
                    <select id="pivotSelect" onchange="setPivotPerson(this.value)" style="margin-bottom: 5px;">
                        <option value="">-- ≈Ω√°dn√° (zobrazit v≈°e) --</option>
                    </select>
                    <small style="font-size:0.75em; color:var(--text-muted); display:block;">
                        Osoby nepropojen√© s pivotem budou vykresleny stranou.
                    </small>
                </div>

                <div class="setting-group">
                    <div class="setting-label">Data & Export</div>
                    <button class="btn btn-outline" onclick="exportJSON()">üíæ Ulo≈æit z√°lohu (JSON)</button>
                    <button class="btn btn-outline" onclick="document.getElementById('importFile').click()">üìÇ Nahr√°t z√°lohu</button>
                    <input type="file" id="importFile" style="display:none" onchange="importJSON(this)">
                    <hr style="border:0; border-top:1px solid var(--border-color); margin:10px 0;">
                    <button class="btn btn-outline" onclick="exportPDF()">üìÑ Export do PDF</button>
                    <button class="btn btn-outline" onclick="exportSVG()">üñºÔ∏è Export do SVG</button>
                </div>

                <div class="setting-group">
                    <div class="setting-label" style="color:var(--danger)">Kontrola dat</div>
                    <button class="btn btn-warning" onclick="checkDataConsistency()">üîç Zkontrolovat logiku rodokmenu</button>
                </div>

                <div class="setting-group">
                    <div class="setting-label" style="color:var(--danger)">Nebezpeƒçn√° z√≥na</div>
                    <button class="btn btn-danger" onclick="loadSampleData()">üé≤ Nahr√°t uk√°zkov√° data</button>
                    <button class="btn btn-danger" onclick="clearAllData()">üóëÔ∏è Smazat v≈°echna data</button>
                </div>
            </div>
        </aside>

        <!-- MAIN CANVAS AREA -->
        <main class="main-area" id="mainArea">
            <div class="zoom-level" id="zoomDisplay">100%</div>
            
            <canvas id="familyTreeCanvas"></canvas>

            <div class="canvas-controls">
                <button class="control-btn" title="Zoom In (+)" onclick="zoomCanvas(1.1)">‚ûï</button>
                <button class="control-btn" title="Zoom Out (-)" onclick="zoomCanvas(0.9)">‚ûñ</button>
                <button class="control-btn" title="Reset View" onclick="resetView()">‚óé</button>
                <button class="control-btn" title="Zpƒõt (Undo)" onclick="performUndo()">‚Ü©Ô∏è</button>
            </div>

            <div class="minimap-container">
                <canvas id="miniMapCanvas" class="minimap-canvas"></canvas>
            </div>
            
            <div class="tutorial-overlay" id="tutorialOverlay">
                üí° Tip: Ctrl + Ta≈æen√≠ pro p≈ôesun osoby. Ctrl + Shift + Ta≈æen√≠ pro p≈ôesun i s p≈ôedky.
            </div>
        </main>
    </div>

    <!-- MODAL: PERSON FORM -->
    <div class="modal-overlay" id="personModal">
        <div class="modal">
            <div class="modal-header">
                <span id="modalTitle">Nov√° osoba</span>
                <button onclick="closeModal()" style="background:none; border:none; color:var(--text-main); font-size:1.5rem; cursor:pointer;">&times;</button>
            </div>
            <div class="modal-body">
                <form id="personForm">
                    <input type="hidden" id="p_id">
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Jm√©no *</label>
                            <input type="text" id="p_firstName" required placeholder="Jan">
                        </div>
                        <div class="form-group">
                            <label class="form-label">P≈ô√≠jmen√≠ *</label>
                            <input type="text" id="p_lastName" required placeholder="Nov√°k">
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Pohlav√≠</label>
                        <select id="p_gender">
                            <option value="male">‚ôÇ Mu≈æ</option>
                            <option value="female">‚ôÄ ≈Ωena</option>
                            <option value="other">‚öß Jin√©</option>
                        </select>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">üìÖ Datum narozen√≠</label>
                            <input type="date" id="p_birthDate">
                        </div>
                        <div class="form-group">
                            <label class="form-label">üïäÔ∏è Datum √∫mrt√≠</label>
                            <input type="date" id="p_deathDate">
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">üë™ Rodiƒçe</label>
                        <div class="form-row">
                            <div style="flex:1">
                                <label style="font-size:0.8em;color:var(--male-color)">Otec</label>
                                <select id="p_father" class="parent-select"><option value="">-- Nezn√°m√Ω --</option></select>
                            </div>
                            <div style="flex:1">
                                <label style="font-size:0.8em;color:var(--female-color)">Matka</label>
                                <select id="p_mother" class="parent-select"><option value="">-- Nezn√°m√° --</option></select>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">üíë Partne≈ôi</label>
                        <select id="p_partners" class="parent-select" multiple style="height: 60px;">
                            <!-- Options generated by JS -->
                        </select>
                        <small style="font-size:0.7em; color:var(--text-muted);">Dr≈æte Ctrl pro v√Ωbƒõr v√≠ce partner≈Ø</small>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">üìù Pozn√°mky</label>
                        <textarea id="p_notes" rows="3" placeholder="M√≠sto narozen√≠, povol√°n√≠..."></textarea>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" style="width:auto;" onclick="closeModal()">Zru≈°it</button>
                <button class="btn btn-primary" style="width:auto;" onclick="savePerson()">Ulo≈æit</button>
            </div>
        </div>
    </div>

    <!-- MODAL: DATA CONSISTENCY CHECK -->
    <div class="modal-overlay" id="consistencyModal">
        <div class="modal" style="width: 700px;">
            <div class="modal-header">
                <span>üîç Kontrola logiky rodokmenu</span>
                <button onclick="closeConsistencyModal()" style="background:none; border:none; color:var(--text-main); font-size:1.5rem; cursor:pointer;">&times;</button>
            </div>
            <div class="modal-body">
                <div id="consistencyResults">
                    <!-- Results will be populated here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" style="width:auto;" onclick="closeConsistencyModal()">Zav≈ô√≠t</button>
                <button class="btn btn-primary" style="width:auto;" onclick="checkDataConsistency()">‚ü≥ Zkontrolovat znovu</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * HERITAGE - GENEALOGY APP CORE LOGIC - OPTIMIZED VERSION
         * Compatible with provided JSON schema
         */

        // --- STATE MANAGEMENT ---
        const State = {
            people: [], // Array of person objects (NEW SCHEMA)
            undoStack: [],
            zoom: 1,
            pan: { x: 0, y: 0 },
            isDragging: false,
            isNodeDragging: false,
            dragStart: { x: 0, y: 0 },
            dragStartMouse: { x: 0, y: 0 }, // For precise delta calculation
            draggedNodeIds: [],
            draggedNodesInitial: {}, // Map: id -> {x, y} for absolute positioning
            hoveredNodeId: null,
            selectedNodeId: null,
            pivotId: null, // üéØ Pivot osoba - ko≈ôen rodokmenu
            canvas: null,
            ctx: null,
            miniCanvas: null,
            miniCtx: null,
            theme: 'dark',
            nodeWidth: 180,
            nodeHeight: 90,
            gridSize: 20,
            snapToGrid: false,
            viewSettings: {
                showDates: true,
                showNames: true,
                showIcons: true,
                showIds: false
            },
            eventHandlers: {},
            hasUnsavedChanges: false,
            renderTimeout: null,
            listRenderTimeout: null
        };

        // --- PERFORMANCE OPTIMIZATIONS ---
        function scheduleRender() {
            if (State.renderTimeout) clearTimeout(State.renderTimeout);
            State.renderTimeout = setTimeout(() => {
                renderCanvas();
                renderUI();
            }, 16); // ~60fps
        }

        function scheduleRenderPersonList() {
            if (State.listRenderTimeout) clearTimeout(State.listRenderTimeout);
            State.listRenderTimeout = setTimeout(() => {
                renderPersonList();
            }, 150); // Debounce search
        }

        // --- INITIALIZATION ---
        window.onload = () => {
            initCanvas();
            loadData();
            loadSettings();
            setupEventListeners();
            setupKeyboardShortcuts();
            setupTouchEvents();
            renderUI();
            
            const toast = document.getElementById('tutorialOverlay');
            toast.style.opacity = '1';
            setTimeout(() => toast.style.opacity = '0', 5000);
            
            // Default to dark theme always, unless user overrides
            applyTheme(localStorage.getItem('heritage_theme') || 'dark');
        };

        window.addEventListener('beforeunload', (e) => {
            if (State.hasUnsavedChanges) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        function initCanvas() {
            State.canvas = document.getElementById('familyTreeCanvas');
            State.ctx = State.canvas.getContext('2d');
            State.miniCanvas = document.getElementById('miniMapCanvas');
            State.miniCtx = State.miniCanvas.getContext('2d');
            resizeCanvas();
            State.pan.x = State.canvas.width / 2;
            State.pan.y = State.canvas.height / 2;
        }

        function resizeCanvas() {
            const parent = document.getElementById('mainArea');
            State.canvas.width = parent.clientWidth;
            State.canvas.height = parent.clientHeight;
            renderCanvas();
        }

        window.addEventListener('resize', resizeCanvas);

        // --- DATA OPERATIONS (CRUD - NEW SCHEMA) ---
        function createPerson(data) {
            pushUndo();
            const newPerson = {
                id: data.id || crypto.randomUUID(),
                firstName: data.firstName,
                lastName: data.lastName,
                gender: data.gender || 'male', // male, female, other
                birthDate: data.birthDate || '',
                birthPlace: data.birthPlace || '',
                deathDate: data.deathDate || '',
                deathPlace: data.deathPlace || '',
                parents: data.parents || [], // Array of IDs
                partners: data.partners || [], // Array of IDs
                notes: data.notes || '',
                x: data.x || 0,
                y: data.y || 0,
                generation: 0,
                generationOrder: 0,
                manuallyPositioned: true
            };
            State.people.push(newPerson);
            State.hasUnsavedChanges = true;
            saveData();
            scheduleRender();
            return newPerson;
        }

        function updatePerson(id, data) {
            pushUndo();
            const idx = State.people.findIndex(p => p.id === id);
            if (idx !== -1) {
                State.people[idx] = { ...State.people[idx], ...data };
                State.hasUnsavedChanges = true;
                saveData();
                scheduleRender();
            }
        }

        function deletePerson(id) {
            if(!confirm('Opravdu smazat tuto osobu?')) return;
            pushUndo();
            State.people = State.people.filter(p => p.id !== id);
            // Clean references
            State.people.forEach(p => {
                if (p.parents) p.parents = p.parents.filter(pid => pid !== id);
                if (p.partners) p.partners = p.partners.filter(pid => pid !== id);
            });
            if(State.selectedNodeId === id) State.selectedNodeId = null;
            State.hasUnsavedChanges = true;
            saveData();
            scheduleRender();
        }

        function getPerson(id) {
            return State.people.find(p => p.id === id);
        }

        // --- STORAGE ---
        function saveData() {
            localStorage.setItem('heritage_people_data', JSON.stringify(State.people));
            calculateStats();
            State.hasUnsavedChanges = false;
        }

        function loadData() {
            const data = localStorage.getItem('heritage_people_data');
            if (data) {
                let parsed = JSON.parse(data);
                // Basic migration check: if old 'name' exists but not 'firstName'
                if(parsed.length > 0 && parsed[0].name && !parsed[0].firstName) {
                     console.warn("Migrating legacy data...");
                     parsed = parsed.map(p => ({
                         id: p.id,
                         firstName: p.name,
                         lastName: p.surname,
                         gender: p.gender === 'm' ? 'male' : (p.gender === 'f' ? 'female' : 'other'),
                         birthDate: p.birthDate,
                         deathDate: p.deathDate,
                         parents: [p.fatherId, p.motherId].filter(Boolean),
                         partners: p.spouseIds || [],
                         notes: p.notes,
                         x: p.x, y: p.y,
                         manuallyPositioned: true
                     }));
                }
                State.people = parsed;
                calculateStats();
            }
        }

        function updateViewSettings() {
            State.viewSettings.showDates = document.getElementById('viewDates').checked;
            State.viewSettings.showNames = document.getElementById('viewNames').checked;
            State.viewSettings.showIcons = document.getElementById('viewIcons').checked;
            State.viewSettings.showIds = document.getElementById('viewIds').checked;
            localStorage.setItem('heritage_view_settings', JSON.stringify(State.viewSettings));
            renderCanvas();
        }

        function toggleSnap() {
            State.snapToGrid = document.getElementById('snapToGrid').checked;
            localStorage.setItem('heritage_snap', State.snapToGrid);
        }

        // --- SNAP ALL TO GRID (Estetick√© zarovn√°n√≠) ---
        function snapAllToGrid() {
            if (State.people.length === 0) return;
            pushUndo();
            
            State.people.forEach(p => {
                p.x = Math.round(p.x / State.gridSize) * State.gridSize;
                p.y = Math.round(p.y / State.gridSize) * State.gridSize;
            });
            
            State.hasUnsavedChanges = true;
            saveData();
            renderCanvas();
            showNotification('V≈°echny osoby zarovn√°ny k m≈ô√≠≈æce', 'success');
        }

        // --- PIVOT PERSON FUNCTIONS ---
        function setPivotPerson(personId) {
            State.pivotId = personId || null;
            localStorage.setItem('heritage_pivot', State.pivotId || '');
            renderCanvas();
            
            if (State.pivotId) {
                const pivot = getPerson(State.pivotId);
                showNotification(`Pivot nastaven: ${pivot.firstName} ${pivot.lastName}`, 'info');
            } else {
                showNotification('Pivot odstranƒõn - zobrazuj√≠ se v≈°echny osoby', 'info');
            }
        }

        function updatePivotSelect() {
            const select = document.getElementById('pivotSelect');
            if (!select) return;
            
            const currentValue = State.pivotId || '';
            select.innerHTML = '<option value="">-- ≈Ω√°dn√° (zobrazit v≈°e) --</option>';
            
            State.people.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.id;
                opt.textContent = `${p.lastName}, ${p.firstName}`;
                if (p.id === currentValue) opt.selected = true;
                select.appendChild(opt);
            });
        }

        /**
         * Zjist√≠, zda je osoba propojena s pivot osobou (p≈ôes rodiƒçe, dƒõti nebo partnery)
         */
        function isConnectedToPivot(personId) {
            if (!State.pivotId) return true; // Bez pivotu jsou v≈°ichni "propojeni"
            if (personId === State.pivotId) return true;
            
            const visited = new Set();
            const queue = [State.pivotId];
            
            while (queue.length > 0) {
                const currentId = queue.shift();
                if (visited.has(currentId)) continue;
                visited.add(currentId);
                
                if (currentId === personId) return true;
                
                const person = getPerson(currentId);
                if (!person) continue;
                
                // P≈ôidej rodiƒçe
                if (person.parents) {
                    person.parents.forEach(pid => {
                        if (!visited.has(pid)) queue.push(pid);
                    });
                }
                
                // P≈ôidej partnery
                if (person.partners) {
                    person.partners.forEach(pid => {
                        if (!visited.has(pid)) queue.push(pid);
                    });
                }
                
                // P≈ôidej dƒõti
                State.people.forEach(p => {
                    if (p.parents && p.parents.includes(currentId) && !visited.has(p.id)) {
                        queue.push(p.id);
                    }
                });
            }
            
            return false;
        }

        /**
         * Vr√°t√≠ v≈°echny osoby propojen√©/nepropojen√© s pivotem
         */
        function getConnectedAndDisconnected() {
            if (!State.pivotId) {
                return { connected: State.people, disconnected: [] };
            }
            
            const connected = [];
            const disconnected = [];
            
            State.people.forEach(p => {
                if (isConnectedToPivot(p.id)) {
                    connected.push(p);
                } else {
                    disconnected.push(p);
                }
            });
            
            return { connected, disconnected };
        }

        function loadSettings() {
            const savedView = localStorage.getItem('heritage_view_settings');
            if (savedView) {
                State.viewSettings = JSON.parse(savedView);
                document.getElementById('viewDates').checked = State.viewSettings.showDates;
                document.getElementById('viewNames').checked = State.viewSettings.showNames;
                document.getElementById('viewIcons').checked = State.viewSettings.showIcons;
                document.getElementById('viewIds').checked = State.viewSettings.showIds;
            }
            const savedSnap = localStorage.getItem('heritage_snap');
            if (savedSnap !== null) {
                State.snapToGrid = (savedSnap === 'true');
                document.getElementById('snapToGrid').checked = State.snapToGrid;
            }
            // Naƒçten√≠ pivot osoby
            const savedPivot = localStorage.getItem('heritage_pivot');
            if (savedPivot) {
                State.pivotId = savedPivot;
            }
        }

        function pushUndo() {
            if(State.undoStack.length > 20) State.undoStack.shift();
            State.undoStack.push(JSON.stringify(State.people));
        }

        function performUndo() {
            if(State.undoStack.length === 0) return;
            const prev = State.undoStack.pop();
            State.people = JSON.parse(prev);
            saveData();
            scheduleRender();
        }

        // --- RENDERING ---
        function renderCanvas() {
            if (!State.people.length) {
                State.ctx.clearRect(0, 0, State.canvas.width, State.canvas.height);
                return;
            }

            requestAnimationFrame(() => {
                const ctx = State.ctx;
                const w = State.canvas.width;
                const h = State.canvas.height;

                ctx.clearRect(0, 0, w, h);
                
                ctx.save();
                ctx.translate(State.pan.x, State.pan.y);
                ctx.scale(State.zoom, State.zoom);

                drawGrid(ctx); // Draw the raster

                // 1. Draw Connections
                ctx.strokeStyle = State.theme === 'dark' ? '#555' : '#ccc';
                ctx.lineWidth = 2;

                State.people.forEach(p => {
                    // PARENTS
                    if (p.parents && p.parents.length > 0) {
                        p.parents.forEach(pid => {
                            const parent = getPerson(pid);
                            if (parent) {
                                // Color based on parent gender
                                const color = parent.gender === 'male' ? '#64b5f6' : (parent.gender === 'female' ? '#f06292' : '#ba68c8');
                                drawLink(p, parent, color);
                            }
                        });
                    }
                    
                    // PARTNERS (draw once)
                    if (p.partners && p.partners.length > 0) {
                        p.partners.forEach(sId => {
                            const partner = getPerson(sId);
                            if (partner && p.id < partner.id) {
                                drawSpouseLink(p, partner);
                            }
                        });
                    }
                });

                // 2. Draw Nodes
                State.people.forEach(p => {
                    drawNode(ctx, p);
                });

                ctx.restore();
                renderMiniMap();
                document.getElementById('zoomDisplay').textContent = Math.round(State.zoom * 100) + '%';
            });
        }

        function drawGrid(ctx) {
            // Calculates visible bounds in "world" coordinates to optimize drawing
            // We are already inside ctx.translate/scale, so we draw in world coords.
            
            const gridSize = State.gridSize;
            
            // Current viewport in world coords
            const viewL = -State.pan.x / State.zoom;
            const viewT = -State.pan.y / State.zoom;
            const viewR = viewL + State.canvas.width / State.zoom;
            const viewB = viewT + State.canvas.height / State.zoom;

            // Expand slightly to avoid flickering edges
            const startX = Math.floor(viewL / gridSize) * gridSize;
            const startY = Math.floor(viewT / gridSize) * gridSize;
            const endX = Math.ceil(viewR / gridSize) * gridSize;
            const endY = Math.ceil(viewB / gridSize) * gridSize;

            ctx.lineWidth = 1 / State.zoom; // Keep lines thin regardless of zoom
            if (ctx.lineWidth < 0.5) ctx.lineWidth = 0.5;

            // Choose grid color based on theme
            const colorSmall = State.theme === 'dark' ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)';
            const colorBig = State.theme === 'dark' ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';

            // Small grid
            ctx.beginPath();
            ctx.strokeStyle = colorSmall;
            for (let x = startX; x <= endX; x += gridSize) {
                if (x % (gridSize * 5) !== 0) { ctx.moveTo(x, viewT); ctx.lineTo(x, viewB); }
            }
            for (let y = startY; y <= endY; y += gridSize) {
                if (y % (gridSize * 5) !== 0) { ctx.moveTo(viewL, y); ctx.lineTo(viewR, y); }
            }
            ctx.stroke();

            // Big grid (every 5 cells = 100px)
            const bigGrid = gridSize * 5;
            const bigStartX = Math.floor(viewL / bigGrid) * bigGrid;
            const bigStartY = Math.floor(viewT / bigGrid) * bigGrid;
            
            ctx.beginPath();
            ctx.strokeStyle = colorBig;
            for (let x = bigStartX; x <= endX; x += bigGrid) {
                ctx.moveTo(x, viewT); ctx.lineTo(x, viewB);
            }
            for (let y = bigStartY; y <= endY; y += bigGrid) {
                ctx.moveTo(viewL, y); ctx.lineTo(viewR, y);
            }
            ctx.stroke();
        }

        function drawLink(child, parent, color) {
            if(!parent) return;
            const ctx = State.ctx;
            ctx.beginPath();
            ctx.strokeStyle = color || '#888';
            
            // Smart Link: Curve from bottom of parent to top of child
            const startX = parent.x + State.nodeWidth / 2;
            const startY = parent.y + State.nodeHeight;
            const endX = child.x + State.nodeWidth / 2;
            const endY = child.y;

            const cp1x = startX;
            const cp1y = startY + 60; // More curvature
            const cp2x = endX;
            const cp2y = endY - 60;

            ctx.moveTo(startX, startY);
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
            ctx.stroke();
        }

        function drawSpouseLink(p1, p2) {
            const ctx = State.ctx;
            ctx.beginPath();
            ctx.strokeStyle = '#ba68c8';
            ctx.setLineDash([5, 5]);
            
            // Link centers if they are close (horizontal)
            const startX = p1.x + State.nodeWidth;
            const startY = p1.y + State.nodeHeight / 2;
            const endX = p2.x;
            const endY = p2.y + State.nodeHeight / 2;
            
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.font = '14px Arial';
            ctx.fillStyle = '#ba68c8';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚ù§', (startX + endX)/2, (startY + endY)/2);
        }

        function drawNode(ctx, p) {
            const x = p.x;
            const y = p.y;
            const w = State.nodeWidth;
            const h = State.nodeHeight;
            
            // Zjisti, zda je osoba propojena s pivotem
            const connectedToPivot = isConnectedToPivot(p.id);
            const isPivot = State.pivotId === p.id;
            const isDisconnected = State.pivotId && !connectedToPivot;

            // Nastav pr≈Øhlednost pro nepropojen√© osoby
            if (isDisconnected) {
                ctx.globalAlpha = 0.4;
            }

            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 4;

            ctx.fillStyle = State.theme === 'dark' ? '#2c2c2c' : '#fff';
            if (State.selectedNodeId === p.id) ctx.fillStyle = State.theme === 'dark' ? '#383838' : '#f0f8ff';
            if (isPivot) ctx.fillStyle = State.theme === 'dark' ? '#3d3d1a' : '#fffacd'; // ≈Ωlut√Ω podklad pro pivot
            
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, 8);
            ctx.fill();
            
            ctx.shadowColor = 'transparent';
            
            // Barva okraje
            if (isPivot) {
                ctx.lineWidth = 4;
                ctx.strokeStyle = '#ffd700'; // Zlat√Ω r√°meƒçek pro pivot
            } else {
                ctx.lineWidth = State.selectedNodeId === p.id ? 3 : 2;
                if (p.gender === 'male') ctx.strokeStyle = '#64b5f6';
                else if (p.gender === 'female') ctx.strokeStyle = '#f06292';
                else ctx.strokeStyle = '#ba68c8';
            }
            ctx.stroke();

            ctx.fillStyle = State.theme === 'dark' ? '#eee' : '#222';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';

            if (State.viewSettings.showNames) {
                ctx.font = 'bold 14px sans-serif';
                // USE NEW FIELDS
                ctx.fillText(`${p.firstName} ${p.lastName}`, x + 10, y + 10);
            }

            if (State.viewSettings.showDates) {
                ctx.font = '11px sans-serif';
                ctx.fillStyle = State.theme === 'dark' ? '#aaa' : '#666';
                const birthYear = p.birthDate ? new Date(p.birthDate).getFullYear() : '?';
                const deathYear = p.deathDate ? new Date(p.deathDate).getFullYear() : '';
                const dateText = deathYear ? `${birthYear} - ${deathYear} üïäÔ∏è` : `* ${birthYear}`;
                const dateY = State.viewSettings.showNames ? y + 32 : y + 10;
                ctx.fillText(dateText, x + 10, dateY);
            }

            if (State.viewSettings.showIds) {
                ctx.font = '10px monospace';
                ctx.fillStyle = 'var(--primary)';
                ctx.fillText(`ID: ${p.id.substring(0,4)}`, x + 10, y + h - 15);
            }

            if(State.viewSettings.showIcons && p.partners && p.partners.length > 0) {
                 ctx.font = '14px sans-serif';
                 ctx.fillText(`üíç`, x + w - 25, y + h - 25);
            }
            
            // Ikona pivot
            if (isPivot) {
                ctx.font = '16px sans-serif';
                ctx.fillText(`üéØ`, x + w - 25, y + 8);
            }
            
            // Reset pr≈Øhlednosti
            ctx.globalAlpha = 1.0;
        }

        function renderMiniMap() {
            const mCtx = State.miniCtx;
            const mW = State.miniCanvas.width = State.miniCanvas.clientWidth;
            const mH = State.miniCanvas.height = State.miniCanvas.clientHeight;
            
            mCtx.clearRect(0, 0, mW, mH);
            if(State.people.length === 0) return;
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            State.people.forEach(p => {
                if(p.x < minX) minX = p.x;
                if(p.y < minY) minY = p.y;
                if(p.x + State.nodeWidth > maxX) maxX = p.x + State.nodeWidth;
                if(p.y + State.nodeHeight > maxY) maxY = p.y + State.nodeHeight;
            });

            const worldW = Math.max(maxX - minX, 1000);
            const worldH = Math.max(maxY - minY, 1000);
            const scaleX = mW / (worldW + 200);
            const scaleY = mH / (worldH + 200);
            const scale = Math.min(scaleX, scaleY);

            const offsetX = (mW - worldW * scale) / 2 - minX * scale;
            const offsetY = (mH - worldH * scale) / 2 - minY * scale;

            mCtx.fillStyle = 'rgba(255,255,255,0.3)';
            State.people.forEach(p => {
                mCtx.fillRect(p.x * scale + offsetX, p.y * scale + offsetY, State.nodeWidth * scale, State.nodeHeight * scale);
            });

            mCtx.strokeStyle = 'var(--primary)';
            mCtx.lineWidth = 2;
            const vpX = (-State.pan.x / State.zoom) * scale + offsetX;
            const vpY = (-State.pan.y / State.zoom) * scale + offsetY;
            const vpW = (State.canvas.width / State.zoom) * scale;
            const vpH = (State.canvas.height / State.zoom) * scale;

            mCtx.strokeRect(vpX, vpY, vpW, vpH);
        }

        // --- INTERACTION ---
        function setupEventListeners() {
            const c = State.canvas;
            
            // Store handlers for cleanup
            State.eventHandlers = {
                mousemove: (e) => handleMouseMove(e),
                mouseup: () => handleMouseUp(),
                wheel: (e) => handleWheel(e),
                dblclick: (e) => handleDoubleClick(e)
            };

            c.addEventListener('mousedown', (e) => handleMouseDown(e));
            window.addEventListener('mousemove', State.eventHandlers.mousemove);
            window.addEventListener('mouseup', State.eventHandlers.mouseup);
            c.addEventListener('wheel', State.eventHandlers.wheel, { passive: false });
            c.addEventListener('dblclick', State.eventHandlers.dblclick);
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key) {
                        case 'n': 
                            e.preventDefault(); 
                            openPersonModal(); 
                            break;
                        case 'z': 
                            e.preventDefault(); 
                            performUndo(); 
                            break;
                        case 'f': 
                            e.preventDefault(); 
                            document.getElementById('searchBox').focus(); 
                            break;
                    }
                }
            });
        }

        function setupTouchEvents() {
            State.canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            State.canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            State.canvas.addEventListener('touchend', handleTouchEnd);
        }

        function cleanup() {
            if (State.eventHandlers) {
                window.removeEventListener('mousemove', State.eventHandlers.mousemove);
                window.removeEventListener('mouseup', State.eventHandlers.mouseup);
                State.canvas.removeEventListener('wheel', State.eventHandlers.wheel);
                State.canvas.removeEventListener('dblclick', State.eventHandlers.dblclick);
            }
        }

        function handleMouseDown(e) {
            const mousePos = getMousePos(e);
            const clickedNode = State.people.slice().reverse().find(p => isInside(mousePos, p));

            // Save exact raw mouse position for delta calculation
            State.dragStartMouse = { x: mousePos.x, y: mousePos.y };
            State.dragStart = { x: e.clientX - State.pan.x, y: e.clientY - State.pan.y }; // For panning

            if (clickedNode) {
                State.selectedNodeId = clickedNode.id;
                
                if (e.ctrlKey) {
                    State.isNodeDragging = true;
                    if (e.shiftKey) {
                        State.draggedNodeIds = getAncestors(clickedNode.id);
                    } else {
                        State.draggedNodeIds = [clickedNode.id];
                    }
                    
                    // SNAP LOGIC FIX: Store initial node positions
                    State.draggedNodesInitial = {};
                    State.draggedNodeIds.forEach(id => {
                         const p = getPerson(id);
                         if(p) State.draggedNodesInitial[id] = {x: p.x, y: p.y};
                    });
                    
                } else {
                    State.isNodeDragging = false;
                    State.draggedNodeIds = [];
                }

            } else {
                State.selectedNodeId = null;
                State.isDragging = true;
            }
            renderCanvas();
            renderUI(); 
        }

        function handleMouseMove(e) {
            const mousePos = getMousePos(e);
            
            if (State.isNodeDragging && State.draggedNodeIds.length > 0) {
                // SNAP LOGIC FIX: Calculate absolute delta from start of drag
                // instead of incremental deltas which cause accumulation errors with snapping.
                const dx = mousePos.x - State.dragStartMouse.x;
                const dy = mousePos.y - State.dragStartMouse.y;
                
                State.draggedNodeIds.forEach(id => {
                    const p = getPerson(id);
                    const initial = State.draggedNodesInitial[id];
                    
                    if (p && initial) {
                        let newX = initial.x + dx;
                        let newY = initial.y + dy;
                        
                        // Apply snap to the theoretical absolute position
                        if (State.snapToGrid) {
                            newX = Math.round(newX / State.gridSize) * State.gridSize;
                            newY = Math.round(newY / State.gridSize) * State.gridSize;
                        }
                        
                        p.x = newX;
                        p.y = newY;
                        p.manuallyPositioned = true; 
                    }
                });
                
                renderCanvas();
            } else if (State.isDragging) {
                State.pan.x = e.clientX - State.dragStart.x;
                State.pan.y = e.clientY - State.dragStart.y;
                renderCanvas();
            }
        }

        function handleMouseUp() {
            if(State.isNodeDragging) {
                State.hasUnsavedChanges = true;
                saveData();
            }
            State.isDragging = false;
            State.isNodeDragging = false;
            State.draggedNodeIds = [];
            State.draggedNodesInitial = {};
        }

        function handleWheel(e) {
            e.preventDefault();
            const zoomIntensity = 0.1;
            const direction = e.deltaY > 0 ? -1 : 1;
            const factor = 1 + (direction * zoomIntensity);
            
            // Z√≠sk√°n√≠ pozice my≈°i pro zoom k kurzoru
            const rect = State.canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            zoomCanvas(factor, { x: mouseX, y: mouseY });
        }

        function handleDoubleClick(e) {
            const mousePos = getMousePos(e);
            const clickedNode = State.people.find(p => isInside(mousePos, p));
            if(clickedNode) {
                openPersonModal(clickedNode.id);
            } else {
                let screenX = (e.offsetX - State.pan.x) / State.zoom;
                let screenY = (e.offsetY - State.pan.y) / State.zoom;
                
                if (State.snapToGrid) {
                    screenX = Math.round(screenX / State.gridSize) * State.gridSize;
                    screenY = Math.round(screenY / State.gridSize) * State.gridSize;
                }
                
                openPersonModal(null, {x: screenX, y: screenY});
            }
        }

        function handleTouchStart(e) {
            if (e.touches.length === 2) {
                // Implementace pinch-to-zoom
                e.preventDefault();
                // Store initial touch positions for pinch detection
                State.touchStartDistance = getTouchDistance(e.touches);
                State.touchStartZoom = State.zoom;
            }
        }

        function handleTouchMove(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                const currentDistance = getTouchDistance(e.touches);
                const scale = currentDistance / State.touchStartDistance;
                zoomCanvas(State.touchStartZoom * scale);
            }
        }

        function handleTouchEnd() {
            // Clean up touch state
            State.touchStartDistance = null;
            State.touchStartZoom = null;
        }

        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getMousePos(evt) {
            const rect = State.canvas.getBoundingClientRect();
            const x = (evt.clientX - rect.left - State.pan.x) / State.zoom;
            const y = (evt.clientY - rect.top - State.pan.y) / State.zoom;
            return { x, y };
        }

        function isInside(pos, node) {
            return pos.x > node.x && pos.x < node.x + State.nodeWidth &&
                   pos.y > node.y && pos.y < node.y + State.nodeHeight;
        }

        function getAncestors(startId, set = new Set()) {
            if (!startId) return [];
            set.add(startId);
            const p = getPerson(startId);
            if (p && p.parents) {
                p.parents.forEach(pid => getAncestors(pid, set));
            }
            return Array.from(set);
        }

        function zoomCanvas(factor, centerPoint = null) {
            // Pokud nen√≠ urƒçen st≈ôed (nap≈ô. tlaƒç√≠tka +/-), pou≈æijeme st≈ôed pl√°tna
            if (!centerPoint) {
                centerPoint = { 
                    x: State.canvas.width / 2, 
                    y: State.canvas.height / 2 
                };
            }

            // 1. Vypoƒç√≠tat svƒõtov√© sou≈ôadnice pod my≈°√≠ P≈òED zoomem
            const worldX = (centerPoint.x - State.pan.x) / State.zoom;
            const worldY = (centerPoint.y - State.pan.y) / State.zoom;

            // 2. Aplikovat nov√Ω zoom
            if(typeof factor === 'number') {
                 State.zoom *= factor;
            } else {
                State.zoom = factor;
            }
            State.zoom = Math.min(Math.max(State.zoom, 0.1), 5);

            // 3. Vypoƒç√≠tat nov√Ω Pan tak, aby svƒõtov√Ω bod z≈Østal pod my≈°√≠
            // mouseX = worldX * newZoom + newPanX  =>  newPanX = mouseX - worldX * newZoom
            State.pan.x = centerPoint.x - worldX * State.zoom;
            State.pan.y = centerPoint.y - worldY * State.zoom;

            renderCanvas();
        }

        function resetView() {
            State.zoom = 1;
            const w = State.canvas.width;
            const h = State.canvas.height;
            
            // Prioritnƒõ centruj na pivot, jinak na prvn√≠ osobu
            let targetPerson = null;
            
            if (State.pivotId) {
                targetPerson = getPerson(State.pivotId);
            }
            
            if (!targetPerson && State.people.length > 0) {
                targetPerson = State.people[0];
            }
            
            if (targetPerson) {
                State.pan.x = w/2 - (targetPerson.x + State.nodeWidth/2);
                State.pan.y = h/2 - (targetPerson.y + State.nodeHeight/2);
            } else {
                State.pan.x = w/2;
                State.pan.y = h/2;
            }
            
            renderCanvas();
        }

        // --- ALIGN GENERATIONS Y (PIVOT-CENTRIC) ---
        function alignGenerationsY() {
            pushUndo();
            if(State.people.length === 0) return;
            
            // Pou≈æij pivot nebo najdi v√Ωchoz√≠ bod
            let rootId = State.pivotId;
            if (!rootId) {
                const leaves = State.people.filter(p => {
                    return !State.people.some(c => c.parents && c.parents.includes(p.id));
                });
                rootId = leaves.length > 0 ? leaves[0].id : State.people[0].id;
            }
            
            // Spoƒç√≠tej generace od pivotu
            calculateGenerationsFromPivot(rootId);
            
            // Najdi max level pro v√Ωpoƒçet Y
            let maxLevel = 0;
            State.people.forEach(p => {
                if (p.levelFromPivot !== null && p.levelFromPivot !== 999 && p.levelFromPivot > maxLevel) {
                    maxLevel = p.levelFromPivot;
                }
            });
            
            // Nastav Y sou≈ôadnice podle generace
            // Pivot (level 0) je dole, p≈ôedci (vy≈°≈°√≠ level) jsou naho≈ôe
            const STEP_Y = 180;
            const pivotY = maxLevel * STEP_Y;
            
            State.people.forEach(p => {
                if (p.levelFromPivot !== null && p.levelFromPivot !== 999) {
                    p.y = pivotY - p.levelFromPivot * STEP_Y;
                }
            });
            
            State.hasUnsavedChanges = true;
            saveData();
            renderCanvas();
            showNotification('Generace zarovn√°ny podle pivotu', 'success');
        }

        // --- HELPER: CALCULATE GENERATIONS (BOTTOM-UP BFS) ---
        function calculateGenerations() {
            // 1. Reset and build child map to find leaves
            const childMap = new Map(); // parentId -> [childIds]
            const partnerMap = new Map(); // personId -> Set(partnerIds)
            
            State.people.forEach(p => {
                p.levelFromBottom = null; // Reset
                if (!childMap.has(p.id)) childMap.set(p.id, []);
                if (!partnerMap.has(p.id)) partnerMap.set(p.id, new Set());
                
                if (p.parents) {
                    p.parents.forEach(pid => {
                        if (!childMap.has(pid)) childMap.set(pid, []);
                        childMap.get(pid).push(p.id);
                    });
                }
                
                if (p.partners) {
                    p.partners.forEach(pid => {
                        partnerMap.get(p.id).add(pid);
                        if (!partnerMap.has(pid)) partnerMap.set(pid, new Set());
                        partnerMap.get(pid).add(p.id);
                    });
                }
            });

            // 2. Identify Leaves (People who are NOT parents to anyone in this set)
            const leaves = State.people.filter(p => {
                const children = childMap.get(p.id);
                return !children || children.length === 0;
            });

            // 3. BFS Queue to propagate upwards
            const queue = [];
            const processed = new Set();
            
            leaves.forEach(l => {
                l.levelFromBottom = 0;
                queue.push(l);
                processed.add(l.id);
            });

            // 4. Process with proper BFS
            while (queue.length > 0) {
                const current = queue.shift();
                const currentLevel = current.levelFromBottom;

                // A. PARTNER SYNC - ensure partners are at same level
                if (partnerMap.has(current.id)) {
                    partnerMap.get(current.id).forEach(pid => {
                        const partner = getPerson(pid);
                        if (partner && !processed.has(partner.id)) {
                            // Partners should be at the same level
                            partner.levelFromBottom = currentLevel;
                            processed.add(partner.id);
                            queue.push(partner);
                        }
                    });
                }

                // B. PARENT PROPAGATION
                if (current.parents && current.parents.length > 0) {
                    const nextLevel = currentLevel + 1;
                    current.parents.forEach(pid => {
                        const parent = getPerson(pid);
                        if (parent && !processed.has(parent.id)) {
                            // Only update if we found a deeper path
                            if (parent.levelFromBottom === null || parent.levelFromBottom < nextLevel) {
                                parent.levelFromBottom = nextLevel;
                            }
                            processed.add(parent.id);
                            queue.push(parent);
                        }
                    });
                }
            }
            
            // Fallback for disconnected nodes
            State.people.forEach(p => {
                if (p.levelFromBottom === null) {
                    p.levelFromBottom = 0;
                    console.warn(`Person ${p.firstName} ${p.lastName} has no generation assignment`);
                }
            });

            // Group by Level (0 = Bottom/Youngest)
            const generations = {};
            State.people.forEach(p => {
                const lvl = p.levelFromBottom;
                if(!generations[lvl]) generations[lvl] = [];
                generations[lvl].push(p);
            });
            
            return generations;
        }

        // --- AUTO LAYOUT (PIVOT-CENTRIC, COMPACT) ---
        function autoLayout() {
            pushUndo();
            if (State.people.length === 0) return;

            // Pokud nen√≠ pivot, pou≈æij prvn√≠ osobu bez dƒõt√≠ (list)
            let rootId = State.pivotId;
            if (!rootId) {
                // Najdi osobu bez dƒõt√≠ jako v√Ωchoz√≠ bod
                const leaves = State.people.filter(p => {
                    return !State.people.some(c => c.parents && c.parents.includes(p.id));
                });
                rootId = leaves.length > 0 ? leaves[0].id : State.people[0].id;
            }

            // 1. Spoƒç√≠tej generace od pivotu (pivot = 0, jeho rodiƒçe = 1, prarodiƒçe = 2...)
            calculateGenerationsFromPivot(rootId);
            
            // 2. Rozdƒõl na propojen√© a nepropojen√©
            const { connected, disconnected } = getConnectedAndDisconnected();
            
            // 3. Layout propojen√Ωch osob
            if (connected.length > 0) {
                layoutConnectedTree(connected, rootId);
            }
            
            // 4. Layout nepropojen√Ωch osob (stranou)
            if (disconnected.length > 0) {
                layoutDisconnected(disconnected);
            }
            
            State.hasUnsavedChanges = true;
            saveData();
            renderCanvas();
            resetView();
        }

        /**
         * Vypoƒç√≠t√° generace od pivotu smƒõrem nahoru k p≈ôedk≈Øm
         * Pivot = 0, rodiƒçe pivotu = 1, prarodiƒçe = 2, atd.
         */
        function calculateGenerationsFromPivot(pivotId) {
            // Reset
            State.people.forEach(p => {
                p.levelFromPivot = null;
                p.subtreeWidth = 1; // V√Ωchoz√≠ ≈°√≠≈ôka
            });
            
            const pivot = getPerson(pivotId);
            if (!pivot) return;
            
            // BFS od pivotu smƒõrem k p≈ôedk≈Øm
            const queue = [{id: pivotId, level: 0}];
            const visited = new Set();
            
            while (queue.length > 0) {
                const {id, level} = queue.shift();
                if (visited.has(id)) continue;
                visited.add(id);
                
                const person = getPerson(id);
                if (!person) continue;
                
                person.levelFromPivot = level;
                
                // P≈ôidej rodiƒçe (o level v√Ω≈°)
                if (person.parents) {
                    person.parents.forEach(parentId => {
                        if (!visited.has(parentId)) {
                            queue.push({id: parentId, level: level + 1});
                        }
                    });
                }
                
                // P≈ôidej partnery (stejn√Ω level)
                if (person.partners) {
                    person.partners.forEach(partnerId => {
                        if (!visited.has(partnerId)) {
                            queue.push({id: partnerId, level: level});
                        }
                    });
                }
                
                // P≈ôidej dƒõti (o level n√≠≈æ) - pouze pokud jdeme od pivotu dol≈Ø
                if (level <= 0) {
                    State.people.forEach(child => {
                        if (child.parents && child.parents.includes(id) && !visited.has(child.id)) {
                            queue.push({id: child.id, level: level - 1});
                        }
                    });
                }
            }
            
            // Nastav nep≈ôi≈ôazen√© osoby
            State.people.forEach(p => {
                if (p.levelFromPivot === null) {
                    p.levelFromPivot = 999; // Nepropojen√©
                }
            });
        }

        /**
         * Hlavn√≠ layout algoritmus - kompaktn√≠ pyramida s pivotem dole
         */
        function layoutConnectedTree(people, pivotId) {
            const STEP_Y = 180;
            const NODE_GAP = 30;
            const PARTNER_GAP = 20;
            
            // 1. Seskup podle generac√≠
            const generations = {};
            let minLevel = Infinity, maxLevel = -Infinity;
            
            people.forEach(p => {
                const lvl = p.levelFromPivot;
                if (lvl === 999) return; // P≈ôeskoƒç nepropojen√©
                
                if (!generations[lvl]) generations[lvl] = [];
                generations[lvl].push(p);
                
                if (lvl < minLevel) minLevel = lvl;
                if (lvl > maxLevel) maxLevel = lvl;
            });
            
            // 2. Spoƒç√≠tej "v√°hu" ka≈æd√© osoby (poƒçet potomk≈Ø smƒõrem k pivotu)
            calculateSubtreeWeights(pivotId);
            
            // 3. Vypoƒç√≠tej Y offset tak, aby pivot byl dole
            // Pivot (level 0) bude na Y = maxLevel * STEP_Y (dole)
            // Nejstar≈°√≠ p≈ôedci budou na Y = 0 (naho≈ôe)
            const pivotY = maxLevel * STEP_Y;
            
            // 4. Layout od pivotu nahoru
            // Nejprve um√≠sti pivot a jeho generaci (level 0)
            const pivotGen = generations[0] || [];
            if (pivotGen.length > 0) {
                // Seskup partnery
                const blocks = groupIntoPartnerBlocks(pivotGen);
                let totalWidth = 0;
                blocks.forEach(block => {
                    totalWidth += block.length * (State.nodeWidth + PARTNER_GAP) - PARTNER_GAP + NODE_GAP;
                });
                totalWidth -= NODE_GAP;
                
                // Pozicuj bloky od st≈ôedu
                let currentX = -totalWidth / 2;
                blocks.forEach(block => {
                    block.forEach((person, i) => {
                        person.x = currentX + i * (State.nodeWidth + PARTNER_GAP);
                        person.y = pivotY; // Pivot je dole
                    });
                    currentX += block.length * (State.nodeWidth + PARTNER_GAP) - PARTNER_GAP + NODE_GAP;
                });
            }
            
            // 5. Layout dƒõt√≠ (pod pivotem, level < 0)
            for (let lvl = -1; lvl >= minLevel; lvl--) {
                const gen = generations[lvl];
                if (!gen) continue;
                
                const y = pivotY - lvl * STEP_Y; // Dƒõti jsou POD pivotem (vy≈°≈°√≠ Y)
                layoutGenerationByChildren(gen, lvl, y, NODE_GAP, PARTNER_GAP);
            }
            
            // 6. Layout p≈ôedk≈Ø (nad pivotem, level > 0) - KOMPAKTN√ç
            for (let lvl = 1; lvl <= maxLevel; lvl++) {
                const gen = generations[lvl];
                if (!gen) continue;
                
                const y = pivotY - lvl * STEP_Y; // P≈ôedci jsou NAD pivotem (ni≈æ≈°√≠ Y)
                layoutAncestorGeneration(gen, lvl, y, NODE_GAP, PARTNER_GAP, pivotId);
            }
        }

        /**
         * Spoƒç√≠t√° v√°hu (d≈Øle≈æitost) ka≈æd√© osoby - kolik m√° potomk≈Ø smƒõrem k pivotu
         */
        function calculateSubtreeWeights(pivotId) {
            // BFS od pivotu nahoru, poƒç√≠tej potomky
            const weights = new Map();
            
            // Inicializace - pivot m√° v√°hu 1
            weights.set(pivotId, 1);
            
            // Pro ka≈ædou osobu spoƒç√≠tej, kolik jej√≠ch dƒõt√≠ vede k pivotu
            State.people.forEach(p => {
                if (p.levelFromPivot === null || p.levelFromPivot === 999) return;
                
                let weight = 0;
                
                // Spoƒç√≠tej dƒõti, kter√© vedou k pivotu
                const children = State.people.filter(c => 
                    c.parents && c.parents.includes(p.id) && 
                    c.levelFromPivot !== null && c.levelFromPivot < p.levelFromPivot
                );
                
                if (children.length > 0) {
                    children.forEach(c => {
                        weight += weights.get(c.id) || 1;
                    });
                } else {
                    weight = 1;
                }
                
                weights.set(p.id, weight);
                p.subtreeWidth = weight;
            });
        }

        /**
         * Layout generace podle pozic jejich dƒõt√≠
         */
        function layoutGenerationByChildren(gen, level, targetY, NODE_GAP, PARTNER_GAP) {
            const blocks = groupIntoPartnerBlocks(gen);
            
            blocks.forEach(block => {
                // Najdi v≈°echny dƒõti tohoto bloku
                const children = State.people.filter(c => 
                    c.parents && block.some(parent => c.parents.includes(parent.id)) &&
                    c.levelFromPivot !== null && c.levelFromPivot > level
                );
                
                let centerX = 0;
                if (children.length > 0) {
                    // St≈ôed podle dƒõt√≠
                    centerX = children.reduce((sum, c) => sum + c.x + State.nodeWidth/2, 0) / children.length;
                }
                
                // Pozicuj blok
                const blockWidth = block.length * (State.nodeWidth + PARTNER_GAP) - PARTNER_GAP;
                let startX = centerX - blockWidth / 2;
                
                block.forEach((person, i) => {
                    person.x = startX + i * (State.nodeWidth + PARTNER_GAP);
                    person.y = targetY;
                });
            });
            
            // Vy≈ôe≈° kolize
            resolveCollisions(gen, NODE_GAP);
        }

        /**
         * Layout generace p≈ôedk≈Ø - KOMPAKTN√ç verze
         * Rodiƒçe se pozicuj√≠ nad st≈ôed sv√Ωch dƒõt√≠, ale s omezenou ≈°√≠≈ôkou
         */
        function layoutAncestorGeneration(gen, level, targetY, NODE_GAP, PARTNER_GAP, pivotId) {
            // Seskup do blok≈Ø partner≈Ø
            const blocks = groupIntoPartnerBlocks(gen);
            
            // Pro ka≈æd√Ω blok najdi dƒõti a pozicuj nad jejich st≈ôed
            const blockPositions = [];
            
            blocks.forEach(block => {
                // Najdi v≈°echny dƒõti tohoto bloku (v ni≈æ≈°√≠ generaci)
                const children = State.people.filter(c => 
                    c.parents && block.some(parent => c.parents.includes(parent.id)) &&
                    c.levelFromPivot !== null && c.levelFromPivot < level
                );
                
                let centerX = 0;
                let totalWeight = 0;
                
                if (children.length > 0) {
                    // V√°≈æen√Ω st≈ôed podle dƒõt√≠
                    children.forEach(c => {
                        const weight = c.subtreeWidth || 1;
                        centerX += (c.x + State.nodeWidth/2) * weight;
                        totalWeight += weight;
                    });
                    centerX = centerX / totalWeight;
                } else {
                    // Fallback - st≈ôed canvasu
                    centerX = 0;
                }
                
                const blockWidth = block.length * (State.nodeWidth + PARTNER_GAP) - PARTNER_GAP;
                
                blockPositions.push({
                    block: block,
                    centerX: centerX,
                    width: blockWidth,
                    startX: centerX - blockWidth / 2
                });
            });
            
            // Se≈ôaƒè bloky podle X pozice
            blockPositions.sort((a, b) => a.centerX - b.centerX);
            
            // Aplikuj pozice s minim√°ln√≠ mezerou
            for (let i = 0; i < blockPositions.length; i++) {
                const bp = blockPositions[i];
                
                // Kontrola kolize s p≈ôedchoz√≠m blokem
                if (i > 0) {
                    const prev = blockPositions[i - 1];
                    const prevEnd = prev.startX + prev.width;
                    const minStart = prevEnd + NODE_GAP;
                    
                    if (bp.startX < minStart) {
                        // Posu≈à tento blok doprava
                        const shift = minStart - bp.startX;
                        bp.startX = minStart;
                        bp.centerX += shift;
                    }
                }
                
                // Aplikuj pozice
                bp.block.forEach((person, idx) => {
                    person.x = bp.startX + idx * (State.nodeWidth + PARTNER_GAP);
                    person.y = targetY;
                });
            }
            
            // Vycentruj celou generaci
            centerGeneration(gen);
        }

        /**
         * Vycentruje generaci kolem X = 0
         */
        function centerGeneration(gen) {
            if (gen.length === 0) return;
            
            const minX = Math.min(...gen.map(p => p.x));
            const maxX = Math.max(...gen.map(p => p.x + State.nodeWidth));
            const centerOffset = -(minX + maxX) / 2;
            
            // Aplikuj pouze mal√Ω posun k vycentrov√°n√≠
            // (nechceme naru≈°it relativn√≠ pozice)
            if (Math.abs(centerOffset) > 50) {
                gen.forEach(p => p.x += centerOffset * 0.3); // ƒå√°steƒçn√© centrov√°n√≠
            }
        }

        /**
         * Seskup√≠ osoby do blok≈Ø podle partnerstv√≠
         */
        function groupIntoPartnerBlocks(people) {
            const blocks = [];
            const processed = new Set();
            
            people.forEach(p => {
                if (processed.has(p.id)) return;
                
                const block = [p];
                processed.add(p.id);
                
                // P≈ôidej partnery ze stejn√© generace
                if (p.partners) {
                    p.partners.forEach(partnerId => {
                        const partner = people.find(x => x.id === partnerId);
                        if (partner && !processed.has(partnerId)) {
                            block.push(partner);
                            processed.add(partnerId);
                        }
                    });
                }
                
                // Se≈ôaƒè blok podle ID pro konzistenci
                block.sort((a, b) => a.id.localeCompare(b.id));
                blocks.push(block);
            });
            
            return blocks;
        }

        /**
         * Vy≈ôe≈°√≠ kolize v r√°mci generace
         */
        function resolveCollisions(gen, minGap) {
            if (gen.length <= 1) return;
            
            // Se≈ôaƒè podle X
            const sorted = [...gen].sort((a, b) => a.x - b.x);
            
            // Posu≈à p≈ôekr√Ωvaj√≠c√≠ se osoby
            for (let i = 1; i < sorted.length; i++) {
                const prev = sorted[i - 1];
                const curr = sorted[i];
                
                const minX = prev.x + State.nodeWidth + minGap;
                if (curr.x < minX) {
                    curr.x = minX;
                }
            }
        }

        /**
         * Layout nepropojen√Ωch osob - um√≠st√≠ je stranou od hlavn√≠ho stromu
         */
        function layoutDisconnected(people) {
            if (people.length === 0) return;
            
            // Najdi hranice hlavn√≠ho stromu
            const connected = State.people.filter(p => p.levelFromPivot !== 999);
            let rightEdge = 200;
            let topY = 0;
            
            if (connected.length > 0) {
                rightEdge = Math.max(...connected.map(p => p.x + State.nodeWidth)) + 150;
                topY = Math.min(...connected.map(p => p.y));
            }
            
            // Um√≠sti nepropojen√© v m≈ô√≠≈æce vpravo od stromu
            const cols = 2;
            const GAP_X = State.nodeWidth + 40;
            const GAP_Y = State.nodeHeight + 40;
            
            people.forEach((p, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                p.x = rightEdge + col * GAP_X;
                p.y = topY + row * GAP_Y;
                p.levelFromPivot = 999;
            });
        }

        // --- ADVANCED DATA CONSISTENCY CHECK - IMPROVED VERSION ---
        // üîç Vylep≈°en√° verze s opravami chyb a nov√Ωmi kontrolami
        function checkDataConsistency() {
            // Recalculate generations to ensure levelFromBottom is set
            calculateGenerations();
            
            const anomalies = [];
            const now = new Date();
            const processedDuplicates = new Set(); // Prevence duplicitn√≠ch hl√°≈°en√≠
            
            // ===== HELPER FUNCTIONS =====
            
            /**
             * Vypoƒç√≠t√° vƒõk z data narozen√≠
             */
            function calculateAge(birthDate) {
                if (!birthDate) return null;
                const birth = new Date(birthDate);
                const age = now.getFullYear() - birth.getFullYear();
                const m = now.getMonth() - birth.getMonth();
                if (m < 0 || (m === 0 && now.getDate() < birth.getDate())) {
                    return age - 1;
                }
                return age;
            }
            
            /**
             * Vypoƒç√≠t√° rozd√≠l v mƒõs√≠c√≠ch mezi dvƒõma daty
             */
            function monthsDifference(date1, date2) {
                const d1 = new Date(date1);
                const d2 = new Date(date2);
                return (d2.getFullYear() - d1.getFullYear()) * 12 + (d2.getMonth() - d1.getMonth());
            }
            
            /**
             * Kontroluje, zda jsou dvƒõ osoby KREVNƒö p≈ô√≠buzn√© (pouze p≈ôedci, ne potomci)
             * Tato funkce NEZAHRNUJE vztah p≈ôes spoleƒçn√© dƒõti - partne≈ôi nejsou p≈ô√≠buzn√≠!
             */
            function areRelated(person1Id, person2Id, maxGenerations = 3) {
                if (person1Id === person2Id) return true;
                
                // 1. Z√≠skej v≈°echny p≈ôedky osoby 1
                const ancestors1 = getAllAncestors(person1Id, maxGenerations);
                
                // 2. Z√≠skej v≈°echny p≈ôedky osoby 2
                const ancestors2 = getAllAncestors(person2Id, maxGenerations);
                
                // 3. Kontrola: Je osoba 2 p≈ôedkem osoby 1? (rodiƒç, prarodiƒç...)
                if (ancestors1.has(person2Id)) return true;
                
                // 4. Kontrola: Je osoba 1 p≈ôedkem osoby 2?
                if (ancestors2.has(person1Id)) return true;
                
                // 5. Kontrola: Maj√≠ spoleƒçn√©ho p≈ôedka? (sourozenci, bratranci...)
                for (const ancestorId of ancestors1) {
                    if (ancestors2.has(ancestorId)) return true;
                }
                
                return false;
            }
            
            /**
             * Z√≠sk√° v≈°echny p≈ôedky osoby (pouze smƒõrem nahoru - rodiƒçe, prarodiƒçe atd.)
             */
            function getAllAncestors(personId, maxGenerations = 3) {
                const ancestors = new Set();
                const queue = [{id: personId, depth: 0}];
                
                while (queue.length > 0) {
                    const {id, depth} = queue.shift();
                    if (depth > maxGenerations) continue;
                    
                    const person = getPerson(id);
                    if (!person || !person.parents) continue;
                    
                    for (const parentId of person.parents) {
                        if (!ancestors.has(parentId)) {
                            ancestors.add(parentId);
                            queue.push({id: parentId, depth: depth + 1});
                        }
                    }
                }
                
                return ancestors;
            }
            
            /**
             * Vytvo≈ô√≠ unik√°tn√≠ kl√≠ƒç pro p√°r osob (prevence duplicitn√≠ch hl√°≈°en√≠)
             */
            function pairKey(id1, id2) {
                return [id1, id2].sort().join('-');
            }

            // ===== MAIN VALIDATION LOOP =====
            
            State.people.forEach(person => {
                // 1. Check for self-references
                if (person.parents && person.parents.includes(person.id)) {
                    anomalies.push({
                        type: 'error',
                        person: person,
                        message: 'Osoba m√° sama sebe jako rodiƒçe',
                        severity: 'high',
                        solution: 'Odstra≈àte sebe sama ze seznamu rodiƒç≈Ø t√©to osoby.'
                    });
                }
                
                if (person.partners && person.partners.includes(person.id)) {
                    anomalies.push({
                        type: 'error', 
                        person: person,
                        message: 'Osoba m√° sama sebe jako partnera',
                        severity: 'high',
                        solution: 'Odstra≈àte sebe sama ze seznamu partner≈Ø t√©to osoby.'
                    });
                }
                
                // 2. Check for invalid parent references
                if (person.parents) {
                    person.parents.forEach(parentId => {
                        const parent = getPerson(parentId);
                        if (!parent) {
                            anomalies.push({
                                type: 'error',
                                person: person,
                                message: `Odkaz na neexistuj√≠c√≠ho rodiƒçe (ID: ${parentId})`,
                                severity: 'high',
                                solution: `Odstra≈àte neplatn√Ω odkaz na rodiƒçe nebo vytvo≈ôte chybƒõj√≠c√≠ osobu s ID: ${parentId}`
                            });
                        } else {
                            // 3. Check if parent is too young when child was born
                            if (person.birthDate && parent.birthDate) {
                                const personBirth = new Date(person.birthDate);
                                const parentBirth = new Date(parent.birthDate);
                                const parentAgeAtBirth = personBirth.getFullYear() - parentBirth.getFullYear();
                                
                                if (parentAgeAtBirth < 12) {
                                    anomalies.push({
                                        type: 'error',
                                        person: person,
                                        message: `Rodiƒç ${parent.firstName} ${parent.lastName} byl p≈ô√≠li≈° mlad√Ω (${parentAgeAtBirth} let) p≈ôi narozen√≠ d√≠tƒõte`,
                                        severity: 'high',
                                        solution: `Zkontrolujte data narozen√≠ rodiƒçe a d√≠tƒõte.`
                                    });
                                } else if (parentAgeAtBirth < 16) {
                                    anomalies.push({
                                        type: 'warning',
                                        person: person,
                                        message: `Rodiƒç ${parent.firstName} ${parent.lastName} byl velmi mlad√Ω (${parentAgeAtBirth} let) p≈ôi narozen√≠ d√≠tƒõte`,
                                        severity: 'medium',
                                        solution: `Zkontrolujte data narozen√≠.`
                                    });
                                } else if (parentAgeAtBirth > 60) {
                                    anomalies.push({
                                        type: 'warning',
                                        person: person,
                                        message: `Rodiƒç ${parent.firstName} ${parent.lastName} byl velmi star√Ω (${parentAgeAtBirth} let) p≈ôi narozen√≠ d√≠tƒõte`,
                                        severity: 'medium',
                                        solution: `Zkontrolujte data narozen√≠.`
                                    });
                                }
                                
                                // NOV√Å KONTROLA: Vƒõk matky nad 50 let (biologick√° hranice)
                                if (parent.gender === 'female' && parentAgeAtBirth > 50) {
                                    anomalies.push({
                                        type: 'warning',
                                        person: person,
                                        message: `Matka ${parent.firstName} ${parent.lastName} mƒõla ${parentAgeAtBirth} let p≈ôi porodu (p≈ôekraƒçuje bƒõ≈ænou biologickou hranici)`,
                                        severity: 'medium',
                                        solution: `Zkontrolujte data narozen√≠. Pokud je spr√°vn√©, m≈Ø≈æe j√≠t o adopci - zva≈æte p≈ôid√°n√≠ pozn√°mky.`
                                    });
                                }
                            }
                            
                            // 4. OPRAVENO: Check if parent died before child was born
                            // Pro otce tolerujeme a≈æ 9 mƒõs√≠c≈Ø (posmrtn√© d√≠tƒõ)
                            if (person.birthDate && parent.deathDate) {
                                const personBirth = new Date(person.birthDate);
                                const parentDeath = new Date(parent.deathDate);
                                const monthsBeforeBirth = monthsDifference(parentDeath, personBirth);
                                
                                if (parent.gender === 'male') {
                                    // Otec m≈Ø≈æe zem≈ô√≠t a≈æ 9 mƒõs√≠c≈Ø p≈ôed narozen√≠m d√≠tƒõte
                                    if (monthsBeforeBirth > 9) {
                                        anomalies.push({
                                            type: 'error',
                                            person: person,
                                            message: `Otec ${parent.firstName} ${parent.lastName} zem≈ôel ${monthsBeforeBirth} mƒõs√≠c≈Ø p≈ôed narozen√≠m d√≠tƒõte (max. 9 mƒõs√≠c≈Ø)`,
                                            severity: 'high',
                                            solution: `Opravte data narozen√≠/√∫mrt√≠ nebo odstra≈àte nespr√°vnou vazbu.`
                                        });
                                    } else if (monthsBeforeBirth > 0) {
                                        anomalies.push({
                                            type: 'info',
                                            person: person,
                                            message: `Otec ${parent.firstName} ${parent.lastName} zem≈ôel ${monthsBeforeBirth} mƒõs√≠c≈Ø p≈ôed narozen√≠m d√≠tƒõte (posmrtn√© d√≠tƒõ)`,
                                            severity: 'low',
                                            solution: `Toto je mo≈æn√© - d√≠tƒõ se mohlo narodit po smrti otce.`
                                        });
                                    }
                                } else {
                                    // Matka mus√≠ b√Ωt na≈æivu p≈ôi porodu
                                    if (parentDeath < personBirth) {
                                        anomalies.push({
                                            type: 'error',
                                            person: person,
                                            message: `Matka ${parent.firstName} ${parent.lastName} zem≈ôela p≈ôed narozen√≠m d√≠tƒõte`,
                                            severity: 'high',
                                            solution: `Opravte data narozen√≠/√∫mrt√≠ nebo odstra≈àte nespr√°vnou vazbu mezi matkou a d√≠tƒõtem.`
                                        });
                                    }
                                }
                            }
                            
                            // 5. Check if parent is the same person as child (different ID but same data)
                            // Kontrola pouze pokud maj√≠ oba vyplnƒõn√© datum narozen√≠
                            if (person.birthDate && parent.birthDate &&
                                person.firstName === parent.firstName && 
                                person.lastName === parent.lastName && 
                                person.birthDate === parent.birthDate &&
                                person.id !== parent.id) {
                                anomalies.push({
                                    type: 'error',
                                    person: person,
                                    message: `Rodiƒç m√° stejn√© jm√©no a datum narozen√≠ jako d√≠tƒõ - mo≈æn√° duplicitn√≠ z√°znam`,
                                    severity: 'high',
                                    solution: `Slouƒçte duplicitn√≠ z√°znamy nebo opravte data tak, aby byly jedineƒçn√©.`
                                });
                            }
                        }
                    });
                }
                
                // 6. Check for invalid partner references
                if (person.partners) {
                    person.partners.forEach(partnerId => {
                        const partner = getPerson(partnerId);
                        if (!partner) {
                            anomalies.push({
                                type: 'error',
                                person: person,
                                message: `Odkaz na neexistuj√≠c√≠ho partnera (ID: ${partnerId})`,
                                severity: 'high',
                                solution: `Odstra≈àte neplatn√Ω odkaz na partnera nebo vytvo≈ôte chybƒõj√≠c√≠ osobu s ID: ${partnerId}`
                            });
                        } else {
                            // 7. Check if partnership is reciprocal
                            if (!partner.partners || !partner.partners.includes(person.id)) {
                                anomalies.push({
                                    type: 'warning',
                                    person: person,
                                    message: `Partnerstv√≠ s ${partner.firstName} ${partner.lastName} nen√≠ oboustrann√©`,
                                    severity: 'low',
                                    solution: `P≈ôidejte ${person.firstName} ${person.lastName} do seznamu partner≈Ø osoby ${partner.firstName} ${partner.lastName}.`
                                });
                            }
                            
                            // 8. Check for close relative partnerships
                            if (areRelated(person.id, partnerId, 2)) {
                                const key = pairKey(person.id, partnerId);
                                if (!processedDuplicates.has(key)) {
                                    processedDuplicates.add(key);
                                    anomalies.push({
                                        type: 'error',
                                        person: person,
                                        message: `Osoba je v partnerstv√≠ s bl√≠zk√Ωm p≈ô√≠buzn√Ωm (${partner.firstName} ${partner.lastName})`,
                                        severity: 'high',
                                        solution: `Zkontrolujte rodinn√© vazby. Pokud je partnerstv√≠ spr√°vn√©, p≈ôidejte vysvƒõtlen√≠ do pozn√°mek.`
                                    });
                                }
                            }
                            
                            // 9. Check age difference between partners
                            if (person.birthDate && partner.birthDate) {
                                const personBirth = new Date(person.birthDate);
                                const partnerBirth = new Date(partner.birthDate);
                                const ageDiff = Math.abs(personBirth.getFullYear() - partnerBirth.getFullYear());
                                
                                if (ageDiff > 30) {
                                    const key = pairKey(person.id, partnerId);
                                    if (!processedDuplicates.has('age-' + key)) {
                                        processedDuplicates.add('age-' + key);
                                        anomalies.push({
                                            type: 'warning',
                                            person: person,
                                            message: `Velk√Ω vƒõkov√Ω rozd√≠l s partnerem ${partner.firstName} ${partner.lastName} (${ageDiff} let)`,
                                            severity: 'medium',
                                            solution: `Zkontrolujte data narozen√≠ obou partner≈Ø.`
                                        });
                                    }
                                }
                            }
                            
                            // 10. OPRAVENO: Check if partners could have met (based on birth/death dates)
                            // Nyn√≠ funguje i kdy≈æ jedna osoba ≈æije (nem√° deathDate)
                            if (person.birthDate && partner.birthDate) {
                                const personBirth = new Date(person.birthDate);
                                const partnerBirth = new Date(partner.birthDate);
                                const personDeath = person.deathDate ? new Date(person.deathDate) : now;
                                const partnerDeath = partner.deathDate ? new Date(partner.deathDate) : now;
                                
                                const overlapStart = new Date(Math.max(personBirth.getTime(), partnerBirth.getTime()));
                                const overlapEnd = new Date(Math.min(personDeath.getTime(), partnerDeath.getTime()));
                                
                                if (overlapStart > overlapEnd) {
                                    const key = pairKey(person.id, partnerId);
                                    if (!processedDuplicates.has('overlap-' + key)) {
                                        processedDuplicates.add('overlap-' + key);
                                        anomalies.push({
                                            type: 'error',
                                            person: person,
                                            message: `Partne≈ôi se nemohli potkat - jejich ≈æivoty se nep≈ôekr√Ωvaly v ƒçase`,
                                            severity: 'high',
                                            solution: `Opravte data narozen√≠/√∫mrt√≠ partner≈Ø nebo odstra≈àte nespr√°vn√© partnerstv√≠.`
                                        });
                                    }
                                } else {
                                    const overlapYears = overlapEnd.getFullYear() - overlapStart.getFullYear();
                                    if (overlapYears < 5 && person.deathDate && partner.deathDate) {
                                        const key = pairKey(person.id, partnerId);
                                        if (!processedDuplicates.has('short-' + key)) {
                                            processedDuplicates.add('short-' + key);
                                            anomalies.push({
                                                type: 'warning',
                                                person: person,
                                                message: `Kr√°tk√© ƒçasov√© p≈ôekryt√≠ ≈æivot≈Ø partner≈Ø (${overlapYears} let)`,
                                                severity: 'low',
                                                solution: `Zkontrolujte data.`
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                // 11. Check for more than two parents
                if (person.parents && person.parents.length > 2) {
                    anomalies.push({
                        type: 'error',
                        person: person,
                        message: `Osoba m√° ${person.parents.length} rodiƒç≈Ø, maximum jsou 2`,
                        severity: 'high',
                        solution: `Upravte seznam rodiƒç≈Ø tak, aby obsahoval maxim√°lnƒõ 2 rodiƒçe. Pro slo≈æitƒõj≈°√≠ rodinn√© situace pou≈æijte pozn√°mky.`
                    });
                }
                
                // 12. Check generation gap between parent and child
                if (person.parents) {
                    person.parents.forEach(parentId => {
                        const parent = getPerson(parentId);
                        if (parent && person.levelFromBottom !== null && parent.levelFromBottom !== null) {
                            const gap = parent.levelFromBottom - person.levelFromBottom;
                            if (gap !== 1) {
                                anomalies.push({
                                    type: 'warning',
                                    person: person,
                                    message: `Generaƒçn√≠ rozd√≠l mezi rodiƒçem a d√≠tƒõtem je ${gap} (mƒõl by b√Ωt 1)`,
                                    severity: 'medium',
                                    solution: `Zkontrolujte rodinn√© vazby nebo spus≈•te "Automatick√© uspo≈ô√°d√°n√≠".`
                                });
                            }
                        }
                    });
                }
                
                // 13. Check for missing critical data
                if (!person.firstName || !person.lastName) {
                    anomalies.push({
                        type: 'warning',
                        person: person,
                        message: 'Chyb√≠ jm√©no nebo p≈ô√≠jmen√≠',
                        severity: 'low',
                        solution: 'Dopl≈àte chybƒõj√≠c√≠ jm√©no nebo p≈ô√≠jmen√≠ osoby.'
                    });
                }
                
                // 14. Check for impossible birth/death dates
                if (person.birthDate) {
                    const birth = new Date(person.birthDate);
                    if (birth > now) {
                        anomalies.push({
                            type: 'error',
                            person: person,
                            message: 'Datum narozen√≠ je v budoucnosti',
                            severity: 'high',
                            solution: 'Opravte datum narozen√≠ na platn√© datum v minulosti.'
                        });
                    }
                    
                    if (person.deathDate) {
                        const death = new Date(person.deathDate);
                        if (death < birth) {
                            anomalies.push({
                                type: 'error',
                                person: person,
                                message: 'Datum √∫mrt√≠ je p≈ôed datem narozen√≠',
                                severity: 'high',
                                solution: 'Opravte data narozen√≠ a √∫mrt√≠ tak, aby datum √∫mrt√≠ bylo po datu narozen√≠.'
                            });
                        }
                        
                        if (death > now) {
                            anomalies.push({
                                type: 'warning',
                                person: person,
                                message: 'Datum √∫mrt√≠ je v budoucnosti',
                                severity: 'low',
                                solution: 'Pokud osoba je≈°tƒõ ≈æije, odstra≈àte datum √∫mrt√≠.'
                            });
                        }
                        
                        const age = death.getFullYear() - birth.getFullYear();
                        if (age > 120) {
                            anomalies.push({
                                type: 'warning',
                                person: person,
                                message: `Vƒõk √∫mrt√≠ (${age} let) je podez≈ôele vysok√Ω`,
                                severity: 'low',
                                solution: 'Zkontrolujte data narozen√≠ a √∫mrt√≠.'
                            });
                        }
                    }
                    // ODSTRANƒöNO: Kontrola vƒõku nad 120 let pro osoby bez data √∫mrt√≠
                    // U historick√Ωch osob ƒçasto chyb√≠ datum √∫mrt√≠, co≈æ by generovalo fale≈°n√° hl√°≈°en√≠
                }
                
                // 15. Check for circular references in ancestry
                if (hasCircularAncestry(person.id)) {
                    anomalies.push({
                        type: 'error',
                        person: person,
                        message: 'Kruhov√° reference v p≈ôedc√≠ch',
                        severity: 'high',
                        solution: 'Odstra≈àte kruhovou vazbu v rodokmenu - osoba nem≈Ø≈æe b√Ωt sv√Ωm vlastn√≠m p≈ôedkem.'
                    });
                }
                
                // 16. OPRAVENO: Check for duplicate persons (only report once per pair)
                // Kontrola pouze pokud m√° osoba vyplnƒõn√© datum narozen√≠
                if (person.birthDate) {
                    const duplicates = State.people.filter(p => 
                        p.id !== person.id &&
                        p.firstName === person.firstName &&
                        p.lastName === person.lastName &&
                        p.birthDate && // Partner mus√≠ m√≠t tak√© vyplnƒõn√© datum
                        p.birthDate === person.birthDate
                    );
                    
                    if (duplicates.length > 0) {
                        // Vytvo≈ô√≠me kl√≠ƒç pro tento p√°r, abychom hl√°sili pouze jednou
                        duplicates.forEach(dup => {
                            const key = pairKey(person.id, dup.id);
                            if (!processedDuplicates.has('dup-' + key)) {
                                processedDuplicates.add('dup-' + key);
                                anomalies.push({
                                    type: 'error',
                                    person: person,
                                    message: `Mo≈æn√° duplicitn√≠ osoba - stejn√© jm√©no a datum narozen√≠ jako ${dup.firstName} ${dup.lastName} (ID: ${dup.id})`,
                                    severity: 'high',
                                    solution: `Slouƒçte duplicitn√≠ z√°znamy nebo upravte data tak, aby byly jedineƒçn√©.`
                                });
                            }
                        });
                    }
                }
                
                // 17. Check for data consistency in gender-specific roles
                if (person.parents && person.parents.length > 0) {
                    const fathers = person.parents.filter(pid => {
                        const p = getPerson(pid);
                        return p && p.gender === 'male';
                    });
                    
                    const mothers = person.parents.filter(pid => {
                        const p = getPerson(pid);
                        return p && p.gender === 'female';
                    });
                    
                    if (fathers.length > 1) {
                        anomalies.push({
                            type: 'warning',
                            person: person,
                            message: `Osoba m√° ${fathers.length} otc≈Ø`,
                            severity: 'medium',
                            solution: `Zkontrolujte pohlav√≠ rodiƒç≈Ø. Pro adopce pou≈æijte pozn√°mky.`
                        });
                    }
                    
                    if (mothers.length > 1) {
                        anomalies.push({
                            type: 'warning',
                            person: person,
                            message: `Osoba m√° ${mothers.length} matek`,
                            severity: 'medium',
                            solution: `Zkontrolujte pohlav√≠ rodiƒç≈Ø. Pro adopce pou≈æijte pozn√°mky.`
                        });
                    }
                }
            });
            
            // 18. Check for isolated persons (no connections)
            State.people.forEach(person => {
                const hasParents = person.parents && person.parents.length > 0;
                const hasPartners = person.partners && person.partners.length > 0;
                const hasChildren = State.people.some(p => p.parents && p.parents.includes(person.id));
                
                if (!hasParents && !hasPartners && !hasChildren) {
                    anomalies.push({
                        type: 'info',
                        person: person,
                        message: 'Osoba nen√≠ propojena s ≈æ√°dnou jinou osobou v rodokmenu',
                        severity: 'low',
                        solution: 'Propojte osobu s rodinou p≈ôid√°n√≠m rodiƒç≈Ø, partner≈Ø nebo dƒõt√≠.'
                    });
                }
            });
            
            // 19. OPRAVENO: Check for family structure issues (rodiƒçe bez partnerstv√≠)
            const processedParentPairs = new Set();
            State.people.forEach(child => {
                if (child.parents && child.parents.length === 2) {
                    const [parent1Id, parent2Id] = child.parents;
                    const parent1 = getPerson(parent1Id);
                    const parent2 = getPerson(parent2Id);
                    
                    if (parent1 && parent2) {
                        const key = pairKey(parent1Id, parent2Id);
                        if (!processedParentPairs.has(key)) {
                            processedParentPairs.add(key);
                            
                            // Kontrola, zda rodiƒçe jsou navz√°jem partnery
                            const arePartnersLinked = 
                                (parent1.partners && parent1.partners.includes(parent2Id)) ||
                                (parent2.partners && parent2.partners.includes(parent1Id));
                            
                            if (!arePartnersLinked) {
                                anomalies.push({
                                    type: 'warning',
                                    person: child,
                                    message: `Rodiƒçe (${parent1.firstName} ${parent1.lastName} a ${parent2.firstName} ${parent2.lastName}) nejsou propojeni jako partne≈ôi`,
                                    severity: 'medium',
                                    solution: `P≈ôidejte partnerstv√≠ mezi ${parent1.firstName} ${parent1.lastName} a ${parent2.firstName} ${parent2.lastName}.`
                                });
                            }
                        }
                    }
                }
            });
            
            // 20. NOV√â: Check for persons not connected to pivot
            // (P≈ôeskoƒç√≠ √∫plnƒõ izolovan√© osoby - ty jsou hl√°≈°eny kontrolou 18)
            if (State.pivotId) {
                const pivot = getPerson(State.pivotId);
                if (pivot) {
                    State.people.forEach(person => {
                        // P≈ôeskoƒç pivot
                        if (person.id === State.pivotId) return;
                        
                        // P≈ôeskoƒç √∫plnƒõ izolovan√© osoby (kontrola 18 je u≈æ nahl√°sila)
                        const hasParents = person.parents && person.parents.length > 0;
                        const hasPartners = person.partners && person.partners.length > 0;
                        const hasChildren = State.people.some(p => p.parents && p.parents.includes(person.id));
                        const isIsolated = !hasParents && !hasPartners && !hasChildren;
                        
                        if (!isIsolated && !isConnectedToPivot(person.id)) {
                            anomalies.push({
                                type: 'info',
                                person: person,
                                message: `Osoba nen√≠ propojena s pivot osobou (${pivot.firstName} ${pivot.lastName})`,
                                severity: 'low',
                                solution: `Propojte osobu s rodokmenem p≈ôid√°n√≠m rodinn√Ωch vazeb, nebo ovƒõ≈ôte, zda pat≈ô√≠ do tohoto rodokmenu.`
                            });
                        }
                    });
                }
            }
            
            displayConsistencyResults(anomalies);
        }

        // IMPROVED CIRCULAR ANCESTRY DETECTION
        function hasCircularAncestry(startId) {
            const visited = new Set();
            const stack = [{id: startId, path: new Set([startId])}];
            
            while (stack.length > 0) {
                const {id, path} = stack.pop();
                const person = getPerson(id);
                
                if (!person || !person.parents) continue;
                
                for (const parentId of person.parents) {
                    if (path.has(parentId)) {
                        return true; // Circular reference found
                    }
                    
                    const parent = getPerson(parentId);
                    if (parent) {
                        const newPath = new Set(path);
                        newPath.add(parentId);
                        stack.push({id: parentId, path: newPath});
                    }
                }
            }
            return false;
        }

        // OPRAVENO: displayConsistencyResults - spr√°vn√© poƒç√≠t√°n√≠ kategori√≠
        function displayConsistencyResults(anomalies) {
            const resultsContainer = document.getElementById('consistencyResults');
            resultsContainer.innerHTML = '';
            
            if (anomalies.length === 0) {
                resultsContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: var(--text-muted);">
                        <div style="font-size: 3rem; margin-bottom: 20px;">‚úÖ</div>
                        <h3 style="margin-bottom: 10px;">≈Ω√°dn√© anom√°lie nenalezeny</h3>
                        <p>V≈°echna data jsou konzistentn√≠ a logicky propojena.</p>
                    </div>
                `;
                openConsistencyModal();
                return;
            }
            
            // Group by severity - OPRAVENO: spr√°vn√© rozdƒõlen√≠ kategori√≠
            const highSeverity = anomalies.filter(a => a.severity === 'high');
            const mediumSeverity = anomalies.filter(a => a.severity === 'medium');
            const lowSeverity = anomalies.filter(a => a.severity === 'low');
            
            let html = `
                <div style="margin-bottom: 20px;">
                    <h3 style="margin-bottom: 15px;">Nalezen√© anom√°lie: <span class="anomaly-count">${anomalies.length}</span></h3>
                    <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                        <span style="background: var(--danger); color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem;">
                            üî¥ Vysok√°: ${highSeverity.length}
                        </span>
                        <span style="background: #ff9800; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem;">
                            üü† St≈ôedn√≠: ${mediumSeverity.length}
                        </span>
                        <span style="background: #64b5f6; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem;">
                            üîµ N√≠zk√°: ${lowSeverity.length}
                        </span>
                    </div>
                </div>
            `;
            
            // Display high severity first
            if (highSeverity.length > 0) {
                html += `<h4 style="color: var(--danger); margin-bottom: 10px;">üî¥ Vysok√° priorita</h4>`;
                highSeverity.forEach(anomaly => {
                    html += createAnomalyHTML(anomaly);
                });
            }
            
            // Display medium severity
            if (mediumSeverity.length > 0) {
                html += `<h4 style="color: #ff9800; margin-bottom: 10px; margin-top: 20px;">üü† St≈ôedn√≠ priorita</h4>`;
                mediumSeverity.forEach(anomaly => {
                    html += createAnomalyHTML(anomaly);
                });
            }
            
            // Display low severity
            if (lowSeverity.length > 0) {
                html += `<h4 style="color: #64b5f6; margin-bottom: 10px; margin-top: 20px;">üîµ N√≠zk√° priorita / Info</h4>`;
                lowSeverity.forEach(anomaly => {
                    html += createAnomalyHTML(anomaly);
                });
            }
            
            resultsContainer.innerHTML = html;
            openConsistencyModal();
        }

        function createAnomalyHTML(anomaly) {
            const genderClass = `gender-${anomaly.person.gender}`;
            return `
                <div class="anomaly-item ${anomaly.type}">
                    <div class="anomaly-person">
                        <span class="gender-dot ${genderClass}" style="margin-right: 8px;"></span>
                        ${anomaly.person.firstName} ${anomaly.person.lastName}
                    </div>
                    <div class="anomaly-desc">
                        <strong>Probl√©m:</strong> ${anomaly.message}
                    </div>
                    <div class="anomaly-solution">
                        <strong>üõ†Ô∏è N√°vrh ≈ôe≈°en√≠:</strong> ${anomaly.solution}
                    </div>
                    <div class="anomaly-actions">
                        <button class="btn btn-outline" style="width: auto; padding: 5px 10px; font-size: 0.8rem;" 
                                onclick="openPersonModal('${anomaly.person.id}')">
                            ‚úèÔ∏è Upravit
                        </button>
                        <button class="btn btn-outline" style="width: auto; padding: 5px 10px; font-size: 0.8rem;" 
                                onclick="focusOnPerson('${anomaly.person.id}')">
                            üîç Zobrazit
                        </button>
                    </div>
                </div>
            `;
        }

        function focusOnPerson(personId) {
            const person = getPerson(personId);
            if (person) {
                State.pan.x = -person.x * State.zoom + State.canvas.width/2 - (State.nodeWidth*State.zoom)/2;
                State.pan.y = -person.y * State.zoom + State.canvas.height/2 - (State.nodeHeight*State.zoom)/2;
                State.selectedNodeId = personId;
                renderCanvas();
                closeConsistencyModal();
            }
        }

        function openConsistencyModal() {
            document.getElementById('consistencyModal').style.display = 'flex';
        }

        function closeConsistencyModal() {
            document.getElementById('consistencyModal').style.display = 'none';
        }

        // --- UI LOGIC ---
        function switchTab(tabId) {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.querySelector(`button[onclick="switchTab('${tabId}')"]`).classList.add('active');
            document.getElementById(`tab-${tabId}`).classList.add('active');
            if(tabId === 'stats') calculateStats();
        }

        function toggleSidebar() {
            document.getElementById('sidebar').classList.toggle('open');
        }

        function renderPersonList() {
            const container = document.getElementById('personListContainer');
            const filter = document.getElementById('searchBox').value.toLowerCase();
            container.innerHTML = '';
            const filtered = State.people.filter(p => 
                `${p.firstName} ${p.lastName} ${p.birthDate || ''} ${p.notes || ''}`
                    .toLowerCase()
                    .includes(filter)
            );
            document.getElementById('listCount').textContent = `${filtered.length} osob`;

            filtered.forEach(p => {
                const div = document.createElement('div');
                div.className = 'person-list-item';
                div.onclick = () => {
                    State.pan.x = -p.x * State.zoom + State.canvas.width/2 - (State.nodeWidth*State.zoom)/2;
                    State.pan.y = -p.y * State.zoom + State.canvas.height/2 - (State.nodeHeight*State.zoom)/2;
                    State.selectedNodeId = p.id;
                    renderCanvas();
                    if(window.innerWidth < 768) toggleSidebar();
                };
                div.innerHTML = `
                    <div class="gender-dot gender-${p.gender}"></div>
                    <div>
                        <div style="font-weight:600">${p.lastName}, ${p.firstName}</div>
                        <div style="font-size:0.8em; color:var(--text-muted)">${p.birthDate ? new Date(p.birthDate).getFullYear() : '?'}</div>
                    </div>
                    <button style="margin-left:auto; background:none; border:none; cursor:pointer;" onclick="event.stopPropagation(); openPersonModal('${p.id}')">‚úèÔ∏è</button>
                `;
                container.appendChild(div);
            });
        }
        
        function renderUI() {
            renderPersonList();
            calculateStats();
            updatePivotSelect();
        }

        // --- MODAL LOGIC ---
        let currentEditId = null;
        let tempCoords = null;

        function populateParentSelect(selectElement, genderFilter, selectedId) {
            const options = State.people
                .filter(p => !genderFilter || p.gender === genderFilter)
                .map(p => `<option value="${p.id}" ${selectedId === p.id ? 'selected' : ''}>${p.lastName} ${p.firstName}</option>`);
            
            selectElement.innerHTML = '<option value="">-- ≈Ω√°dn√Ω --</option>' + options.join('');
        }

        function openPersonModal(id = null, coords = null) {
            const modal = document.getElementById('personModal');
            const form = document.getElementById('personForm');
            currentEditId = id;
            tempCoords = coords;
            
            const others = State.people.filter(p => p.id !== id);

            if (id) {
                const p = getPerson(id);
                document.getElementById('modalTitle').innerText = 'Upravit osobu';
                document.getElementById('p_firstName').value = p.firstName;
                document.getElementById('p_lastName').value = p.lastName;
                document.getElementById('p_gender').value = p.gender;
                document.getElementById('p_birthDate').value = p.birthDate;
                document.getElementById('p_deathDate').value = p.deathDate;
                
                // Resolve Parents from array
                const father = p.parents.find(pid => getPerson(pid)?.gender === 'male');
                const mother = p.parents.find(pid => getPerson(pid)?.gender === 'female');
                
                populateParentSelect(document.getElementById('p_father'), 'male', father);
                populateParentSelect(document.getElementById('p_mother'), 'female', mother);
                document.getElementById('p_notes').value = p.notes;
                
                // Partners
                const partnerSelect = document.getElementById('p_partners');
                partnerSelect.innerHTML = '';
                others.forEach(o => {
                     const opt = document.createElement('option');
                     opt.value = o.id;
                     opt.text = `${o.lastName} ${o.firstName}`;
                     if(p.partners.includes(o.id)) opt.selected = true;
                     partnerSelect.appendChild(opt);
                });
                
                const footer = modal.querySelector('.modal-footer');
                
                // Tlaƒç√≠tko Smazat
                if(!document.getElementById('btn-delete-person')) {
                     const delBtn = document.createElement('button');
                     delBtn.id = 'btn-delete-person';
                     delBtn.className = 'btn btn-danger';
                     delBtn.style.width = 'auto';
                     delBtn.style.marginRight = '5px';
                     delBtn.innerHTML = 'üóëÔ∏è Smazat';
                     delBtn.onclick = () => { closeModal(); deletePerson(id); };
                     footer.prepend(delBtn);
                }
                
                // Tlaƒç√≠tko Pivot
                let pivotBtn = document.getElementById('btn-set-pivot');
                if (!pivotBtn) {
                    pivotBtn = document.createElement('button');
                    pivotBtn.id = 'btn-set-pivot';
                    pivotBtn.className = 'btn btn-outline';
                    pivotBtn.style.width = 'auto';
                    pivotBtn.style.marginRight = 'auto';
                    footer.insertBefore(pivotBtn, footer.children[1]);
                }
                
                // Aktualizace textu tlaƒç√≠tka podle stavu
                if (State.pivotId === id) {
                    pivotBtn.innerHTML = 'üéØ Zru≈°it pivot';
                    pivotBtn.onclick = () => { setPivotPerson(null); closeModal(); };
                } else {
                    pivotBtn.innerHTML = 'üéØ Nastavit jako pivot';
                    pivotBtn.onclick = () => { setPivotPerson(id); closeModal(); };
                }
                
            } else {
                document.getElementById('modalTitle').innerText = 'Nov√° osoba';
                form.reset();
                populateParentSelect(document.getElementById('p_father'), 'male', null);
                populateParentSelect(document.getElementById('p_mother'), 'female', null);
                const partnerSelect = document.getElementById('p_partners');
                partnerSelect.innerHTML = '';
                others.forEach(o => {
                     const opt = document.createElement('option');
                     opt.value = o.id;
                     opt.text = `${o.lastName} ${o.firstName}`;
                     partnerSelect.appendChild(opt);
                });
                
                const delBtn = document.getElementById('btn-delete-person');
                if(delBtn) delBtn.remove();
                
                const pivotBtn = document.getElementById('btn-set-pivot');
                if(pivotBtn) pivotBtn.remove();
            }

            modal.style.display = 'flex';
            document.getElementById('p_firstName').focus();
        }

        function closeModal() {
            document.getElementById('personModal').style.display = 'none';
        }

        function savePerson() {
            const firstName = document.getElementById('p_firstName').value;
            const lastName = document.getElementById('p_lastName').value;
            if (!firstName || !lastName) {
                alert('Jm√©no a p≈ô√≠jmen√≠ jsou povinn√©!');
                return;
            }

            const partnerSelect = document.getElementById('p_partners');
            const selectedPartners = Array.from(partnerSelect.selectedOptions).map(opt => opt.value);
            
            const fatherId = document.getElementById('p_father').value;
            const motherId = document.getElementById('p_mother').value;
            const parents = [fatherId, motherId].filter(Boolean); // Remove empty strings

            const data = {
                firstName: firstName,
                lastName: lastName,
                gender: document.getElementById('p_gender').value,
                birthDate: document.getElementById('p_birthDate').value,
                deathDate: document.getElementById('p_deathDate').value,
                parents: parents,
                partners: selectedPartners,
                notes: document.getElementById('p_notes').value
            };

            if (currentEditId) {
                updatePerson(currentEditId, data);
            } else {
                if(!tempCoords) tempCoords = {x: -State.pan.x + 100, y: -State.pan.y + 100};
                data.x = tempCoords.x;
                data.y = tempCoords.y;
                createPerson(data);
            }
            closeModal();
        }

        // --- STATISTICS ---
        function calculateStats() {
            const total = State.people.length;
            const males = State.people.filter(p => p.gender === 'male').length;
            const females = State.people.filter(p => p.gender === 'female').length;
            
            document.getElementById('statTotal').innerText = total;
            document.getElementById('statMale').innerText = males;
            document.getElementById('statFemale').innerText = females;
            
            const malePerc = total > 0 ? (males / total) * 100 : 50;
            document.getElementById('statGenderBar').style.width = `${malePerc}%`;

            let ageSum = 0;
            let ageCount = 0;
            const now = new Date().getFullYear();
            State.people.forEach(p => {
                if(p.birthDate) {
                    const bYear = new Date(p.birthDate).getFullYear();
                    const dYear = p.deathDate ? new Date(p.deathDate).getFullYear() : now;
                    ageSum += (dYear - bYear);
                    ageCount++;
                }
            });
            document.getElementById('statAvgAge').innerText = ageCount ? Math.round(ageSum / ageCount) : '-';

            const names = {};
            State.people.forEach(p => { names[p.firstName] = (names[p.firstName] || 0) + 1; });
            const commonName = Object.keys(names).reduce((a, b) => names[a] > names[b] ? a : b, '-');
            document.getElementById('statCommonName').innerText = commonName !== '-' ? `${commonName} (${names[commonName]}x)` : '-';
            
            // Max generation
            const maxGen = State.people.reduce((max, p) => Math.max(max, p.generation || 0), 0);
            document.getElementById('statGenerations').innerText = maxGen + 1;
        }

        // --- EXPORTS & SETTINGS ---
        function toggleTheme() {
            const newTheme = State.theme === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
        }

        function applyTheme(themeName) {
            State.theme = themeName;
            document.documentElement.setAttribute('data-theme', themeName);
            localStorage.setItem('heritage_theme', themeName);
            renderCanvas();
        }

        function setLoadingState(loading) {
            document.getElementById('mainArea').style.opacity = loading ? 0.7 : 1;
            document.getElementById('mainArea').style.pointerEvents = loading ? 'none' : 'auto';
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Trigger animation
            setTimeout(() => notification.classList.add('show'), 10);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 300);
            }, 3000);
        }

        function loadSampleData() {
            if(State.people.length > 0 && !confirm('P≈ôepsat st√°vaj√≠c√≠ data?')) return;
            
            setLoadingState(true);
            
            // Sample Data matching NEW Schema
            const sample = [
                {id: "1", firstName: "Karel IV.", lastName: "Lucembursk√Ω", gender: "male", birthDate: "1316-05-14", deathDate: "1378-11-29", x: 0, y: 0, partners: ["2", "3", "4", "5"], parents: [], generation: 0},
                {id: "2", firstName: "Blanka", lastName: "z Valois", gender: "female", birthDate: "1316-01-01", deathDate: "1348-08-01", x: 200, y: 0, partners: ["1"], parents: [], generation: 0},
                {id: "3", firstName: "Anna", lastName: "Falck√°", gender: "female", birthDate: "1329-09-26", deathDate: "1353-02-02", x: 400, y: 0, partners: ["1"], parents: [], generation: 0},
                {id: "4", firstName: "Anna", lastName: "Sv√≠dnick√°", gender: "female", birthDate: "1339-01-01", deathDate: "1362-07-11", x: 600, y: 0, partners: ["1"], parents: [], generation: 0},
                {id: "5", firstName: "Al≈æbƒõta", lastName: "Pomo≈ôansk√°", gender: "female", birthDate: "1347-01-01", deathDate: "1393-04-15", x: 800, y: 0, partners: ["1"], parents: [], generation: 0},
                {id: "6", firstName: "V√°clav IV.", lastName: "Lucembursk√Ω", gender: "male", birthDate: "1361-02-26", parents: ["1", "4"], x: 300, y: 200, partners: [], generation: 1},
                {id: "7", firstName: "Zikmund", lastName: "Lucembursk√Ω", gender: "male", birthDate: "1368-02-14", parents: ["1", "5"], x: 700, y: 200, partners: [], generation: 1}
            ];
            State.people = sample;
            State.hasUnsavedChanges = true;
            saveData();
            renderUI();
            renderCanvas();
            autoLayout();
            
            setTimeout(() => {
                setLoadingState(false);
                showNotification('Uk√°zkov√° data √∫spƒõ≈°nƒõ naƒçtena!', 'success');
            }, 500);
        }

        function clearAllData() {
            if(confirm('Opravdu smazat V≈†ECHNA data?')) {
                State.people = [];
                State.hasUnsavedChanges = true;
                saveData();
                renderUI();
                renderCanvas();
                showNotification('V≈°echna data byla smaz√°na', 'info');
            }
        }

        function exportJSON() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(State.people, null, 2));
            const anchor = document.createElement('a');
            anchor.setAttribute("href", dataStr);
            anchor.setAttribute("download", "rodokmen.json");
            document.body.appendChild(anchor);
            anchor.click();
            anchor.remove();
            showNotification('Data exportov√°na do JSON', 'success');
        }

        function importJSON(input) {
            const file = input.files[0];
            if(!file) return;
            
            if (file.size > 5 * 1024 * 1024) { // 5MB limit
                showNotification('Soubor je p≈ô√≠li≈° velk√Ω (max 5MB)', 'error');
                return;
            }
            
            setLoadingState(true);
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const json = JSON.parse(e.target.result);
                    if (!Array.isArray(json)) {
                        throw new Error('Neplatn√Ω form√°t dat');
                    }
                    
                    State.people = json;
                    State.hasUnsavedChanges = true;
                    saveData();
                    renderUI();
                    renderCanvas();
                    showNotification('Data √∫spƒõ≈°nƒõ nahr√°na!', 'success');
                } catch (err) {
                    showNotification('Chyba p≈ôi ƒçten√≠ souboru: ' + err.message, 'error');
                    console.error(err);
                } finally {
                    setLoadingState(false);
                }
            };
            reader.onerror = () => {
                showNotification('Chyba p≈ôi ƒçten√≠ souboru', 'error');
                setLoadingState(false);
            };
            reader.readAsText(file);
        }

        function exportPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'landscape' });
            const imgData = State.canvas.toDataURL("image/png");
            doc.text("Heritage - Genealogick√Ω strom", 10, 10);
            doc.addImage(imgData, 'PNG', 10, 20, 280, 150);
            doc.save("rodokmen.pdf");
            showNotification('PDF exportov√°n', 'success');
        }

        function exportSVG() {
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${State.canvas.width}" height="${State.canvas.height}" style="background:#1e1e1e">`;
            svg += `<style>.node { fill: #2c2c2c; stroke-width: 2px; } .text { font-family: sans-serif; fill: #eee; } .link { stroke: #555; fill: none; stroke-width: 2px; }</style>`;

            // Links
            State.people.forEach(p => {
                if(p.parents) {
                    p.parents.forEach(pid => {
                        const parent = getPerson(pid);
                        if(parent) {
                            svg += `<path d="M${parent.x+State.nodeWidth/2} ${parent.y+State.nodeHeight} L${p.x+State.nodeWidth/2} ${p.y}" class="link"/>`;
                        }
                    });
                }
            });

            // Nodes
            State.people.forEach(p => {
                const color = p.gender === 'male' ? '#64b5f6' : (p.gender === 'female' ? '#f06292' : '#ba68c8');
                svg += `<rect x="${p.x}" y="${p.y}" width="${State.nodeWidth}" height="${State.nodeHeight}" rx="8" class="node" stroke="${color}"/>`;
                svg += `<text x="${p.x+10}" y="${p.y+20}" class="text" font-weight="bold">${p.firstName} ${p.lastName}</text>`;
                svg += `<text x="${p.x+10}" y="${p.y+40}" class="text" font-size="12">${p.birthDate || ''}</text>`;
            });
            svg += `</svg>`;
            const blob = new Blob([svg], {type: "image/svg+xml;charset=utf-8"});
            const url = URL.createObjectURL(blob);
            const anchor = document.createElement('a');
            anchor.href = url;
            anchor.download = "rodokmen.svg";
            document.body.appendChild(anchor);
            anchor.click();
            anchor.remove();
            URL.revokeObjectURL(url);
            showNotification('SVG exportov√°n', 'success');
        }
    </script>
</body>
</html>