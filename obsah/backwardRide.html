<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üöó Simul√°tor couv√°n√≠ s voz√≠kem</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: #1a1a1a;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 15px;
      color: #e0e0e0;
    }
    
    h1 {
      color: #6aa6fd;
      margin-bottom: 12px;
      font-size: 1.5rem;
      font-weight: 600;
    }
    
    .top-bar {
      display: flex;
      gap: 12px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
    }
    
    .stat {
      background: #2a2a2a;
      padding: 6px 14px;
      border-radius: 6px;
      border: 1px solid #404040;
      font-size: 14px;
    }
    
    .stat-value { font-weight: 600; }
    .time { color: #fbbf24; }
    .best { color: #34d399; }
    .level { color: #a78bfa; }
    .score { color: #f472b6; }
    .highscore { color: #fb923c; }
    
    .gamepad-status {
      padding: 6px 14px;
      border-radius: 6px;
      font-size: 14px;
    }
    .gamepad-connected { background: #1a3a1a; color: #34d399; border: 1px solid #34d399; }
    .gamepad-disconnected { background: #2a2a2a; color: #666; border: 1px solid #404040; }
    
    .controls-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 10px;
      background: #2a2a2a;
      padding: 10px 16px;
      border-radius: 6px;
      border: 1px solid #404040;
      flex-wrap: wrap;
      justify-content: center;
      font-size: 13px;
    }
    
    .controls-row label { color: #888; }
    
    .slider {
      width: 100px;
      accent-color: #6aa6fd;
      cursor: pointer;
    }
    
    .slider-value {
      font-weight: 600;
      min-width: 35px;
      text-align: center;
    }
    
    .btn-small {
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.15s;
    }
    .btn-small.active { background: #6aa6fd; color: #fff; }
    .btn-small:not(.active) { background: #404040; color: #e0e0e0; }
    .btn-small:hover:not(.active) { background: #505050; }
    
    .game-container {
      position: relative;
    }
    
    canvas {
      border-radius: 8px;
      border: 1px solid #404040;
      display: block;
    }
    
    .overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
    }
    
    .overlay-box {
      text-align: center;
      padding: 25px 40px;
      background: #2a2a2a;
      border-radius: 8px;
      border: 1px solid;
    }
    .overlay-box.success { border-color: #34d399; }
    .overlay-box.fail { border-color: #f87171; }
    .overlay-box.pause { border-color: #6aa6fd; }
    
    .overlay-box h2 { font-size: 24px; margin: 10px 0; }
    .overlay-box .icon { font-size: 40px; }
    .overlay-box p { font-size: 15px; color: #888; margin-bottom: 15px; }
    .overlay-box .score-detail { font-size: 13px; color: #666; margin-bottom: 10px; }
    
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      margin: 4px;
      transition: all 0.15s;
    }
    .btn-primary { background: #6aa6fd; color: #fff; }
    .btn-primary:hover { background: #5694f0; }
    .btn-secondary { background: #a78bfa; color: #fff; }
    .btn-secondary:hover { background: #8b5cf6; }
    .btn-danger { background: #f87171; color: #fff; }
    .btn-danger:hover { background: #ef4444; }
    
    .instructions {
      margin-top: 12px;
      text-align: center;
      color: #666;
      font-size: 12px;
      line-height: 1.6;
    }
    .instructions kbd {
      background: #404040;
      padding: 2px 6px;
      border-radius: 3px;
      color: #e0e0e0;
      font-size: 11px;
    }
    .hint { color: #6aa6fd; margin-top: 5px; }

    .hidden { display: none !important; }
  </style>
</head>
<body>
  <h1>üöó Simul√°tor couv√°n√≠ s voz√≠kem üöõ</h1>
  
  <div class="top-bar">
    <div class="stat">‚è±Ô∏è <span class="stat-value time" id="time">0.0s</span></div>
    <div class="stat">üèÜ <span class="stat-value best" id="best">---</span></div>
    <div class="stat">üìä Level <span class="stat-value level" id="level">1</span>/5</div>
    <div class="stat">‚≠ê <span class="stat-value score" id="score">0</span></div>
    <div class="stat">ü•á High: <span class="stat-value highscore" id="highscore">0</span></div>
    <div class="stat gamepad-status gamepad-disconnected" id="gamepadStatus">üéÆ ---</div>
  </div>
  
  <div class="controls-row">
    <label>üèéÔ∏è Rychlost:</label>
    <input type="range" class="slider" id="speedSlider" min="0.5" max="5" step="0.5" value="2">
    <span class="slider-value" id="speedValue" style="color:#6aa6fd;">2.0x</span>
    <button class="btn-small" onclick="setSpeed(1)">Pomal√©</button>
    <button class="btn-small active" onclick="setSpeed(2)">Norm√°ln√≠</button>
    <button class="btn-small" onclick="setSpeed(4)">Rychl√©</button>
    <span style="color:#404040; margin: 0 5px;">|</span>
    <label>üéÆ ≈ò√≠zen√≠:</label>
    <input type="range" class="slider" id="steerSlider" min="0.3" max="2" step="0.1" value="1">
    <span class="slider-value" id="steerValue" style="color:#a78bfa;">1.0</span>
    <label>‚ö° Plyn:</label>
    <input type="range" class="slider" id="throttleSlider" min="0.3" max="2" step="0.1" value="1">
    <span class="slider-value" id="throttleValue" style="color:#fbbf24;">1.0</span>
  </div>
  
  <div class="game-container">
    <canvas id="canvas" width="950" height="600"></canvas>
    
    <div class="overlay hidden" id="successOverlay">
      <div class="overlay-box success">
        <div class="icon">üéâ</div>
        <h2 style="color:#34d399;">ZAPARKOV√ÅNO!</h2>
        <p>ƒåas: <span id="finalTime">0.0</span>s</p>
        <div class="score-detail">+<span id="scoreGained">0</span> bod≈Ø</div>
        <button class="btn btn-primary" onclick="resetGame()">üîÑ Znovu</button>
        <button class="btn btn-secondary" id="nextLevelBtn" onclick="nextLevel()">‚û°Ô∏è Level <span id="nextLevelNum">2</span></button>
      </div>
    </div>
    
    <div class="overlay hidden" id="pauseOverlay">
      <div class="overlay-box pause">
        <div class="icon">‚è∏Ô∏è</div>
        <h2 style="color:#6aa6fd;">PAUZA</h2>
        <p>Stiskni P nebo Start pro pokraƒçov√°n√≠</p>
        <button class="btn btn-primary" onclick="togglePause()">‚ñ∂Ô∏è Pokraƒçovat</button>
      </div>
    </div>
  </div>
  
  <div class="instructions">
    <kbd>W</kbd>/<kbd>‚Üë</kbd> Vp≈ôed &nbsp;
    <kbd>S</kbd>/<kbd>‚Üì</kbd> Vzad &nbsp;
    <kbd>A</kbd>/<kbd>‚Üê</kbd> Vlevo &nbsp;
    <kbd>D</kbd>/<kbd>‚Üí</kbd> Vpravo &nbsp;
    <kbd>R</kbd> Reset &nbsp;
    <kbd>P</kbd> Pauza
    <div class="hint">Zacouvej voz√≠k do zelen√© z√≥ny ve smƒõru ≈°ipky. ƒå√≠m rychleji, t√≠m v√≠ce bod≈Ø!</div>
  </div>

<script>
// ==================== KONSTANTY ====================
const CFG = {
  CAR_LENGTH: 60,
  CAR_WIDTH: 30,
  HITCH_OFFSET: 5,
  TRAILER_LENGTH: 40,
  TRAILER_WIDTH: 28,
  DRAWBAR_LENGTH: 20,
  MAX_STEERING: 0.6,
  STEERING_SPEED: 0.04,
  FRICTION: 0.98,
  MAX_LEVELS: 5
};

// ==================== STAV ====================
const state = {
  car: { x: 0, y: 0, angle: 0, steering: 0, velocity: 0 },
  trailer: { angle: 0 },
  keys: { up: false, down: false, left: false, right: false },
  gamepad: { steering: 0, throttle: 0, brake: 0 },
  parked: false,
  paused: false,
  attempts: 0,
  bestTime: null,
  currentTime: 0,
  gameStarted: false,
  level: 1,
  score: 0,
  highScore: parseInt(localStorage.getItem('trailerHighScore')) || 0,
  tireMarks: [],
  particles: [],
  warningLevel: 0,
  trailerCarCollision: false,
  obstacleCollision: false
};

let settings = {
  speed: 2,
  steeringSens: 1,
  throttleSens: 1
};

let parkingZone = {};
let obstacles = [];
let startPos = {};
let gamepadIndex = null;
let lastTime = 0;
let backgroundColor = '#3a3a3a';

// ==================== CANVAS ====================
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// ==================== GENEROV√ÅN√ç LEVELU ====================
function rand(min, max) {
  return Math.random() * (max - min) + min;
}

function randInt(min, max) {
  return Math.floor(rand(min, max + 1));
}

function generateLevel(level) {
  const difficulty = Math.min(level / CFG.MAX_LEVELS, 1);
  
  // N√°hodn√° barva pozad√≠ (b√≠l√°, zelen√°, antracitov√°)
  const bgColors = ['#ffffff', '#2d5a3d', '#3a3a3a'];
  backgroundColor = bgColors[randInt(0, 2)];
  
  // Startovn√≠ pozice
  const startVariants = [
    { x: 180, y: 150 }, { x: 280, y: 180 }, { x: 150, y: 220 },
    { x: 350, y: 130 }, { x: 220, y: 250 }
  ];
  const sv = startVariants[randInt(0, Math.min(level, startVariants.length - 1))];
  startPos = {
    x: sv.x + rand(-25, 25),
    y: sv.y + rand(-20, 20),
    angle: rand(0.3, Math.PI - 0.3)
  };
  
  // Parkovac√≠ z√≥na - V≈ΩDY DOLE, n√°hodnƒõ vlevo/st≈ôed/vpravo
  const parkPositions = ['left', 'center', 'right'];
  const parkPos = parkPositions[randInt(0, 2)];
  
  // Rozmƒõry z√≥ny
  const zoneWidth = 90;
  const zoneHeight = 130;
  
  // X sou≈ôadnice s dostateƒçnou rezervou od okraj≈Ø (z√≥na + auto mus√≠ se vej√≠t)
  let parkX;
  if (parkPos === 'left') {
    parkX = rand(80, 180);
  } else if (parkPos === 'center') {
    parkX = rand(380, 480);
  } else {
    parkX = rand(680, 780);
  }
  
  // Y sou≈ôadnice - st≈ôed z√≥ny mus√≠ b√Ωt tak, aby cel√° z√≥na byla viditeln√°
  // St≈ôed z√≥ny je parkY + zoneHeight/2, tak≈æe doln√≠ okraj je parkY + zoneHeight
  // Canvas v√Ω≈°ka je 600, nech√°me rezervu 30px
  const maxY = canvas.height - zoneHeight - 30; // 600 - 130 - 30 = 440
  const parkY = rand(340, Math.min(400, maxY));
  const parkAngle = Math.PI/2 + rand(-0.05, 0.05); // Men≈°√≠ rotace
  
  parkingZone = {
    x: parkX,
    y: parkY,
    width: zoneWidth,
    height: zoneHeight,
    angle: parkAngle
  };
  
  // P≈ôek√°≈æky
  obstacles = [];
  const numObstacles = 1 + level;
  
  for (let i = 0; i < numObstacles; i++) {
    let obs, valid, attempts = 0;
    do {
      valid = true;
      const isVertical = Math.random() > 0.5;
      obs = {
        x: rand(280, 700),
        y: rand(180, 420),
        width: isVertical ? rand(15, 25) : rand(60, 120),
        height: isVertical ? rand(60, 120) : rand(15, 25)
      };
      
      if (Math.abs(obs.x - startPos.x) < 150 && Math.abs(obs.y - startPos.y) < 100) valid = false;
      if (Math.abs(obs.x - parkingZone.x) < 150 && Math.abs(obs.y - parkingZone.y) < 150) valid = false;
      for (const other of obstacles) {
        if (Math.abs(obs.x - other.x) < 80 && Math.abs(obs.y - other.y) < 80) valid = false;
      }
      attempts++;
    } while (!valid && attempts < 20);
    
    if (valid) obstacles.push(obs);
  }
  
  state.tireMarks = [];
  state.particles = [];
  state.warningLevel = 0;
  state.trailerCarCollision = false;
  state.obstacleCollision = false;
}

// ==================== VSTUP ====================
document.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();
  if (['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d'].includes(key)) {
    e.preventDefault();
    if (!state.paused) state.gameStarted = true;
  }
  if (key === 'arrowup' || key === 'w') state.keys.up = true;
  if (key === 'arrowdown' || key === 's') state.keys.down = true;
  if (key === 'arrowleft' || key === 'a') state.keys.left = true;
  if (key === 'arrowright' || key === 'd') state.keys.right = true;
  if (key === 'r') resetGame();
  if (key === 'p') togglePause();
  if (key === 'escape') togglePause();
});

document.addEventListener('keyup', e => {
  const key = e.key.toLowerCase();
  if (key === 'arrowup' || key === 'w') state.keys.up = false;
  if (key === 'arrowdown' || key === 's') state.keys.down = false;
  if (key === 'arrowleft' || key === 'a') state.keys.left = false;
  if (key === 'arrowright' || key === 'd') state.keys.right = false;
});

// ==================== GAMEPAD ====================
window.addEventListener('gamepadconnected', e => {
  gamepadIndex = e.gamepad.index;
  updateGamepadUI(true);
});

window.addEventListener('gamepaddisconnected', e => {
  if (e.gamepad.index === gamepadIndex) {
    gamepadIndex = null;
    updateGamepadUI(false);
  }
});

function updateGamepadUI(connected) {
  const el = document.getElementById('gamepadStatus');
  el.className = 'stat gamepad-status ' + (connected ? 'gamepad-connected' : 'gamepad-disconnected');
  el.textContent = 'üéÆ ' + (connected ? 'OK' : '---');
}

function pollGamepad() {
  let gp = null;
  try {
    const gamepads = navigator.getGamepads();
    if (gamepadIndex !== null) gp = gamepads[gamepadIndex];
    else {
      for (let i = 0; i < gamepads.length; i++) {
        if (gamepads[i]) { gamepadIndex = i; gp = gamepads[i]; updateGamepadUI(true); break; }
      }
    }
  } catch (e) { return; }
  
  if (!gp) return;
  
  const dz = 0.15;
  let steering = 0, throttle = 0, brake = 0;
  
  // ≈ò√≠zen√≠ - lev√° p√°ƒçka X nebo prav√° p√°ƒçka X
  const leftX = gp.axes[0] || 0;
  const rightX = gp.axes[2] || 0;
  if (Math.abs(leftX) > dz) steering = leftX;
  else if (Math.abs(rightX) > dz) steering = rightX;
  if (gp.buttons[14]?.pressed) steering = -1;
  if (gp.buttons[15]?.pressed) steering = 1;
  
  // Triggery pro plyn/brzdu (maj√≠ prioritu)
  if (gp.buttons[7]) throttle = Math.max(throttle, gp.buttons[7].value || (gp.buttons[7].pressed ? 1 : 0));
  if (gp.buttons[6]) brake = Math.max(brake, gp.buttons[6].value || (gp.buttons[6].pressed ? 1 : 0));
  
  // Lev√° p√°ƒçka Y pro plyn/brzdu - KOMPENZACE diagon√°ln√≠ho pohybu
  const leftY = gp.axes[1] || 0;
  if (Math.abs(leftY) > dz) {
    // Vypoƒç√≠t√°me magnitude vektoru p√°ƒçky
    const magnitude = Math.sqrt(leftX * leftX + leftY * leftY);
    // Normalizujeme Y slo≈æku podle magnitude (kompenzace diagon√°ly)
    // Pokud hr√°ƒç tlaƒç√≠ diagon√°lnƒõ, Y slo≈æka se kompenzuje
    let normalizedY = leftY;
    if (magnitude > dz) {
      // Zachov√°me smƒõr, ale pou≈æijeme vƒõt≈°√≠ hodnotu pro kompenzaci
      normalizedY = (leftY / magnitude) * Math.min(magnitude, 1);
    }
    
    if (normalizedY < -dz) throttle = Math.max(throttle, -normalizedY);
    if (normalizedY > dz) brake = Math.max(brake, normalizedY);
  }
  
  // Tlaƒç√≠tka pro plyn/brzdu
  if (gp.buttons[0]?.pressed) throttle = 1;
  if (gp.buttons[1]?.pressed) brake = 1;
  if (gp.buttons[5]?.pressed) throttle = 1;
  if (gp.buttons[4]?.pressed) brake = 1;
  if (gp.buttons[12]?.pressed) throttle = 1;
  if (gp.buttons[13]?.pressed) brake = 1;
  
  if (gp.buttons[9]?.pressed) togglePause();
  if (gp.buttons[8]?.pressed) resetGame();
  
  state.gamepad = { steering, throttle, brake };
  if ((throttle > 0.1 || brake > 0.1) && !state.paused) state.gameStarted = true;
}

// ==================== UI ====================
document.getElementById('speedSlider').oninput = e => {
  settings.speed = parseFloat(e.target.value);
  document.getElementById('speedValue').textContent = settings.speed.toFixed(1) + 'x';
  updateSpeedBtns();
};

document.getElementById('steerSlider').oninput = e => {
  settings.steeringSens = parseFloat(e.target.value);
  document.getElementById('steerValue').textContent = settings.steeringSens.toFixed(1);
};

document.getElementById('throttleSlider').oninput = e => {
  settings.throttleSens = parseFloat(e.target.value);
  document.getElementById('throttleValue').textContent = settings.throttleSens.toFixed(1);
};

function setSpeed(val) {
  settings.speed = val;
  document.getElementById('speedSlider').value = val;
  document.getElementById('speedValue').textContent = val.toFixed(1) + 'x';
  updateSpeedBtns();
}

function updateSpeedBtns() {
  document.querySelectorAll('.btn-small').forEach(b => {
    b.classList.toggle('active', 
      (b.textContent === 'Pomal√©' && settings.speed === 1) ||
      (b.textContent === 'Norm√°ln√≠' && settings.speed === 2) ||
      (b.textContent === 'Rychl√©' && settings.speed === 4)
    );
  });
}

function updateUI() {
  document.getElementById('time').textContent = state.currentTime.toFixed(1) + 's';
  document.getElementById('best').textContent = state.bestTime ? state.bestTime.toFixed(1) + 's' : '---';
  document.getElementById('level').textContent = state.level;
  document.getElementById('score').textContent = state.score;
  document.getElementById('highscore').textContent = state.highScore;
}

// ==================== FYZIKA ====================
function normalizeAngle(a) {
  while (a > Math.PI) a -= Math.PI * 2;
  while (a < -Math.PI) a += Math.PI * 2;
  return a;
}

function getCorners(cx, cy, len, wid, angle) {
  const cos = Math.cos(angle), sin = Math.sin(angle);
  const hl = len/2, hw = wid/2;
  return [
    { x: cx + cos*hl - sin*hw, y: cy + sin*hl + cos*hw },
    { x: cx + cos*hl + sin*hw, y: cy + sin*hl - cos*hw },
    { x: cx - cos*hl + sin*hw, y: cy - sin*hl - cos*hw },
    { x: cx - cos*hl - sin*hw, y: cy - sin*hl + cos*hw }
  ];
}

function polygonsIntersect(p1, p2) {
  for (const poly of [p1, p2]) {
    for (let i = 0; i < poly.length; i++) {
      const j = (i + 1) % poly.length;
      const ax = -(poly[j].y - poly[i].y), ay = poly[j].x - poly[i].x;
      let min1 = Infinity, max1 = -Infinity, min2 = Infinity, max2 = -Infinity;
      for (const p of p1) { const d = p.x*ax + p.y*ay; min1 = Math.min(min1,d); max1 = Math.max(max1,d); }
      for (const p of p2) { const d = p.x*ax + p.y*ay; min2 = Math.min(min2,d); max2 = Math.max(max2,d); }
      if (max1 < min2 || max2 < min1) return false;
    }
  }
  return true;
}

function distToObstacle(carCorners, trailerCorners) {
  let minDist = Infinity;
  const allCorners = [...carCorners, ...trailerCorners];
  
  for (const obs of obstacles) {
    const cx = obs.x + obs.width/2, cy = obs.y + obs.height/2;
    for (const c of allCorners) {
      const d = Math.sqrt((c.x - cx)**2 + (c.y - cy)**2) - Math.max(obs.width, obs.height)/2;
      minDist = Math.min(minDist, d);
    }
  }
  
  for (const c of allCorners) {
    minDist = Math.min(minDist, c.x, c.y, canvas.width - c.x, canvas.height - c.y);
  }
  
  return minDist;
}

function checkObstacleCollision(carCorners, trailerCorners) {
  let carCollision = false;
  let trailerCollision = false;
  let collisionPoint = null;
  
  for (const obs of obstacles) {
    const oc = [
      {x: obs.x, y: obs.y}, {x: obs.x + obs.width, y: obs.y},
      {x: obs.x + obs.width, y: obs.y + obs.height}, {x: obs.x, y: obs.y + obs.height}
    ];
    if (polygonsIntersect(carCorners, oc)) {
      carCollision = true;
      collisionPoint = { x: obs.x + obs.width/2, y: obs.y + obs.height/2 };
    }
    if (polygonsIntersect(trailerCorners, oc)) {
      trailerCollision = true;
      collisionPoint = { x: obs.x + obs.width/2, y: obs.y + obs.height/2 };
    }
  }
  
  return { car: carCollision, trailer: trailerCollision, point: collisionPoint };
}

function checkBoundaryCollision(carCorners, trailerCorners) {
  for (const c of [...carCorners, ...trailerCorners]) {
    if (c.x < 0 || c.x > canvas.width || c.y < 0 || c.y > canvas.height) return true;
  }
  return false;
}

function checkTrailerCarCollision(carCorners, trailerCorners) {
  return polygonsIntersect(carCorners, trailerCorners);
}

function getPolygonInsideZonePercentage(corners, zone) {
  const zcx = zone.x + zone.width/2;
  const zcy = zone.y + zone.height/2;
  const rot = -(zone.angle - Math.PI/2);
  
  let insideCount = 0;
  const testPoints = [];
  
  for (const c of corners) {
    testPoints.push(c);
  }
  
  for (let i = 0; i < corners.length; i++) {
    const c1 = corners[i];
    const c2 = corners[(i + 1) % corners.length];
    for (let t = 0.25; t < 1; t += 0.25) {
      testPoints.push({
        x: c1.x + (c2.x - c1.x) * t,
        y: c1.y + (c2.y - c1.y) * t
      });
    }
  }
  
  const centerX = corners.reduce((s, c) => s + c.x, 0) / corners.length;
  const centerY = corners.reduce((s, c) => s + c.y, 0) / corners.length;
  testPoints.push({ x: centerX, y: centerY });
  
  for (const p of testPoints) {
    const relX = p.x - zcx;
    const relY = p.y - zcy;
    const lx = relX * Math.cos(rot) - relY * Math.sin(rot);
    const ly = relX * Math.sin(rot) + relY * Math.cos(rot);
    
    if (Math.abs(lx) < zone.width/2 && Math.abs(ly) < zone.height/2) {
      insideCount++;
    }
  }
  
  return insideCount / testPoints.length;
}

function checkParked() {
  const { car, trailer } = state;
  const hitchX = car.x - Math.cos(car.angle) * (CFG.CAR_LENGTH/2 + CFG.HITCH_OFFSET);
  const hitchY = car.y - Math.sin(car.angle) * (CFG.CAR_LENGTH/2 + CFG.HITCH_OFFSET);
  const tcX = hitchX - Math.cos(trailer.angle) * (CFG.DRAWBAR_LENGTH + CFG.TRAILER_LENGTH/2);
  const tcY = hitchY - Math.sin(trailer.angle) * (CFG.DRAWBAR_LENGTH + CFG.TRAILER_LENGTH/2);
  
  const trailerCorners = getCorners(tcX, tcY, CFG.TRAILER_LENGTH, CFG.TRAILER_WIDTH, trailer.angle);
  const carCorners = getCorners(car.x, car.y, CFG.CAR_LENGTH, CFG.CAR_WIDTH, car.angle);
  
  const trailerInside = getPolygonInsideZonePercentage(trailerCorners, parkingZone);
  const carInside = getPolygonInsideZonePercentage(carCorners, parkingZone);
  
  const angleDiff = Math.abs(normalizeAngle(trailer.angle - parkingZone.angle));
  const aligned = angleDiff < 0.35 || Math.abs(angleDiff - Math.PI) < 0.35;
  
  return trailerInside >= 0.99 && carInside >= 0.75 && aligned && Math.abs(car.velocity) < 0.1;
}

function createCollisionSparks(x, y, intensity) {
  const count = Math.floor(5 + intensity * 10);
  for (let i = 0; i < count; i++) {
    state.particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 6 * intensity,
      vy: (Math.random() - 0.5) * 6 * intensity,
      life: 0.3 + Math.random() * 0.4,
      color: Math.random() > 0.5 ? '#fbbf24' : '#ef4444'
    });
  }
}

// ==================== UPDATE ====================
function update(dt) {
  if (state.parked || state.paused) return;
  
  if (state.gameStarted) state.currentTime += dt;
  
  const { car, trailer, keys, gamepad } = state;
  const { speed, steeringSens, throttleSens } = settings;
  
  const prevCarX = car.x;
  const prevCarY = car.y;
  const prevCarAngle = car.angle;
  const prevTrailerAngle = trailer.angle;
  
  // ≈ò√≠zen√≠
  let steer = car.steering;
  if (Math.abs(gamepad.steering) > 0.01) {
    const curved = Math.sign(gamepad.steering) * Math.pow(Math.abs(gamepad.steering), 2 - steeringSens);
    steer = curved * CFG.MAX_STEERING * steeringSens;
  } else if (keys.left) {
    steer = Math.max(steer - CFG.STEERING_SPEED * steeringSens, -CFG.MAX_STEERING);
  } else if (keys.right) {
    steer = Math.min(steer + CFG.STEERING_SPEED * steeringSens, CFG.MAX_STEERING);
  } else {
    steer *= 0.9;
  }
  steer = Math.max(-CFG.MAX_STEERING, Math.min(CFG.MAX_STEERING, steer));
  
  // Rychlost
  let vel = car.velocity;
  if (gamepad.throttle > 0.01 || gamepad.brake > 0.01) {
    const accel = 0.12 * throttleSens;
    if (gamepad.throttle > 0.01) {
      // C√≠lov√° rychlost je v≈ædy maxim√°ln√≠, throttle ovliv≈àuje akceleraci
      const target = speed * throttleSens;
      const effectiveAccel = accel * gamepad.throttle; // Akcelerace z√°vis√≠ na s√≠le stisku
      vel = vel < target ? Math.min(vel + effectiveAccel, target) : vel * 0.98;
    }
    if (gamepad.brake > 0.01) {
      const target = -speed * throttleSens;
      const effectiveAccel = accel * gamepad.brake;
      vel = vel > target ? Math.max(vel - effectiveAccel, target) : vel * 0.98;
    }
    vel = Math.max(-speed, Math.min(speed, vel));
  } else if (keys.up) {
    vel = Math.min(vel + 0.1, speed);
  } else if (keys.down) {
    vel = Math.max(vel - 0.1, -speed);
  } else {
    vel *= CFG.FRICTION;
  }
  
  // Pohyb
  const turnRate = vel * Math.tan(steer) / CFG.CAR_LENGTH;
  let newAngle = car.angle + turnRate;
  let newX = car.x + Math.cos(newAngle) * vel;
  let newY = car.y + Math.sin(newAngle) * vel;
  
  // Voz√≠k
  const pivotLen = CFG.DRAWBAR_LENGTH + CFG.TRAILER_LENGTH/2;
  const oldHitchX = car.x - Math.cos(car.angle) * (CFG.CAR_LENGTH/2 + CFG.HITCH_OFFSET);
  const oldHitchY = car.y - Math.sin(car.angle) * (CFG.CAR_LENGTH/2 + CFG.HITCH_OFFSET);
  const oldWheelX = oldHitchX - Math.cos(trailer.angle) * pivotLen;
  const oldWheelY = oldHitchY - Math.sin(trailer.angle) * pivotLen;
  
  let hitchX = newX - Math.cos(newAngle) * (CFG.CAR_LENGTH/2 + CFG.HITCH_OFFSET);
  let hitchY = newY - Math.sin(newAngle) * (CFG.CAR_LENGTH/2 + CFG.HITCH_OFFSET);
  
  const long = (hitchX - oldHitchX) * Math.cos(trailer.angle) + (hitchY - oldHitchY) * Math.sin(trailer.angle);
  let newWheelX = oldWheelX + long * Math.cos(trailer.angle);
  let newWheelY = oldWheelY + long * Math.sin(trailer.angle);
  let newTrailerAngle = Math.atan2(hitchY - newWheelY, hitchX - newWheelX);
  
  // Kolize voz√≠k-auto
  let carCorners = getCorners(newX, newY, CFG.CAR_LENGTH, CFG.CAR_WIDTH, newAngle);
  let tcX = hitchX - Math.cos(newTrailerAngle) * (CFG.DRAWBAR_LENGTH + CFG.TRAILER_LENGTH/2);
  let tcY = hitchY - Math.sin(newTrailerAngle) * (CFG.DRAWBAR_LENGTH + CFG.TRAILER_LENGTH/2);
  let trailerCorners = getCorners(tcX, tcY, CFG.TRAILER_LENGTH, CFG.TRAILER_WIDTH, newTrailerAngle);
  
  const trailerCarCollision = checkTrailerCarCollision(carCorners, trailerCorners);
  
  if (trailerCarCollision) {
    state.trailerCarCollision = true;
    
    const maxJackknife = Math.PI * 0.45;
    const angleDiffFromCar = normalizeAngle(newTrailerAngle - newAngle);
    
    if (Math.abs(angleDiffFromCar) > maxJackknife) {
      const limitedAngleDiff = Math.sign(angleDiffFromCar) * maxJackknife;
      newTrailerAngle = newAngle + limitedAngleDiff;
      newWheelX = hitchX - Math.cos(newTrailerAngle) * pivotLen;
      newWheelY = hitchY - Math.sin(newTrailerAngle) * pivotLen;
    }
    
    if (Math.random() > 0.7) {
      state.particles.push({
        x: hitchX, y: hitchY,
        vx: (Math.random() - 0.5) * 4,
        vy: (Math.random() - 0.5) * 4,
        life: 0.5,
        color: '#fbbf24'
      });
    }
  } else {
    state.trailerCarCollision = false;
  }
  
  // P≈ôepoƒç√≠t√°me pozice
  tcX = hitchX - Math.cos(newTrailerAngle) * (CFG.DRAWBAR_LENGTH + CFG.TRAILER_LENGTH/2);
  tcY = hitchY - Math.sin(newTrailerAngle) * (CFG.DRAWBAR_LENGTH + CFG.TRAILER_LENGTH/2);
  carCorners = getCorners(newX, newY, CFG.CAR_LENGTH, CFG.CAR_WIDTH, newAngle);
  trailerCorners = getCorners(tcX, tcY, CFG.TRAILER_LENGTH, CFG.TRAILER_WIDTH, newTrailerAngle);
  
  // Kolize s p≈ôek√°≈ækami
  const obstacleCollision = checkObstacleCollision(carCorners, trailerCorners);
  const boundaryCollision = checkBoundaryCollision(carCorners, trailerCorners);
  
  if (obstacleCollision.car || obstacleCollision.trailer || boundaryCollision) {
    state.obstacleCollision = true;
    
    const collisionIntensity = Math.abs(vel) / speed;
    if (obstacleCollision.point) {
      createCollisionSparks(obstacleCollision.point.x, obstacleCollision.point.y, collisionIntensity);
    } else {
      createCollisionSparks(
        obstacleCollision.car ? newX : tcX,
        obstacleCollision.car ? newY : tcY,
        collisionIntensity
      );
    }
    
    vel = -vel * 0.3;
    
    newX = prevCarX;
    newY = prevCarY;
    newAngle = prevCarAngle;
    newTrailerAngle = prevTrailerAngle;
    
    hitchX = newX - Math.cos(newAngle) * (CFG.CAR_LENGTH/2 + CFG.HITCH_OFFSET);
    hitchY = newY - Math.sin(newAngle) * (CFG.CAR_LENGTH/2 + CFG.HITCH_OFFSET);
  } else {
    state.obstacleCollision = false;
  }
  
  // Stopy pneumatik
  if (Math.abs(vel) > 0.3 && state.gameStarted && !state.obstacleCollision) {
    if (state.tireMarks.length > 500) state.tireMarks.shift();
    state.tireMarks.push({
      x: oldWheelX, y: oldWheelY,
      angle: trailer.angle,
      age: 1
    });
  }
  
  car.x = newX; car.y = newY;
  car.angle = newAngle; car.steering = steer; car.velocity = vel;
  trailer.angle = newTrailerAngle;
  
  const finalCarCorners = getCorners(car.x, car.y, CFG.CAR_LENGTH, CFG.CAR_WIDTH, car.angle);
  const finalHitchX = car.x - Math.cos(car.angle) * (CFG.CAR_LENGTH/2 + CFG.HITCH_OFFSET);
  const finalHitchY = car.y - Math.sin(car.angle) * (CFG.CAR_LENGTH/2 + CFG.HITCH_OFFSET);
  const finalTcX = finalHitchX - Math.cos(trailer.angle) * (CFG.DRAWBAR_LENGTH + CFG.TRAILER_LENGTH/2);
  const finalTcY = finalHitchY - Math.sin(trailer.angle) * (CFG.DRAWBAR_LENGTH + CFG.TRAILER_LENGTH/2);
  const finalTrailerCorners = getCorners(finalTcX, finalTcY, CFG.TRAILER_LENGTH, CFG.TRAILER_WIDTH, trailer.angle);
  
  const dist = distToObstacle(finalCarCorners, finalTrailerCorners);
  state.warningLevel = dist < 30 ? Math.max(0, 1 - dist/30) : 0;
  
  if (checkParked()) {
    state.parked = true;
    const timeBonus = Math.max(0, Math.floor((60 - state.currentTime) * 10));
    const levelBonus = state.level * 100;
    const attemptPenalty = Math.max(0, (state.attempts - 1) * 20);
    const gained = Math.max(10, timeBonus + levelBonus - attemptPenalty);
    state.score += gained;
    
    if (state.score > state.highScore) {
      state.highScore = state.score;
      localStorage.setItem('trailerHighScore', state.highScore);
    }
    
    if (!state.bestTime || state.currentTime < state.bestTime) {
      state.bestTime = state.currentTime;
    }
    
    document.getElementById('finalTime').textContent = state.currentTime.toFixed(1);
    document.getElementById('scoreGained').textContent = gained;
    document.getElementById('nextLevelNum').textContent = Math.min(state.level + 1, CFG.MAX_LEVELS);
    document.getElementById('nextLevelBtn').classList.toggle('hidden', state.level >= CFG.MAX_LEVELS);
    document.getElementById('successOverlay').classList.remove('hidden');
  }
  
  state.tireMarks.forEach(m => m.age *= 0.998);
  state.tireMarks = state.tireMarks.filter(m => m.age > 0.1);
  
  state.particles = state.particles.filter(p => {
    p.x += p.vx; p.y += p.vy;
    p.vy += 0.2; p.life -= 0.02;
    return p.life > 0;
  });
  
  updateUI();
}

// ==================== VYKRESLOV√ÅN√ç ====================
function draw() {
  const { car, trailer, warningLevel } = state;
  
  ctx.fillStyle = backgroundColor;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  const tireMarkColor = backgroundColor === '#ffffff' ? '#cccccc' : '#2a2a2a';
  ctx.fillStyle = tireMarkColor;
  for (const m of state.tireMarks) {
    ctx.save();
    ctx.globalAlpha = m.age * 0.4;
    ctx.translate(m.x, m.y);
    ctx.rotate(m.angle);
    ctx.fillRect(-3, -CFG.TRAILER_WIDTH/2 - 2, 6, 4);
    ctx.fillRect(-3, CFG.TRAILER_WIDTH/2 - 2, 6, 4);
    ctx.restore();
  }
  ctx.globalAlpha = 1;
  
  if (warningLevel > 0 || state.obstacleCollision) {
    ctx.save();
    const intensity = state.obstacleCollision ? 1 : warningLevel;
    ctx.strokeStyle = `rgba(248, 113, 113, ${intensity * 0.6})`;
    ctx.lineWidth = state.obstacleCollision ? 12 : 8;
    ctx.strokeRect(4, 4, canvas.width - 8, canvas.height - 8);
    ctx.restore();
  }
  
  // Parkovac√≠ z√≥na
  ctx.save();
  const zcx = parkingZone.x + parkingZone.width/2;
  const zcy = parkingZone.y + parkingZone.height/2;
  ctx.translate(zcx, zcy);
  ctx.rotate(parkingZone.angle - Math.PI/2);
  ctx.fillStyle = state.parked ? '#34d39944' : '#34d39920';
  ctx.strokeStyle = state.parked ? '#34d399' : '#34d39966';
  ctx.lineWidth = 2;
  ctx.setLineDash([8, 4]);
  ctx.fillRect(-parkingZone.width/2, -parkingZone.height/2, parkingZone.width, parkingZone.height);
  ctx.strokeRect(-parkingZone.width/2, -parkingZone.height/2, parkingZone.width, parkingZone.height);
  ctx.setLineDash([]);
  ctx.strokeStyle = state.parked ? '#34d399' : '#34d39955';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, parkingZone.height * 0.3);
  ctx.lineTo(0, -parkingZone.height * 0.3);
  ctx.moveTo(-8, -parkingZone.height * 0.3 + 12);
  ctx.lineTo(0, -parkingZone.height * 0.3);
  ctx.lineTo(8, -parkingZone.height * 0.3 + 12);
  ctx.stroke();
  ctx.restore();
  
  // P≈ôek√°≈æky
  for (const obs of obstacles) {
    ctx.fillStyle = '#ef4444';
    ctx.strokeStyle = '#b91c1c';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(obs.x, obs.y, obs.width, obs.height, 3);
    ctx.fill();
    ctx.stroke();
    ctx.strokeStyle = '#fbbf24';
    ctx.lineWidth = 2;
    const step = 12;
    ctx.save();
    ctx.beginPath();
    ctx.rect(obs.x, obs.y, obs.width, obs.height);
    ctx.clip();
    for (let i = -obs.height; i < obs.width + obs.height; i += step) {
      ctx.moveTo(obs.x + i, obs.y);
      ctx.lineTo(obs.x + i + obs.height, obs.y + obs.height);
    }
    ctx.stroke();
    ctx.restore();
  }
  
  const hitchX = car.x - Math.cos(car.angle) * (CFG.CAR_LENGTH/2 + CFG.HITCH_OFFSET);
  const hitchY = car.y - Math.sin(car.angle) * (CFG.CAR_LENGTH/2 + CFG.HITCH_OFFSET);
  const tcX = hitchX - Math.cos(trailer.angle) * (CFG.DRAWBAR_LENGTH + CFG.TRAILER_LENGTH/2);
  const tcY = hitchY - Math.sin(trailer.angle) * (CFG.DRAWBAR_LENGTH + CFG.TRAILER_LENGTH/2);
  
  // St√≠n
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.save();
  ctx.translate(tcX + 4, tcY + 4);
  ctx.rotate(trailer.angle);
  ctx.beginPath();
  ctx.roundRect(-CFG.TRAILER_LENGTH/2, -CFG.TRAILER_WIDTH/2, CFG.TRAILER_LENGTH, CFG.TRAILER_WIDTH, 4);
  ctx.fill();
  ctx.restore();
  ctx.save();
  ctx.translate(car.x + 4, car.y + 4);
  ctx.rotate(car.angle);
  ctx.beginPath();
  ctx.roundRect(-CFG.CAR_LENGTH/2, -CFG.CAR_WIDTH/2, CFG.CAR_LENGTH, CFG.CAR_WIDTH, 5);
  ctx.fill();
  ctx.restore();
  
  // Oj
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 5;
  ctx.beginPath();
  ctx.moveTo(car.x - Math.cos(car.angle) * CFG.CAR_LENGTH/2, car.y - Math.sin(car.angle) * CFG.CAR_LENGTH/2);
  ctx.lineTo(hitchX, hitchY);
  ctx.lineTo(hitchX - Math.cos(trailer.angle) * CFG.DRAWBAR_LENGTH, hitchY - Math.sin(trailer.angle) * CFG.DRAWBAR_LENGTH);
  ctx.stroke();
  
  // Voz√≠k
  ctx.save();
  ctx.translate(tcX, tcY);
  ctx.rotate(trailer.angle);
  const tg = ctx.createLinearGradient(-CFG.TRAILER_LENGTH/2, -CFG.TRAILER_WIDTH/2, CFG.TRAILER_LENGTH/2, CFG.TRAILER_WIDTH/2);
  tg.addColorStop(0, '#6b7280'); tg.addColorStop(1, '#4b5563');
  ctx.fillStyle = tg;
  ctx.strokeStyle = state.trailerCarCollision ? '#fbbf24' : (state.obstacleCollision ? '#ef4444' : '#9ca3af');
  ctx.lineWidth = (state.trailerCarCollision || state.obstacleCollision) ? 3 : 2;
  ctx.beginPath();
  ctx.roundRect(-CFG.TRAILER_LENGTH/2, -CFG.TRAILER_WIDTH/2, CFG.TRAILER_LENGTH, CFG.TRAILER_WIDTH, 4);
  ctx.fill(); ctx.stroke();
  ctx.fillStyle = '#1f2937';
  ctx.fillRect(-5, -CFG.TRAILER_WIDTH/2 - 4, 10, 6);
  ctx.fillRect(-5, CFG.TRAILER_WIDTH/2 - 2, 10, 6);
  ctx.restore();
  
  // Auto
  ctx.save();
  ctx.translate(car.x, car.y);
  ctx.rotate(car.angle);
  const cg = ctx.createLinearGradient(-CFG.CAR_LENGTH/2, -CFG.CAR_WIDTH/2, CFG.CAR_LENGTH/2, CFG.CAR_WIDTH/2);
  cg.addColorStop(0, '#3b82f6'); cg.addColorStop(1, '#1d4ed8');
  ctx.fillStyle = cg;
  ctx.strokeStyle = state.trailerCarCollision ? '#fbbf24' : (state.obstacleCollision ? '#ef4444' : '#60a5fa');
  ctx.lineWidth = (state.trailerCarCollision || state.obstacleCollision) ? 3 : 2;
  ctx.beginPath();
  ctx.roundRect(-CFG.CAR_LENGTH/2, -CFG.CAR_WIDTH/2, CFG.CAR_LENGTH, CFG.CAR_WIDTH, 5);
  ctx.fill(); ctx.stroke();
  ctx.fillStyle = 'rgba(30,30,30,0.7)';
  ctx.beginPath();
  ctx.roundRect(-CFG.CAR_LENGTH/2 + 22, -CFG.CAR_WIDTH/2 + 4, 22, CFG.CAR_WIDTH - 8, 3);
  ctx.fill();
  ctx.fillStyle = '#fef08a';
  ctx.beginPath();
  ctx.arc(CFG.CAR_LENGTH/2 - 5, -CFG.CAR_WIDTH/2 + 6, 3, 0, Math.PI*2);
  ctx.arc(CFG.CAR_LENGTH/2 - 5, CFG.CAR_WIDTH/2 - 6, 3, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = '#ef4444';
  ctx.beginPath();
  ctx.arc(-CFG.CAR_LENGTH/2 + 5, -CFG.CAR_WIDTH/2 + 6, 3, 0, Math.PI*2);
  ctx.arc(-CFG.CAR_LENGTH/2 + 5, CFG.CAR_WIDTH/2 - 6, 3, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = '#1f2937';
  ctx.save();
  ctx.translate(CFG.CAR_LENGTH/2 - 10, -CFG.CAR_WIDTH/2);
  ctx.rotate(car.steering);
  ctx.fillRect(-5, -5, 10, 6);
  ctx.restore();
  ctx.save();
  ctx.translate(CFG.CAR_LENGTH/2 - 10, CFG.CAR_WIDTH/2);
  ctx.rotate(car.steering);
  ctx.fillRect(-5, -1, 10, 6);
  ctx.restore();
  ctx.fillRect(-CFG.CAR_LENGTH/2 + 5, -CFG.CAR_WIDTH/2 - 4, 10, 6);
  ctx.fillRect(-CFG.CAR_LENGTH/2 + 5, CFG.CAR_WIDTH/2 - 2, 10, 6);
  ctx.restore();
  
  // ƒå√°stice
  for (const p of state.particles) {
    ctx.fillStyle = p.color;
    ctx.globalAlpha = p.life;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  
  // HUD
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.beginPath();
  ctx.roundRect(canvas.width - 90, canvas.height - 50, 80, 40, 6);
  ctx.fill();
  ctx.fillStyle = '#e0e0e0';
  ctx.font = '11px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('RYCHLOST', canvas.width - 50, canvas.height - 35);
  ctx.font = 'bold 16px system-ui';
  ctx.fillStyle = Math.abs(car.velocity) > settings.speed * 0.8 ? '#fbbf24' : '#34d399';
  ctx.fillText(Math.abs(car.velocity).toFixed(1), canvas.width - 50, canvas.height - 18);
  
  ctx.save();
  ctx.translate(55, canvas.height - 55);
  ctx.strokeStyle = '#404040';
  ctx.lineWidth = 6;
  ctx.beginPath();
  ctx.arc(0, 0, 28, 0, Math.PI * 2);
  ctx.stroke();
  ctx.rotate(-car.steering * 2.5);
  ctx.strokeStyle = '#e0e0e0';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(0, 0, 28, -Math.PI/2 - 0.4, -Math.PI/2 + 0.4);
  ctx.stroke();
  ctx.fillStyle = '#e0e0e0';
  ctx.beginPath();
  ctx.moveTo(0, -20);
  ctx.lineTo(-6, -12);
  ctx.lineTo(6, -12);
  ctx.fill();
  ctx.restore();
  
  if (state.trailerCarCollision) {
    ctx.fillStyle = 'rgba(251, 191, 36, 0.8)';
    ctx.beginPath();
    ctx.roundRect(canvas.width/2 - 60, 10, 120, 25, 4);
    ctx.fill();
    ctx.fillStyle = '#000';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('‚ö†Ô∏è ZLOM VOZ√çKU', canvas.width/2, 27);
  }
  
  if (state.obstacleCollision) {
    ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
    ctx.beginPath();
    ctx.roundRect(canvas.width/2 - 50, state.trailerCarCollision ? 40 : 10, 100, 25, 4);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('üí• N√ÅRAZ!', canvas.width/2, state.trailerCarCollision ? 57 : 27);
  }
  
  if (state.paused && !state.parked) {
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
}

// ==================== GAME LOOP ====================
function gameLoop(timestamp) {
  const dt = lastTime ? Math.min((timestamp - lastTime) / 1000, 0.1) : 0.016;
  lastTime = timestamp;
  
  pollGamepad();
  update(dt);
  draw();
  requestAnimationFrame(gameLoop);
}

// ==================== AKCE ====================
function resetGame() {
  generateLevel(state.level);
  state.car = { x: startPos.x, y: startPos.y, angle: startPos.angle, steering: 0, velocity: 0 };
  state.trailer = { angle: startPos.angle };
  state.parked = false;
  state.paused = false;
  state.currentTime = 0;
  state.gameStarted = false;
  state.attempts++;
  state.particles = [];
  state.warningLevel = 0;
  state.trailerCarCollision = false;
  state.obstacleCollision = false;
  document.querySelectorAll('.overlay').forEach(o => o.classList.add('hidden'));
  updateUI();
}

function nextLevel() {
  state.level = Math.min(state.level + 1, CFG.MAX_LEVELS);
  state.bestTime = null;
  state.attempts = 0;
  resetGame();
  state.attempts = 0;
}

function togglePause() {
  if (state.parked) return;
  state.paused = !state.paused;
  document.getElementById('pauseOverlay').classList.toggle('hidden', !state.paused);
}

// ==================== INIT ====================
generateLevel(1);
state.car = { x: startPos.x, y: startPos.y, angle: startPos.angle, steering: 0, velocity: 0 };
state.trailer = { angle: startPos.angle };
updateUI();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
