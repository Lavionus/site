<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üîß Gener√°tor redukc√≠ trubek</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: #1a1a1a;
      color: #e0e0e0;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 40px;
    }

    .header h1 {
      font-size: 1.4rem;
      font-weight: 600;
      margin: 0;
      margin-bottom: 10px;
      color: #e0e0e0;
    }

    .main-content {
      display: grid;
      grid-template-columns: 400px 1fr;
      gap: 20px;
    }

    .controls-section {
      background-color: #2a2a2a;
      border: 1px solid #404040;
      border-radius: 8px;
      padding: 20px;
      height: fit-content;
    }

    .controls-section h2 {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 20px;
      color: #e0e0e0;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      font-size: 0.9rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
      font-weight: 600;
    }

    .form-group input[type="number"] {
      width: 100%;
      padding: 8px 12px;
      background-color: #404040;
      border: 1px solid #555;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 0.9rem;
      transition: all 0.3s ease;
    }

    .form-group input[type="number"]:focus {
      outline: none;
      border-color: #6aa6fd;
    }

    .form-group input[type="number"]::placeholder {
      color: #999;
    }

    /* Styly pro slider pr≈Øhlednosti */
    .form-group input[type="range"] {
      width: 100%;
      height: 6px;
      background: linear-gradient(to right, #404040 0%, #6aa6fd 100%);
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      cursor: pointer;
    }

    .form-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: #6aa6fd;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .form-group input[type="range"]::-webkit-slider-thumb:hover {
      background: #5694f0;
      transform: scale(1.1);
    }

    .form-group input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #6aa6fd;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .form-group input[type="range"]::-moz-range-thumb:hover {
      background: #5694f0;
      transform: scale(1.1);
    }

    /* Styly pro color picker */
    .form-group input[type="color"] {
      width: 100%;
      height: 40px;
      padding: 4px;
      background-color: #404040;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .form-group input[type="color"]:hover {
      border-color: #6aa6fd;
    }

    .form-group input[type="color"]:focus {
      outline: none;
      border-color: #6aa6fd;
      box-shadow: 0 0 0 2px rgba(106, 166, 253, 0.2);
    }

    /* Styly pro select (kvality) */
    .form-group select {
      width: 100%;
      padding: 8px 12px;
      background-color: #404040;
      border: 1px solid #555;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 0.9rem;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .form-group select:focus {
      outline: none;
      border-color: #6aa6fd;
    }

    .form-group select option {
      background-color: #404040;
      color: #e0e0e0;
    }

    .slider-value {
      display: inline-block;
      float: right;
      color: #6aa6fd;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .radio-group {
      display: flex;
      gap: 15px;
      margin-top: 8px;
    }

    .radio-option {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }

    .radio-option input[type="radio"] {
      appearance: none;
      width: 20px;
      height: 20px;
      border: 2px solid #555;
      border-radius: 50%;
      background-color: #404040;
      cursor: pointer;
      position: relative;
      transition: all 0.3s ease;
    }

    .radio-option input[type="radio"]:checked {
      border-color: #6aa6fd;
    }

    .radio-option input[type="radio"]:checked::after {
      content: '';
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #6aa6fd;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .radio-option label {
      margin: 0;
      text-transform: none;
      font-size: 0.9rem;
      color: #e0e0e0;
      cursor: pointer;
    }

    .angle-group {
      display: none;
    }

    .angle-group.active {
      display: block;
    }

    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 30px;
    }

    .btn {
      flex: 1;
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.3s ease;
      font-weight: 500;
    }

    .btn-primary {
      background-color: #6aa6fd;
      color: white;
    }

    .btn-primary:hover {
      background-color: #5694f0;
    }

    .btn-secondary {
      background-color: #404040;
      color: #e0e0e0;
      border: 1px solid #555;
    }

    .btn-secondary:hover {
      background-color: #4a4a4a;
    }

    .export-section {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #404040;
    }

    .export-section h3 {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 15px;
      color: #e0e0e0;
    }

    .export-subsection {
      margin-bottom: 15px;
    }

    .export-subsection h4 {
      font-size: 0.85rem;
      font-weight: 500;
      margin-bottom: 10px;
      color: #aaa;
    }

    .viewer-section {
      background-color: #2a2a2a;
      border: 1px solid #404040;
      border-radius: 8px;
      padding: 20px;
      position: relative;
    }

    .viewer-section h2 {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 15px;
      color: #e0e0e0;
    }

    #canvas-container {
      width: 100%;
      height: 600px;
      background-color: #1a1a1a;
      border-radius: 4px;
      border: 1px solid #404040;
      cursor: grab;
      position: relative;
    }

    #canvas-container:active {
      cursor: grabbing;
    }

    .controls-hint {
      margin-top: 15px;
      padding: 12px;
      background-color: #353535;
      border-radius: 4px;
      font-size: 0.85rem;
      color: #bbb;
      line-height: 1.6;
    }

    .controls-hint strong {
      color: #6aa6fd;
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 20px;
      border-radius: 4px;
      color: white;
      font-size: 0.9rem;
      z-index: 10000;
      min-width: 300px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: space-between;
      animation: slideIn 0.3s ease-out;
    }

    .notification.success {
      background-color: #4caf50;
      border-left: 4px solid #45a049;
    }

    .notification.info {
      background-color: #2196f3;
      border-left: 4px solid #1976d2;
    }

    .notification.warning {
      background-color: #ff9800;
      border-left: 4px solid #f57c00;
    }

    .notification.error {
      background-color: #f44336;
      border-left: 4px solid #d32f2f;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    .stats-section {
      margin-top: 15px;
      padding: 12px;
      background-color: #353535;
      border-radius: 4px;
    }

    .stats-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 0.85rem;
    }

    .stats-item:last-child {
      margin-bottom: 0;
    }

    .stats-label {
      color: #888;
    }

    .stats-value {
      color: #6aa6fd;
      font-weight: 600;
    }

    /* Nov√© styly pro informace o p≈ô√≠rub√°ch */
    .flange-info-section {
      margin-top: 15px;
      padding: 15px;
      background-color: #353535;
      border-radius: 4px;
    }

    .flange-info-section h3 {
      font-size: 0.95rem;
      font-weight: 600;
      margin-bottom: 12px;
      color: #e0e0e0;
    }

    .flange-info-group {
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid #404040;
    }

    .flange-info-group:last-child {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }

    .flange-info-title {
      font-size: 0.85rem;
      color: #6aa6fd;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .flange-info-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-size: 0.8rem;
    }

    .flange-info-item:last-child {
      margin-bottom: 0;
    }

    .flange-info-label {
      color: #888;
    }

    .flange-info-value {
      color: #e0e0e0;
      font-weight: 600;
    }

    /* Styly pro dva sloupce pod canvasem */
    .controls-columns {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 15px;
    }

    .controls-column {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    @media (max-width: 768px) {
      .controls-columns {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 1024px) {
      .main-content {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üîß Gener√°tor redukc√≠ trubek</h1>
    </div>

    <div class="main-content">
      <div class="controls-section">
        <h2>Parametry redukce</h2>
        
        <div class="form-group">
          <label>D√©lka vstupn√≠ p≈ô√≠ruby (mm)</label>
          <input type="number" id="inputLength" value="50" min="10" max="500" step="1">
        </div>

        <div class="form-group">
          <label>Pr≈Ømƒõr vstupn√≠ p≈ô√≠ruby - OD (mm)</label>
          <input type="number" id="inputDiameter" value="100" min="20" max="1000" step="1">
        </div>

        <div class="form-group">
          <label>D√©lka v√Ωstupn√≠ p≈ô√≠ruby (mm)</label>
          <input type="number" id="outputLength" value="50" min="10" max="500" step="1">
        </div>

        <div class="form-group">
          <label>Pr≈Ømƒõr v√Ωstupn√≠ p≈ô√≠ruby - OD (mm)</label>
          <input type="number" id="outputDiameter" value="50" min="20" max="1000" step="1">
        </div>

        <div class="form-group">
          <label>Tlou≈°≈•ka stƒõny (mm)</label>
          <input type="number" id="wallThickness" value="3" min="1" max="20" step="0.5">
        </div>

        <div class="form-group">
          <label>D√©lka p≈ôechodov√© ƒç√°sti (mm)</label>
          <input type="number" id="transitionLength" value="100" min="10" max="500" step="10">
        </div>

        <div class="form-group">
          <label>Typ redukce</label>
          <div class="radio-group">
            <div class="radio-option">
              <input type="radio" id="reductionShort" name="reductionType" value="short" checked>
              <label for="reductionShort">Kr√°tk√° (vlo≈æen√°)<br><span style="color: red;">experimental</span></label>
            </div>
            <div class="radio-option">
              <input type="radio" id="reductionLong" name="reductionType" value="long">
              <label for="reductionLong">Dlouh√° optim√°ln√≠</label>
            </div>
            <div class="radio-option">
              <input type="radio" id="reductionLongShort" name="reductionType" value="longShort">
              <label for="reductionLongShort">Dlouh√° voliteln√°</label>
            </div>
          </div>
        </div>

        <div class="form-group angle-group" id="angleGroup">
          <label>√öhel stoƒçen√≠ (¬∞)</label>
          <input type="number" id="bendAngle" value="0" min="-90" max="90" step="5">
        </div>

        <div class="form-group">
          <label>Kvalita n√°hledu</label>
          <select id="previewQuality">
            <option value="16">N√≠zk√° (16 segment≈Ø)</option>
            <option value="32" selected>St≈ôedn√≠ (32 segment≈Ø)</option>
            <option value="48">Vysok√° (48 segment≈Ø)</option>
            <option value="64">Ultra (64 segment≈Ø)</option>
          </select>
        </div>

        <div class="form-group">
          <label>Kvalita exportu</label>
          <select id="exportQuality">
            <option value="32">St≈ôedn√≠ (32 segment≈Ø)</option>
            <option value="48">Vysok√° (48 segment≈Ø)</option>
            <option value="64" selected>Ultra (64 segment≈Ø)</option>
            <option value="128">Maximum (128 segment≈Ø)</option>
          </select>
        </div>

        <div class="form-group">
          <label>Barva pozad√≠</label>
          <input type="color" id="bgColorPicker" value="#1a1a1a">
        </div>

        <div class="form-group">
          <label>Barva objektu</label>
          <input type="color" id="objectColorPicker" value="#6aa6fd">
        </div>

        <div class="stats-section">
          <div class="stats-item">
            <span class="stats-label">Vrchol≈Ø:</span>
            <span class="stats-value" id="vertexCount">0</span>
          </div>
          <div class="stats-item">
            <span class="stats-label">Troj√∫heln√≠k≈Ø:</span>
            <span class="stats-value" id="faceCount">0</span>
          </div>
        </div>

        <div class="export-section">
          <h3>Export</h3>
          
          <div class="export-subsection">
            <div class="button-group">
              <button class="btn btn-primary" onclick="exportSTL()">STL</button>
              <button class="btn btn-primary" onclick="exportOBJ()">OBJ</button>
            </div>
          </div>
        </div>
      </div>

      <div class="viewer-section">
        <h2>3D N√°hled</h2>
        <div id="canvas-container"></div>
        <div class="controls-hint">
          <strong>Ovl√°d√°n√≠:</strong> Lev√© tlaƒç√≠tko my≈°i - rotace objektu | Prav√© tlaƒç√≠tko my≈°i - posun kamery | Koleƒçko my≈°i - p≈ôibl√≠≈æen√≠/odd√°len√≠
        </div>
        
        <div class="controls-columns">
          <div class="controls-column">
            <div class="button-group">
              <button class="btn btn-primary" onclick="generateReduction()">Vygenerovat</button>
              <button class="btn btn-secondary" onclick="resetParameters()">Reset</button>
            </div>

            <div class="form-group">
              <label>Typ n√°hledu</label>
              <div class="radio-group">
                <div class="radio-option">
                  <input type="radio" id="viewNormal" name="viewType" value="normal" checked>
                  <label for="viewNormal">Norm√°ln√≠</label>
                </div>
                <div class="radio-option">
                  <input type="radio" id="viewWireframe" name="viewType" value="wireframe">
                  <label for="viewWireframe">Dr√°tov√Ω</label>
                </div>
                <div class="radio-option">
                  <input type="radio" id="viewEdges" name="viewType" value="edges">
                  <label for="viewEdges">S hranami</label>
                </div>
              </div>
            </div>

            <div class="form-group">
              <label>
                Pr≈Øhlednost 
                <span class="slider-value" id="opacityValue">100%</span>
              </label>
              <input type="range" id="opacitySlider" min="0" max="100" value="100" step="1">
            </div>
          </div>

          <div class="controls-column">
            <!-- Nov√° sekce s informacemi o p≈ô√≠rub√°ch -->
            <div class="flange-info-section">
              <h3>üìê Informace o p≈ô√≠rub√°ch</h3>
              
              <div class="flange-info-group">
                <div class="flange-info-title">Vstupn√≠ p≈ô√≠ruba:</div>
                <div class="flange-info-item">
                  <span class="flange-info-label">OD (vnƒõj≈°√≠ pr≈Ømƒõr):</span>
                  <span class="flange-info-value" id="inputOD">100 mm</span>
                </div>
                <div class="flange-info-item">
                  <span class="flange-info-label">ID (vnit≈ôn√≠ pr≈Ømƒõr):</span>
                  <span class="flange-info-value" id="inputID">94 mm</span>
                </div>
                <div class="flange-info-item">
                  <span class="flange-info-label">D√©lka:</span>
                  <span class="flange-info-value" id="inputLengthInfo">50 mm</span>
                </div>
              </div>
              
              <div class="flange-info-group">
                <div class="flange-info-title">V√Ωstupn√≠ p≈ô√≠ruba:</div>
                <div class="flange-info-item">
                  <span class="flange-info-label">OD (vnƒõj≈°√≠ pr≈Ømƒõr):</span>
                  <span class="flange-info-value" id="outputOD">50 mm</span>
                </div>
                <div class="flange-info-item">
                  <span class="flange-info-label">ID (vnit≈ôn√≠ pr≈Ømƒõr):</span>
                  <span class="flange-info-value" id="outputID">44 mm</span>
                </div>
                <div class="flange-info-item">
                  <span class="flange-info-label">D√©lka:</span>
                  <span class="flange-info-value" id="outputLengthInfo">50 mm</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let scene, camera, renderer, reductionMesh, edgesObject, controls;
    let isDragging = false;
    let isPanning = false;
    let previousMousePosition = { x: 0, y: 0 };
    let rotation = { x: 0, y: 0 };
    let cameraPosition = { x: 0, y: 0, z: 500 };
    let currentOpacity = 1.0;

    // Funkce pro aktualizaci informac√≠ o p≈ô√≠rub√°ch
    function updateFlangeInfo() {
      const inputDiameter = parseFloat(document.getElementById('inputDiameter').value);
      const outputDiameter = parseFloat(document.getElementById('outputDiameter').value);
      const wallThickness = parseFloat(document.getElementById('wallThickness').value);
      const inputLength = parseFloat(document.getElementById('inputLength').value);
      const outputLength = parseFloat(document.getElementById('outputLength').value);

      const inputID = inputDiameter - (2 * wallThickness);
      const outputID = outputDiameter - (2 * wallThickness);

      document.getElementById('inputOD').textContent = inputDiameter.toFixed(1) + ' mm';
      document.getElementById('inputID').textContent = inputID.toFixed(1) + ' mm';
      document.getElementById('inputLengthInfo').textContent = inputLength.toFixed(1) + ' mm';
      
      document.getElementById('outputOD').textContent = outputDiameter.toFixed(1) + ' mm';
      document.getElementById('outputID').textContent = outputID.toFixed(1) + ' mm';
      document.getElementById('outputLengthInfo').textContent = outputLength.toFixed(1) + ' mm';
    }

    // Inicializace 3D sc√©ny
    function initScene() {
      const container = document.getElementById('canvas-container');
      
      // Sc√©na
      scene = new THREE.Scene();
      const initialBgColor = document.getElementById('bgColorPicker').value;
      scene.background = new THREE.Color(initialBgColor);

      // Kamera
      camera = new THREE.PerspectiveCamera(
        45,
        container.clientWidth / container.clientHeight,
        1,
        10000
      );
      camera.position.set(0, 0, 500);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      // Svƒõtla
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight1.position.set(1, 1, 1);
      scene.add(directionalLight1);

      const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
      directionalLight2.position.set(-1, -1, -1);
      scene.add(directionalLight2);

      // M≈ô√≠≈æka odebr√°na podle po≈æadavku

      // Event listeners pro ovl√°d√°n√≠ my≈°√≠
      renderer.domElement.addEventListener('mousedown', onMouseDown);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('mouseup', onMouseUp);
      renderer.domElement.addEventListener('wheel', onWheel);
      renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

      // Event listener pro slider pr≈Øhlednosti
      const opacitySlider = document.getElementById('opacitySlider');
      opacitySlider.addEventListener('input', function() {
        const value = this.value;
        document.getElementById('opacityValue').textContent = value + '%';
        currentOpacity = value / 100;
        if (reductionMesh) {
          reductionMesh.material.opacity = currentOpacity;
          reductionMesh.material.transparent = currentOpacity < 1.0;
        }
      });

      // Event listener pro zmƒõnu kvality n√°hledu
      document.getElementById('previewQuality').addEventListener('change', generateReduction);

      // Event listeners pro typ n√°hledu
      document.querySelectorAll('input[name="viewType"]').forEach(radio => {
        radio.addEventListener('change', updateViewType);
      });

      // Event listeners pro zmƒõnu barev
      document.getElementById('bgColorPicker').addEventListener('input', function() {
        scene.background = new THREE.Color(this.value);
      });

      document.getElementById('objectColorPicker').addEventListener('input', function() {
        if (reductionMesh) {
          reductionMesh.material.color.setStyle(this.value);
        }
      });

      // Responsive
      window.addEventListener('resize', onWindowResize);

      // Prvn√≠ render
      animate();

      // Naƒçten√≠ ulo≈æen√Ωch nastaven√≠
      loadSettings();

      // Vygenerov√°n√≠ v√Ωchoz√≠ redukce
      generateReduction();
    }

    // Funkce pro vytvo≈ôen√≠ geometrie redukce
    function createReductionGeometry(params) {
      const {
        inputLength,
        inputDiameter,
        outputLength,
        outputDiameter,
        wallThickness,
        isLong,
        isLongShort,
        bendAngle,
        transitionLength,
        segments = 32  // V√Ωchoz√≠ poƒçet segment≈Ø
      } = params;

      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const indices = [];

      const inputRadius = inputDiameter / 2;
      const outputRadius = outputDiameter / 2;
      const innerInputRadius = inputRadius - wallThickness;
      const innerOutputRadius = outputRadius - wallThickness;

      // Urƒçen√≠ d√©lky p≈ôechodov√© ƒç√°sti pro kr√°tkou redukci
      let effectiveTransitionLength = transitionLength;
      let isNested = false;
      
      if (!isLong && !isLongShort) {
        // Kr√°tk√° redukce - zkontrolovat zda je mo≈æn√© vlo≈æen√≠
        const smallerRadius = Math.min(inputRadius, outputRadius);
        const largerRadius = Math.max(inputRadius, outputRadius);
        const smallerInnerRadius = Math.min(innerInputRadius, innerOutputRadius);
        
        if (smallerRadius <= largerRadius - wallThickness * 2) {
          // P≈ô√≠ruby se mohou vlo≈æit do sebe
          // Prstenec m√° tlou≈°≈•ku wallThickness ve smƒõru -Z
          isNested = true;
          effectiveTransitionLength = wallThickness;
        } else {
          // Norm√°ln√≠ p≈ôechodov√° ƒç√°st
          effectiveTransitionLength = Math.min(transitionLength, 50);
        }
        
        // Zajistit minim√°ln√≠ tlou≈°≈•ku p≈ôechodov√© ƒç√°sti (pro nevlo≈æen√© redukce)
        if (!isNested) {
          effectiveTransitionLength = Math.max(effectiveTransitionLength, wallThickness);
        }
      }

      const bendRadians = (bendAngle * Math.PI) / 180;
      
      // Polomƒõr ohybu podle vƒõt≈°√≠ho pr≈Ømƒõru (1.5√ó pr≈Ømƒõr pro hladk√© proudƒõn√≠)
      const largerDiameter = Math.max(inputDiameter, outputDiameter);
      let bendRadius = largerDiameter * 1.5;
      
      // Pro longShort typ: vypoƒç√≠tat bendRadius tak, aby vnit≈ôn√≠ strana mƒõla d√©lku transitionLength
      if (isLongShort && bendAngle !== 0) {
        // Pr≈Ømƒõrn√Ω polomƒõr pr≈Ø≈ôezu pro v√Ωpoƒçet vnit≈ôn√≠ strany
        const avgRadius = (inputRadius + outputRadius) / 2;
        // Vnit≈ôn√≠ polomƒõr oblouku (od osy ohybu po vnit≈ôn√≠ stranu trubky)
        // innerBendRadius * bendRadians = transitionLength
        const innerBendRadius = transitionLength / bendRadians;
        // St≈ôedn√≠ polomƒõr ohybu je innerBendRadius + avgRadius
        bendRadius = innerBendRadius + avgRadius;
      }

      // Vytvo≈ôen√≠ vrchol≈Ø pro p≈ôechodovou ƒç√°st
      const sections = 20;
      
      // Pro vlo≈æenou kr√°tkou redukci zaƒç√≠n√° prstenec na konci prodlou≈æen√© vstupn√≠ p≈ô√≠ruby
      const transitionStartZ = isNested ? inputLength + wallThickness : inputLength;
      
      for (let i = 0; i <= sections; i++) {
        const t = i / sections;
        
        // Interpolace polomƒõr≈Ø
        const outerRadius = inputRadius + (outputRadius - inputRadius) * t;
        const innerRadius = innerInputRadius + (innerOutputRadius - innerInputRadius) * t;

        // V√Ωpoƒçet pozice a orientace pod√©l k≈ôivky
        let x = 0;
        let y = 0;
        // Pro vlo≈æenou redukci jde prstenec ve smƒõru -Z
        let z = isNested ? (transitionStartZ - t * effectiveTransitionLength) : (transitionStartZ + t * effectiveTransitionLength);
        let rotationAngle = 0;

        if ((isLong || isLongShort) && bendAngle !== 0) {
          // Ohyb - vstupn√≠ p≈ô√≠ruba je pevn√°, v√Ωstupn√≠ se ot√°ƒç√≠
          // St≈ôed ohybu je posunut o bendRadius ve smƒõru Y od zaƒç√°tku p≈ôechodov√© ƒç√°sti
          const currentAngle = t * bendRadians;
          
          // Pozice na oblouku (st≈ôed oblouku je na [0, bendRadius, inputLength])
          y = bendRadius * (1 - Math.cos(currentAngle));
          z = inputLength + bendRadius * Math.sin(currentAngle);
          
          // √öhel rotace pr≈Ø≈ôezu (postupn√° rotace od 0 do bendAngle)
          rotationAngle = currentAngle;
        }

        // Vytvo≈ôen√≠ rotaƒçn√≠ matice pro pr≈Ø≈ôez
        const cosRot = Math.cos(rotationAngle);
        const sinRot = Math.sin(rotationAngle);

        // Vnƒõj≈°√≠ kruh s rotac√≠
        for (let j = 0; j <= segments; j++) {
          const theta = (j / segments) * Math.PI * 2;
          const localX = Math.cos(theta) * outerRadius;
          const localY = Math.sin(theta) * outerRadius;
          
          // Rotace pr≈Ø≈ôezu kolem osy X (ohyb v rovinƒõ YZ)
          const vx = x + localX;
          const vy = y + localY * cosRot;
          const vz = z - localY * sinRot;
          
          vertices.push(vx, vy, vz);
        }

        // Vnit≈ôn√≠ kruh s rotac√≠
        for (let j = 0; j <= segments; j++) {
          const theta = (j / segments) * Math.PI * 2;
          const localX = Math.cos(theta) * innerRadius;
          const localY = Math.sin(theta) * innerRadius;
          
          // Rotace pr≈Ø≈ôezu kolem osy X
          const vx = x + localX;
          const vy = y + localY * cosRot;
          const vz = z - localY * sinRot;
          
          vertices.push(vx, vy, vz);
        }
      }

      // P≈ôedn√≠ p≈ô√≠ruba (vstupn√≠)
      // Pro vlo≈æenou kr√°tkou redukci je prodlou≈æen√° o wallThickness
      const inputFlangeEnd = isNested ? inputLength + wallThickness : inputLength;
      
      for (let j = 0; j <= segments; j++) {
        const theta = (j / segments) * Math.PI * 2;
        vertices.push(Math.cos(theta) * inputRadius, Math.sin(theta) * inputRadius, 0);
      }
      for (let j = 0; j <= segments; j++) {
        const theta = (j / segments) * Math.PI * 2;
        vertices.push(Math.cos(theta) * inputRadius, Math.sin(theta) * inputRadius, inputFlangeEnd);
      }
      for (let j = 0; j <= segments; j++) {
        const theta = (j / segments) * Math.PI * 2;
        vertices.push(Math.cos(theta) * innerInputRadius, Math.sin(theta) * innerInputRadius, inputFlangeEnd);
      }
      for (let j = 0; j <= segments; j++) {
        const theta = (j / segments) * Math.PI * 2;
        vertices.push(Math.cos(theta) * innerInputRadius, Math.sin(theta) * innerInputRadius, 0);
      }

      // Zadn√≠ p≈ô√≠ruba (v√Ωstupn√≠) - otoƒçen√° o bendAngle
      let xEnd = 0;
      let yEnd = 0;
      // Pro vlo≈æenou redukci zaƒç√≠n√° v√Ωstupn√≠ p≈ô√≠ruba na stejn√© pozici jako zaƒç√°tek prstence
      let zEnd = isNested ? transitionStartZ : (transitionStartZ + effectiveTransitionLength);
      let endRotation = 0;
      
      if ((isLong || isLongShort) && bendAngle !== 0) {
        const largerDiameter = Math.max(inputDiameter, outputDiameter);
        let bendRadius = largerDiameter * 1.5;
        
        // Pro longShort: p≈ôepoƒç√≠tat bendRadius
        if (isLongShort) {
          const avgRadius = (inputRadius + outputRadius) / 2;
          const innerBendRadius = transitionLength / bendRadians;
          bendRadius = innerBendRadius + avgRadius;
        }
        
        // Koncov√° pozice po ohybu
        yEnd = bendRadius * (1 - Math.cos(bendRadians));
        zEnd = inputLength + bendRadius * Math.sin(bendRadians);
        endRotation = bendRadians;
      }

      // Smƒõrov√Ω vektor v√Ωstupn√≠ p≈ô√≠ruby po rotaci
      let dirY = Math.sin(endRotation);
      let dirZ = Math.cos(endRotation);
      
      // Pro kr√°tkou redukci m√° v√Ωstupn√≠ p≈ô√≠ruba smƒõ≈ôovat zpƒõt
      if (!isLong && !isLongShort) {
        dirY = 0;
        dirZ = -1;
      }

      // Vytvo≈ôen√≠ rotaƒçn√≠ matice pro v√Ωstupn√≠ p≈ô√≠rubu
      const cosEnd = Math.cos(endRotation);
      const sinEnd = Math.sin(endRotation);
      
      // Pro vlo≈æenou kr√°tkou redukci je v√Ωstupn√≠ p≈ô√≠ruba tak√© prodlou≈æen√° o wallThickness
      const outputFlangeLength = isNested ? outputLength + wallThickness : outputLength;

      // Prvn√≠ kruh v√Ωstupn√≠ p≈ô√≠ruby (napojen√≠ na p≈ôechodovou ƒç√°st)
      for (let j = 0; j <= segments; j++) {
        const theta = (j / segments) * Math.PI * 2;
        const localX = Math.cos(theta) * outputRadius;
        const localY = Math.sin(theta) * outputRadius;
        
        vertices.push(
          xEnd + localX,
          yEnd + localY * cosEnd,
          zEnd - localY * sinEnd
        );
      }
      
      // Druh√Ω kruh v√Ωstupn√≠ p≈ô√≠ruby (konec p≈ô√≠ruby - posunut√Ω ve smƒõru norm√°ly)
      for (let j = 0; j <= segments; j++) {
        const theta = (j / segments) * Math.PI * 2;
        const localX = Math.cos(theta) * outputRadius;
        const localY = Math.sin(theta) * outputRadius;
        
        vertices.push(
          xEnd + localX,
          yEnd + localY * cosEnd + outputFlangeLength * dirY,
          zEnd - localY * sinEnd + outputFlangeLength * dirZ
        );
      }
      
      // Vnit≈ôn√≠ kruh v√Ωstupn√≠ p≈ô√≠ruby (konec)
      for (let j = 0; j <= segments; j++) {
        const theta = (j / segments) * Math.PI * 2;
        const localX = Math.cos(theta) * innerOutputRadius;
        const localY = Math.sin(theta) * innerOutputRadius;
        
        vertices.push(
          xEnd + localX,
          yEnd + localY * cosEnd + outputFlangeLength * dirY,
          zEnd - localY * sinEnd + outputFlangeLength * dirZ
        );
      }
      
      // Vnit≈ôn√≠ kruh v√Ωstupn√≠ p≈ô√≠ruby (zaƒç√°tek)
      for (let j = 0; j <= segments; j++) {
        const theta = (j / segments) * Math.PI * 2;
        const localX = Math.cos(theta) * innerOutputRadius;
        const localY = Math.sin(theta) * innerOutputRadius;
        
        vertices.push(
          xEnd + localX,
          yEnd + localY * cosEnd,
          zEnd - localY * sinEnd
        );
      }

      // Vytvo≈ôen√≠ index≈Ø pro vnƒõj≈°√≠ stƒõnu
      for (let i = 0; i < sections; i++) {
        for (let j = 0; j < segments; j++) {
          const a = i * (segments + 1) * 2 + j;
          const b = a + 1;
          const c = a + (segments + 1) * 2;
          const d = c + 1;

          indices.push(a, b, d);
          indices.push(a, d, c);
        }
      }

      // Vytvo≈ôen√≠ index≈Ø pro vnit≈ôn√≠ stƒõnu
      for (let i = 0; i < sections; i++) {
        for (let j = 0; j < segments; j++) {
          const offset = segments + 1;
          const a = i * (segments + 1) * 2 + offset + j;
          const b = a + 1;
          const c = a + (segments + 1) * 2;
          const d = c + 1;

          indices.push(a, d, b);
          indices.push(a, c, d);
        }
      }

      // Indexy pro p≈ôedn√≠ p≈ô√≠rubu
      const frontOffset = (sections + 1) * (segments + 1) * 2;
      // Vnƒõj≈°√≠ p≈ôedn√≠ stƒõna
      for (let j = 0; j < segments; j++) {
        indices.push(frontOffset + j, frontOffset + j + 1, frontOffset + segments + 1 + j + 1);
        indices.push(frontOffset + j, frontOffset + segments + 1 + j + 1, frontOffset + segments + 1 + j);
      }
      // Vnit≈ôn√≠ p≈ôedn√≠ stƒõna
      for (let j = 0; j < segments; j++) {
        const innerOffset = frontOffset + (segments + 1) * 2;
        indices.push(innerOffset + j, innerOffset + segments + 1 + j + 1, innerOffset + j + 1);
        indices.push(innerOffset + j, innerOffset + segments + 1 + j, innerOffset + segments + 1 + j + 1);
      }
      // ƒåeln√≠ kruh
      for (let j = 0; j < segments; j++) {
        indices.push(frontOffset + j, frontOffset + j + 1, frontOffset + (segments + 1) * 3 + j + 1);
        indices.push(frontOffset + j, frontOffset + (segments + 1) * 3 + j + 1, frontOffset + (segments + 1) * 3 + j);
      }
      // Zadn√≠ kruh vstupn√≠ p≈ô√≠ruby
      for (let j = 0; j < segments; j++) {
        const offset1 = frontOffset + segments + 1;
        const offset2 = frontOffset + (segments + 1) * 2;
        indices.push(offset1 + j, offset2 + j + 1, offset1 + j + 1);
        indices.push(offset1 + j, offset2 + j, offset2 + j + 1);
      }

      // Indexy pro zadn√≠ p≈ô√≠rubu
      const backOffset = frontOffset + (segments + 1) * 4;
      // Vnƒõj≈°√≠ zadn√≠ stƒõna
      for (let j = 0; j < segments; j++) {
        indices.push(backOffset + j, backOffset + j + 1, backOffset + segments + 1 + j + 1);
        indices.push(backOffset + j, backOffset + segments + 1 + j + 1, backOffset + segments + 1 + j);
      }
      // Vnit≈ôn√≠ zadn√≠ stƒõna
      for (let j = 0; j < segments; j++) {
        const innerOffset = backOffset + (segments + 1) * 2;
        indices.push(innerOffset + j, innerOffset + segments + 1 + j + 1, innerOffset + j + 1);
        indices.push(innerOffset + j, innerOffset + segments + 1 + j, innerOffset + segments + 1 + j + 1);
      }
      // ƒåeln√≠ kruh v√Ωstupn√≠ p≈ô√≠ruby
      for (let j = 0; j < segments; j++) {
        indices.push(backOffset + j, backOffset + (segments + 1) * 3 + j + 1, backOffset + j + 1);
        indices.push(backOffset + j, backOffset + (segments + 1) * 3 + j, backOffset + (segments + 1) * 3 + j + 1);
      }
      // Zadn√≠ kruh v√Ωstupn√≠ p≈ô√≠ruby
      for (let j = 0; j < segments; j++) {
        const offset1 = backOffset + segments + 1;
        const offset2 = backOffset + (segments + 1) * 2;
        indices.push(offset1 + j, offset1 + j + 1, offset2 + j + 1);
        indices.push(offset1 + j, offset2 + j + 1, offset2 + j);
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();

      return geometry;
    }

    // Funkce pro aktualizaci typu n√°hledu
    function updateViewType() {
      if (!reductionMesh) return;

      const viewType = document.querySelector('input[name="viewType"]:checked').value;

      // Odstranƒõn√≠ st√°vaj√≠c√≠ch edges
      if (edgesObject) {
        scene.remove(edgesObject);
        edgesObject.geometry.dispose();
        edgesObject.material.dispose();
        edgesObject = null;
      }

      // Nastaven√≠ podle typu zobrazen√≠
      switch(viewType) {
        case 'normal':
          // Norm√°ln√≠ zobrazen√≠ - vypnout wireframe
          reductionMesh.material.wireframe = false;
          reductionMesh.visible = true;
          break;

        case 'wireframe':
          // Dr√°tov√Ω model
          reductionMesh.material.wireframe = true;
          reductionMesh.visible = true;
          break;

        case 'edges':
          // Zobrazen√≠ s hranami
          reductionMesh.material.wireframe = false;
          reductionMesh.visible = true;
          
          // Vytvo≈ôen√≠ edges geometrie
          const edgesGeometry = new THREE.EdgesGeometry(reductionMesh.geometry, 15);
          const edgesMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
          edgesObject = new THREE.LineSegments(edgesGeometry, edgesMaterial);
          
          // Synchronizace v≈°ech rotac√≠ s hlavn√≠m meshem
          edgesObject.rotation.x = reductionMesh.rotation.x;
          edgesObject.rotation.y = reductionMesh.rotation.y;
          edgesObject.rotation.z = reductionMesh.rotation.z;
          edgesObject.position.copy(reductionMesh.position);
          
          scene.add(edgesObject);
          break;
      }
    }

    // Generov√°n√≠ redukce
    function generateReduction() {
      const reductionType = document.querySelector('input[name="reductionType"]:checked').value;
      const previewQuality = parseInt(document.getElementById('previewQuality').value);
      
      const params = {
        inputLength: parseFloat(document.getElementById('inputLength').value),
        inputDiameter: parseFloat(document.getElementById('inputDiameter').value),
        outputLength: parseFloat(document.getElementById('outputLength').value),
        outputDiameter: parseFloat(document.getElementById('outputDiameter').value),
        wallThickness: parseFloat(document.getElementById('wallThickness').value),
        transitionLength: parseFloat(document.getElementById('transitionLength').value),
        isLong: reductionType === 'long',
        isLongShort: reductionType === 'longShort',
        bendAngle: parseFloat(document.getElementById('bendAngle').value),
        segments: previewQuality
      };

      // Validace
      if (params.inputDiameter <= params.wallThickness * 2) {
        showNotification('Vstupn√≠ pr≈Ømƒõr mus√≠ b√Ωt vƒõt≈°√≠ ne≈æ dvojn√°sobek tlou≈°≈•ky stƒõny', 'error');
        return;
      }
      if (params.outputDiameter <= params.wallThickness * 2) {
        showNotification('V√Ωstupn√≠ pr≈Ømƒõr mus√≠ b√Ωt vƒõt≈°√≠ ne≈æ dvojn√°sobek tlou≈°≈•ky stƒõny', 'error');
        return;
      }

      // Odstranƒõn√≠ star√© geometrie
      if (reductionMesh) {
        scene.remove(reductionMesh);
        reductionMesh.geometry.dispose();
        reductionMesh.material.dispose();
      }
      
      // Odstranƒõn√≠ star√Ωch edges
      if (edgesObject) {
        scene.remove(edgesObject);
        edgesObject.geometry.dispose();
        edgesObject.material.dispose();
        edgesObject = null;
      }

      // Vytvo≈ôen√≠ nov√© geometrie
      const geometry = createReductionGeometry(params);
      const objectColor = document.getElementById('objectColorPicker').value;
      const material = new THREE.MeshPhongMaterial({
        color: objectColor,
        shininess: 80,
        side: THREE.DoubleSide,
        transparent: currentOpacity < 1.0,
        opacity: currentOpacity,
        wireframe: false
      });

      reductionMesh = new THREE.Mesh(geometry, material);
      
      // Vycentrov√°n√≠ objektu - geometrie je p≈ôesunuta tak, aby st≈ôed byl v [0,0,0]
      geometry.computeBoundingBox();
      const box = geometry.boundingBox;
      const center = new THREE.Vector3();
      box.getCenter(center);
      
      // Posun v≈°ech vrchol≈Ø geometrie
      const positions = geometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        positions.setXYZ(
          i,
          positions.getX(i) - center.x,
          positions.getY(i) - center.y,
          positions.getZ(i) - center.z
        );
      }
      positions.needsUpdate = true;
      geometry.computeVertexNormals();
      geometry.computeBoundingBox();
      
      scene.add(reductionMesh);

      // Zachov√°n√≠ natoƒçen√≠ kamery - pokud u≈æ byl nƒõjak√Ω objekt, zachovaj√≠ se rotation hodnoty
      // Jinak se nastav√≠ z√°kladn√≠ rotace o 90¬∞ v ose Z
      if (rotation.x === 0 && rotation.y === 0) {
        // Prvn√≠ naƒçten√≠ - nastavit z√°kladn√≠ rotaci
        reductionMesh.rotation.z = Math.PI / 2; // 90 stup≈à≈Ø v radi√°nech
      } else {
        // Zachovat souƒçasn√© natoƒçen√≠
        reductionMesh.rotation.x = rotation.x;
        reductionMesh.rotation.y = rotation.y;
        reductionMesh.rotation.z = Math.PI / 2; // Zachovat z√°kladn√≠ Z rotaci
      }

      // Aktualizace statistik
      const vertexCount = positions.count;
      const faceCount = geometry.index ? geometry.index.count / 3 : vertexCount / 3;
      
      document.getElementById('vertexCount').textContent = vertexCount.toLocaleString('cs-CZ');
      document.getElementById('faceCount').textContent = Math.floor(faceCount).toLocaleString('cs-CZ');

      // Aktualizace informac√≠ o p≈ô√≠rub√°ch
      updateFlangeInfo();

      // Aktualizace typu n√°hledu podle vybran√©ho m√≥du
      updateViewType();

      // Ulo≈æen√≠ nastaven√≠
      saveSettings();

      showNotification('Redukce vygenerov√°na', 'success');
    }

    // Ovl√°d√°n√≠ my≈°√≠ - rotace
    function onMouseDown(event) {
      if (event.button === 0) { // Lev√© tlaƒç√≠tko
        isDragging = true;
      } else if (event.button === 2) { // Prav√© tlaƒç√≠tko
        isPanning = true;
      }
      previousMousePosition = {
        x: event.clientX,
        y: event.clientY
      };
    }

    function onMouseMove(event) {
      if (isDragging) {
        const deltaX = event.clientX - previousMousePosition.x;
        const deltaY = event.clientY - previousMousePosition.y;

        rotation.y += deltaX * 0.01;
        rotation.x += deltaY * 0.01;

        if (reductionMesh) {
          reductionMesh.rotation.x = rotation.x;
          reductionMesh.rotation.y = rotation.y;
          
          // Synchronizace rotace edges objektu
          if (edgesObject) {
            edgesObject.rotation.x = rotation.x;
            edgesObject.rotation.y = rotation.y;
          }
        }
      }

      if (isPanning) {
        const deltaX = event.clientX - previousMousePosition.x;
        const deltaY = event.clientY - previousMousePosition.y;

        cameraPosition.x -= deltaX * 0.5;
        cameraPosition.y += deltaY * 0.5;

        camera.position.x = cameraPosition.x;
        camera.position.y = cameraPosition.y;
      }

      previousMousePosition = {
        x: event.clientX,
        y: event.clientY
      };
    }

    function onMouseUp() {
      isDragging = false;
      isPanning = false;
    }

    // Zoom koleƒçkem my≈°i
    function onWheel(event) {
      event.preventDefault();
      const delta = event.deltaY * 0.5;
      cameraPosition.z += delta;
      cameraPosition.z = Math.max(100, Math.min(2000, cameraPosition.z));
      camera.position.z = cameraPosition.z;
    }

    // Responsive
    function onWindowResize() {
      const container = document.getElementById('canvas-container');
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }

    // Animaƒçn√≠ smyƒçka
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    // Export do STL
    function exportSTL() {
      if (!reductionMesh) {
        showNotification('Nejprve vygenerujte redukci', 'warning');
        return;
      }

      showNotification('Generuji STL soubor...', 'info');
      
      const exportQuality = parseInt(document.getElementById('exportQuality').value);
      const reductionType = document.querySelector('input[name="reductionType"]:checked').value;
      const params = {
        inputLength: parseFloat(document.getElementById('inputLength').value),
        inputDiameter: parseFloat(document.getElementById('inputDiameter').value),
        outputLength: parseFloat(document.getElementById('outputLength').value),
        outputDiameter: parseFloat(document.getElementById('outputDiameter').value),
        wallThickness: parseFloat(document.getElementById('wallThickness').value),
        transitionLength: parseFloat(document.getElementById('transitionLength').value),
        isLong: reductionType === 'long',
        isLongShort: reductionType === 'longShort',
        bendAngle: parseFloat(document.getElementById('bendAngle').value),
        segments: exportQuality
      };

      // Vytvo≈ôen√≠ exportn√≠ geometrie
      const exportGeometry = createReductionGeometry(params);
      
      // Vycentrov√°n√≠
      exportGeometry.computeBoundingBox();
      const box = exportGeometry.boundingBox;
      const center = new THREE.Vector3();
      box.getCenter(center);
      
      const positions = exportGeometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        positions.setXYZ(
          i,
          positions.getX(i) - center.x,
          positions.getY(i) - center.y,
          positions.getZ(i) - center.z
        );
      }
      positions.needsUpdate = true;
      exportGeometry.computeVertexNormals();

      const vertices = exportGeometry.attributes.position.array;
      const indices = exportGeometry.index.array;

      let stl = 'solid reduction\n';

      for (let i = 0; i < indices.length; i += 3) {
        const i1 = indices[i] * 3;
        const i2 = indices[i + 1] * 3;
        const i3 = indices[i + 2] * 3;

        const v1 = new THREE.Vector3(vertices[i1], vertices[i1 + 1], vertices[i1 + 2]);
        const v2 = new THREE.Vector3(vertices[i2], vertices[i2 + 1], vertices[i2 + 2]);
        const v3 = new THREE.Vector3(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);

        const normal = new THREE.Vector3()
          .crossVectors(
            new THREE.Vector3().subVectors(v2, v1),
            new THREE.Vector3().subVectors(v3, v1)
          )
          .normalize();

        stl += `  facet normal ${normal.x} ${normal.y} ${normal.z}\n`;
        stl += '    outer loop\n';
        stl += `      vertex ${v1.x} ${v1.y} ${v1.z}\n`;
        stl += `      vertex ${v2.x} ${v2.y} ${v2.z}\n`;
        stl += `      vertex ${v3.x} ${v3.y} ${v3.z}\n`;
        stl += '    endloop\n';
        stl += '  endfacet\n';
      }

      stl += 'endsolid reduction\n';

      // Vyƒçi≈°tƒõn√≠ exportn√≠ geometrie
      exportGeometry.dispose();

      downloadFile(stl, 'redukce.stl', 'text/plain');
      showNotification('STL soubor exportov√°n', 'success');
    }

    // Export do OBJ
    function exportOBJ() {
      if (!reductionMesh) {
        showNotification('Nejprve vygenerujte redukci', 'warning');
        return;
      }

      showNotification('Generuji OBJ soubor...', 'info');
      
      const exportQuality = parseInt(document.getElementById('exportQuality').value);
      const reductionType = document.querySelector('input[name="reductionType"]:checked').value;
      const params = {
        inputLength: parseFloat(document.getElementById('inputLength').value),
        inputDiameter: parseFloat(document.getElementById('inputDiameter').value),
        outputLength: parseFloat(document.getElementById('outputLength').value),
        outputDiameter: parseFloat(document.getElementById('outputDiameter').value),
        wallThickness: parseFloat(document.getElementById('wallThickness').value),
        transitionLength: parseFloat(document.getElementById('transitionLength').value),
        isLong: reductionType === 'long',
        isLongShort: reductionType === 'longShort',
        bendAngle: parseFloat(document.getElementById('bendAngle').value),
        segments: exportQuality
      };

      // Vytvo≈ôen√≠ exportn√≠ geometrie
      const exportGeometry = createReductionGeometry(params);
      
      // Vycentrov√°n√≠
      exportGeometry.computeBoundingBox();
      const box = exportGeometry.boundingBox;
      const center = new THREE.Vector3();
      box.getCenter(center);
      
      const positions = exportGeometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        positions.setXYZ(
          i,
          positions.getX(i) - center.x,
          positions.getY(i) - center.y,
          positions.getZ(i) - center.z
        );
      }
      positions.needsUpdate = true;
      exportGeometry.computeVertexNormals();

      const vertices = exportGeometry.attributes.position.array;
      const indices = exportGeometry.index.array;

      let obj = '# Redukce trubky\n';
      obj += 'o reduction\n';

      // Vertices
      for (let i = 0; i < vertices.length; i += 3) {
        obj += `v ${vertices[i]} ${vertices[i + 1]} ${vertices[i + 2]}\n`;
      }

      // Faces
      for (let i = 0; i < indices.length; i += 3) {
        obj += `f ${indices[i] + 1} ${indices[i + 1] + 1} ${indices[i + 2] + 1}\n`;
      }

      // Vyƒçi≈°tƒõn√≠ exportn√≠ geometrie
      exportGeometry.dispose();

      downloadFile(obj, 'redukce.obj', 'text/plain');
      showNotification('OBJ soubor exportov√°n', 'success');
    }

    // Sta≈æen√≠ souboru
    function downloadFile(content, filename, contentType) {
      const blob = new Blob([content], { type: contentType });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    // Reset parametr≈Ø
    function resetParameters() {
      document.getElementById('inputLength').value = 50;
      document.getElementById('inputDiameter').value = 100;
      document.getElementById('outputLength').value = 50;
      document.getElementById('outputDiameter').value = 50;
      document.getElementById('wallThickness').value = 3;
      document.getElementById('transitionLength').value = 100;
      document.getElementById('reductionShort').checked = true;
      document.getElementById('bendAngle').value = 0;
      document.getElementById('angleGroup').classList.remove('active');
      document.getElementById('opacitySlider').value = 100;
      document.getElementById('opacityValue').textContent = '100%';
      document.getElementById('viewNormal').checked = true;
      document.getElementById('bgColorPicker').value = '#1a1a1a';
      document.getElementById('objectColorPicker').value = '#6aa6fd';
      document.getElementById('previewQuality').value = '32';
      document.getElementById('exportQuality').value = '64';
      currentOpacity = 1.0;
      
      // Aplikace v√Ωchoz√≠ch barev
      scene.background = new THREE.Color('#1a1a1a');
      
      // Reset rotace p≈ôi resetu
      rotation.x = 0;
      rotation.y = 0;
      
      generateReduction();
      showNotification('Parametry resetov√°ny', 'info');
    }

    // Ulo≈æen√≠ nastaven√≠ do localStorage
    function saveSettings() {
      const settings = {
        inputLength: document.getElementById('inputLength').value,
        inputDiameter: document.getElementById('inputDiameter').value,
        outputLength: document.getElementById('outputLength').value,
        outputDiameter: document.getElementById('outputDiameter').value,
        wallThickness: document.getElementById('wallThickness').value,
        transitionLength: document.getElementById('transitionLength').value,
        reductionType: document.querySelector('input[name="reductionType"]:checked').value,
        bendAngle: document.getElementById('bendAngle').value,
        opacity: document.getElementById('opacitySlider').value,
        viewType: document.querySelector('input[name="viewType"]:checked').value,
        bgColor: document.getElementById('bgColorPicker').value,
        objectColor: document.getElementById('objectColorPicker').value,
        previewQuality: document.getElementById('previewQuality').value,
        exportQuality: document.getElementById('exportQuality').value
      };

      localStorage.setItem('reductionSettings', JSON.stringify(settings));
    }

    // Naƒçten√≠ nastaven√≠ z localStorage
    function loadSettings() {
      const saved = localStorage.getItem('reductionSettings');
      if (saved) {
        try {
          const settings = JSON.parse(saved);
          document.getElementById('inputLength').value = settings.inputLength || 50;
          document.getElementById('inputDiameter').value = settings.inputDiameter || 100;
          document.getElementById('outputLength').value = settings.outputLength || 50;
          document.getElementById('outputDiameter').value = settings.outputDiameter || 50;
          document.getElementById('wallThickness').value = settings.wallThickness || 3;
          document.getElementById('transitionLength').value = settings.transitionLength || 100;
          document.getElementById('bendAngle').value = settings.bendAngle || 0;
          
          // Naƒçten√≠ pr≈Øhlednosti
          if (settings.opacity !== undefined) {
            document.getElementById('opacitySlider').value = settings.opacity;
            document.getElementById('opacityValue').textContent = settings.opacity + '%';
            currentOpacity = settings.opacity / 100;
          }
          
          // Naƒçten√≠ kvality
          if (settings.previewQuality) {
            document.getElementById('previewQuality').value = settings.previewQuality;
          }
          if (settings.exportQuality) {
            document.getElementById('exportQuality').value = settings.exportQuality;
          }
          
          // Naƒçten√≠ typu n√°hledu
          if (settings.viewType) {
            const viewRadio = document.getElementById('view' + settings.viewType.charAt(0).toUpperCase() + settings.viewType.slice(1));
            if (viewRadio) {
              viewRadio.checked = true;
            }
          }
          
          // Naƒçten√≠ barev
          if (settings.bgColor) {
            document.getElementById('bgColorPicker').value = settings.bgColor;
            scene.background = new THREE.Color(settings.bgColor);
          }
          
          if (settings.objectColor) {
            document.getElementById('objectColorPicker').value = settings.objectColor;
          }
          
          if (settings.reductionType === 'long') {
            document.getElementById('reductionLong').checked = true;
            document.getElementById('angleGroup').classList.add('active');
          } else if (settings.reductionType === 'longShort') {
            document.getElementById('reductionLongShort').checked = true;
            document.getElementById('angleGroup').classList.add('active');
          } else {
            document.getElementById('reductionShort').checked = true;
          }
        } catch (e) {
          console.error('Chyba p≈ôi naƒç√≠t√°n√≠ nastaven√≠:', e);
        }
      }
    }

    // Toast notifikace
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      document.body.appendChild(notification);

      setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-out';
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    }

    // Event listeners
    document.querySelectorAll('input[name="reductionType"]').forEach(radio => {
      radio.addEventListener('change', function() {
        const angleGroup = document.getElementById('angleGroup');
        if (this.value === 'long' || this.value === 'longShort') {
          angleGroup.classList.add('active');
        } else {
          angleGroup.classList.remove('active');
          document.getElementById('bendAngle').value = 0;
        }
      });
    });

    // Auto-generov√°n√≠ p≈ôi zmƒõnƒõ hodnot
    document.querySelectorAll('input[type="number"]').forEach(input => {
      input.addEventListener('change', generateReduction);
    });

    // Inicializace p≈ôi naƒçten√≠ str√°nky
    window.addEventListener('DOMContentLoaded', initScene);
  </script>
</body>
</html>
