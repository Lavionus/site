<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>P≈ôedpovƒõƒè Poƒças√≠ - 3 dny</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: #1a1a1a;
      color: #e0e0e0;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 40px;
    }

    .header h1 {
      font-size: 1.4rem;
      font-weight: 600;
      margin: 0;
      margin-bottom: 10px;
      color: #e0e0e0;
    }

    .controls-section {
      background-color: #2a2a2a;
      border: 1px solid #404040;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .search-form {
      display: flex;
      align-items: end;
      gap: 20px;
      flex-wrap: wrap;
    }

    .search-group {
      position: relative;
      flex: 1;
      min-width: 200px;
    }

    .search-group h3 {
      font-size: 0.9rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
      font-weight: 600;
    }

    .search-input {
      width: 100%;
      padding: 8px 12px;
      background-color: #404040;
      border: 1px solid #555;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 0.9rem;
      transition: all 0.3s ease;
    }

    .search-input::placeholder {
      color: #999;
    }

    .search-input:focus {
      outline: none;
      border-color: #6aa6fd;
    }

    .suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background-color: #404040;
      border: 1px solid #555;
      border-top: none;
      border-radius: 0 0 4px 4px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
    }

    .suggestions.show {
      display: block;
    }

    .suggestion-item {
      padding: 10px 12px;
      cursor: pointer;
      color: #e0e0e0;
      font-size: 0.9rem;
      border-bottom: 1px solid #555;
      transition: background-color 0.2s ease;
    }

    .suggestion-item:hover,
    .suggestion-item.selected {
      background-color: #6aa6fd;
    }

    .suggestion-item:last-child {
      border-bottom: none;
    }

    .suggestion-name {
      font-weight: 500;
    }

    .suggestion-details {
      font-size: 0.8rem;
      color: #bbb;
      margin-top: 2px;
    }

    .load-btn {
      background-color: #6aa6fd;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background-color 0.2s ease;
      flex-shrink: 0;
      height: fit-content;
    }

    .load-btn:hover {
      background-color: #5694f0;
    }

    .charts-section {
      display: grid;
      gap: 30px;
      margin-bottom: 30px;
    }

    .chart-container {
      background-color: #2a2a2a;
      border: 1px solid #404040;
      border-radius: 8px;
      padding: 20px;
      box-shadow: none;
    }

    .chart-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 15px;
      color: #e0e0e0;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .chart-wrapper {
      position: relative;
      height: 400px;
      margin-bottom: 20px;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #888;
    }

    .loading .spinner {
      font-size: 3rem;
      animation: spin 2s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .error {
      background-color: #4a2c2c;
      border: 1px solid #8b4444;
      color: #ff8888;
      padding: 15px;
      border-radius: 4px;
      margin: 20px 0;
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 20px;
      border-radius: 4px;
      color: white;
      font-size: 0.9rem;
      z-index: 10000;
      min-width: 300px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: space-between;
      animation: slideIn 0.3s ease-out;
    }

    .notification.success {
      background-color: #4caf50;
      border-left: 4px solid #45a049;
    }

    .notification.info {
      background-color: #2196f3;
      border-left: 4px solid #1976d2;
    }

    .notification.warning {
      background-color: #ff9800;
      border-left: 4px solid #f57c00;
    }

    .notification.error {
      background-color: #f44336;
      border-left: 4px solid #d32f2f;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .saved-location-info {
      background-color: #2d4a2d;
      border: 1px solid #4caf50;
      color: #81c784;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
      height: fit-content;
    }

    @media (max-width: 1200px) {
      .search-form {
        flex-direction: column;
        align-items: stretch;
      }
      .search-group {
        min-width: auto;
      }
    }

    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }
      .header h1 {
        font-size: 1.2rem;
      }
      .chart-wrapper {
        height: 300px;
      }
      .saved-location-info {
        display: none;
      }
    }

    .charts-section {
      display: grid;
      gap: 30px;
      margin-bottom: 30px;
      grid-template-columns: 1fr;
    }

    @media (min-width: 1200px) {
      .weather-icons {
        padding-right: 60px; /* Vƒõt≈°√≠ kompenzace pro ≈°ir≈°√≠ obrazovky */
        right: -20px;
      }
    }

    /* Posun legendy dol≈Ø */
    .chartjs-legend {
      margin-top: 20px !important;
      text-align: center !important;
    }

    .chartjs-legend ul {
      display: flex !important;
      flex-wrap: wrap !important;
      justify-content: center !important;
      gap: 15px !important;
      padding: 0 !important;
      margin: 0 !important;
    }

    .chartjs-legend li {
      display: flex !important;
      align-items: center !important;
      gap: 5px !important;
    }

    .chartjs-legend li span {
      display: inline-block !important;
      width: 12px !important;
      height: 12px !important;
      margin-right: 5px !important;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üå§Ô∏è P≈ôedpovƒõƒè Poƒças√≠</h1>
    </div>
    
    <div class="controls-section">
      <div class="search-form">
        <div class="search-group">
          <h3>üìç Lokace</h3>
          <input
            id="location"
            class="search-input"
            type="text"
            placeholder="Zaƒçnƒõte ps√°t n√°zev mƒõsta..."
            autocomplete="off"
          />
          <div class="suggestions" id="suggestions"></div>
        </div>
        <div id="savedLocationInfo" class="saved-location-info" style="display: none;">
          <span>üíæ</span>
          <span id="savedLocationText">Pou≈æ√≠v√°m ulo≈æenou lokaci</span>
        </div>
        <button class="load-btn" id="loadWeather">
          üîç Naƒç√≠st p≈ôedpovƒõƒè poƒças√≠
        </button>
        <button class="load-btn" id="saveLocationBtn" style="display: none;">
          üíæ Ulo≈æit lokaci
        </button>
      </div>
    </div>
    
    <div id="loading" class="loading" style="display: none;">
      <div class="spinner">‚è≥</div>
      <p>Naƒç√≠t√°m meteorologick√° data...</p>
    </div>
    
    <div id="error" class="error" style="display: none;"></div>
    
    <div class="charts-section" id="chartsSection" style="display: none;">
      <div class="chart-container">
        <div class="chart-title">‚è≥ 24hodinov√° p≈ôedpovƒõƒè</div>
        <div class="chart-wrapper">
          <canvas id="twentyFourHourChart"></canvas>
        </div>
      </div>
    
      <div class="chart-container">
        <div class="chart-title">üìÖ 3denn√≠ p≈ôedpovƒõƒè</div>
        <div class="chart-wrapper">
          <canvas id="threeDayChart"></canvas>
        </div>
      </div>

      <div class="chart-container">
        <div class="chart-title">üóìÔ∏è 10denn√≠ p≈ôedpovƒõƒè</div>
        <div class="chart-wrapper">
          <canvas id="tenDayChart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Glob√°ln√≠ promƒõnn√©
    let threeDayChart = null;
    let twentyFourHourChart = null;
    let tenDayChart = null;
    let searchTimeout;
    let selectedSuggestionIndex = -1;
    let currentSuggestions = [];
    let currentLocationData = null;

    // Funkce pro zobrazen√≠ notifikace
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.innerHTML = `
        <span>${message}</span>
        <button onclick="this.parentElement.remove()" style="background:none;border:none;color:white;float:right;cursor:pointer;font-size:1.2rem;">√ó</button>
      `;

      document.body.appendChild(notification);

      setTimeout(() => {
        if (notification.parentElement) {
          notification.remove();
        }
      }, 5000);
    }

    // Funkce pro vyhled√°v√°n√≠ lokac√≠
    async function searchLocations(query) {
      if (query.length < 2) {
        return [];
      }
      try {
        const response = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=10&language=cs&format=json`);
        const data = await response.json();

        if (data.results) {
          return data.results.map(location => ({
            name: location.name,
            country: location.country,
            admin1: location.admin1,
            lat: location.latitude,
            lon: location.longitude,
            displayName: `${location.name}${location.admin1 ? ', ' + location.admin1 : ''}, ${location.country}`
          }));
        }

        return [];
      } catch (error) {
        console.error('Geocoding error:', error);
        // Fallback pro ƒçesk√© mƒõsta
        const czechCities = [
          { name: 'Praha', country: 'ƒåesk√° republika', lat: 50.0755, lon: 14.4378 },
          { name: 'Brno', country: 'ƒåesk√° republika', lat: 49.1951, lon: 16.6068 },
          { name: 'Ostrava', country: 'ƒåesk√° republika', lat: 49.8209, lon: 18.2625 },
          { name: 'Plze≈à', country: 'ƒåesk√° republika', lat: 49.7384, lon: 13.3736 }
        ];

        return czechCities
          .filter(city => city.name.toLowerCase().includes(query.toLowerCase()))
          .map(city => ({
            name: city.name,
            country: city.country,
            lat: city.lat,
            lon: city.lon,
            displayName: `${city.name}, ${city.country}`
          }));
      }
    }

    // Funkce pro zobrazen√≠ n√°vrh≈Ø
    function displaySuggestions(suggestions) {
      const suggestionsDiv = document.getElementById('suggestions');
      currentSuggestions = suggestions;
      selectedSuggestionIndex = -1;

      if (suggestions.length === 0) {
        suggestionsDiv.classList.remove('show');
        return;
      }

      suggestionsDiv.innerHTML = suggestions.map((suggestion, index) => `
        <div class="suggestion-item" data-index="${index}" data-lat="${suggestion.lat}" data-lon="${suggestion.lon}">
          <div class="suggestion-name">${suggestion.name}</div>
          <div class="suggestion-details">${suggestion.displayName}</div>
        </div>
      `).join('');

      suggestionsDiv.classList.add('show');

      suggestionsDiv.querySelectorAll('.suggestion-item').forEach(item => {
        item.addEventListener('click', function() {
          const index = parseInt(this.dataset.index);
          selectSuggestion(index);
        });
      });
    }

    // Funkce pro v√Ωbƒõr n√°vrhu
    function selectSuggestion(index) {
      if (index >= 0 && index < currentSuggestions.length) {
        const suggestion = currentSuggestions[index];
        document.getElementById('location').value = suggestion.displayName;
        document.getElementById('suggestions').classList.remove('show');
        selectedSuggestionIndex = -1;
        
        currentLocationData = {
          displayName: suggestion.displayName,
          lat: suggestion.lat,
          lon: suggestion.lon,
          name: suggestion.name,
          country: suggestion.country,
          admin1: suggestion.admin1
        };
        
        loadWeather();
      }
    }

    // Funkce pro zv√Ωraznƒõn√≠ n√°vrhu
    function highlightSuggestion(index) {
      const suggestions = document.querySelectorAll('.suggestion-item');
      suggestions.forEach(item => item.classList.remove('selected'));

      if (index >= 0 && index < suggestions.length) {
        suggestions[index].classList.add('selected');
        selectedSuggestionIndex = index;
      }
    }

    function showLoading() {
      document.getElementById('loading').style.display = 'block';
      document.getElementById('error').style.display = 'none';
      document.getElementById('chartsSection').style.display = 'none';
    }

    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }

    function showError(message) {
      const errorDiv = document.getElementById('error');
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
      hideLoading();
    }

    function showWeatherData() {
      document.getElementById('chartsSection').style.display = 'block';
      hideLoading();
    }

    // Funkce pro z√≠sk√°n√≠ sou≈ôadnic
    async function getCoordinates(location) {
      if (currentLocationData && currentLocationData.displayName === location) {
        return { lat: currentLocationData.lat, lon: currentLocationData.lon };
      }

      const coordPattern = /^-?\d+\.?\d*,-?\d+\.?\d*$/;
      if (coordPattern.test(location)) {
        const [lat, lon] = location.split(',').map(Number);
        return { lat, lon };
      }
      
      if (currentSuggestions.length > 0) {
        const matchingSuggestion = currentSuggestions.find(s =>
          s.displayName === location || s.name === location
        );
        if (matchingSuggestion) {
          currentLocationData = matchingSuggestion;
          return { lat: matchingSuggestion.lat, lon: matchingSuggestion.lon };
        }
      }
      
      try {
        const locations = await searchLocations(location);
        if (locations.length > 0) {
          currentLocationData = locations[0];
          return { lat: locations[0].lat, lon: locations[0].lon };
        } else {
          throw new Error('Lokace nebyla nalezena');
        }
      } catch (error) {
        console.warn('Geocoding failed, using Prague coordinates:', error);
        currentLocationData = {
          displayName: 'Praha, ƒåesk√° republika',
          lat: 50.0755,
          lon: 14.4378,
          name: 'Praha',
          country: 'ƒåesk√° republika'
        };
        return { lat: 50.0755, lon: 14.4378 };
      }
    }

    async function loadWeather() {
      showLoading();

      try {
        const input = document.getElementById('location').value.trim();
        if (!input) {
          showError('Pros√≠m zadejte mƒõsto nebo sou≈ôadnice');
          return;
        }
        
        const coords = await getCoordinates(input);
        console.log('Pou≈æ√≠van√© sou≈ôadnice:', coords);
        
        if (currentLocationData && currentLocationData.displayName !== input) {
          document.getElementById('location').value = currentLocationData.displayName;
        }
        
        // Zobrazit tlaƒç√≠tko pro ulo≈æen√≠ lokace
        document.getElementById('saveLocationBtn').style.display = 'block';
        
        // Naƒçten√≠ hodinov√Ωch dat pro 3 dny
        const hourlyParams = [
          'temperature_2m', 'precipitation', 'wind_speed_10m', 'wind_direction_10m', 'cloud_cover', 'relative_humidity_2m'
        ].join(',');

        const hourlyUrl = `https://api.open-meteo.com/v1/forecast?latitude=${coords.lat}&longitude=${coords.lon}&hourly=${hourlyParams}&timezone=Europe%2FPrague&forecast_days=3`;
        
        // Naƒçten√≠ denn√≠ch dat pro 10 dn√≠
        const dailyParams = [
          'temperature_2m_max', 'temperature_2m_min', 'precipitation_sum', 'wind_speed_10m_max', 
          'wind_direction_10m_dominant', 'cloud_cover_mean'
        ].join(',');

        const dailyUrl = `https://api.open-meteo.com/v1/forecast?latitude=${coords.lat}&longitude=${coords.lon}&daily=${dailyParams}&timezone=Europe%2FPrague&forecast_days=10`;
        
        const [hourlyResponse, dailyResponse] = await Promise.all([
          fetch(hourlyUrl),
          fetch(dailyUrl)
        ]);
        
        if (!hourlyResponse.ok || !dailyResponse.ok) {
          throw new Error('Chyba p≈ôi naƒç√≠t√°n√≠ dat z API');
        }

        const hourly3DayData = await hourlyResponse.json();
        const daily10DayData = await dailyResponse.json();
        
        if (!hourly3DayData.hourly || !daily10DayData.daily) {
          throw new Error('Neplatn√° odpovƒõƒè z API');
        }
        
        // Zpracov√°n√≠ hodinov√Ωch dat pro 3 dny
        const hourlyTime = hourly3DayData.hourly.time;
        const hourlyTemp = hourly3DayData.hourly.temperature_2m;
        const hourlyPrecip = hourly3DayData.hourly.precipitation;
        const hourlyWind = hourly3DayData.hourly.wind_speed_10m.map(speed => Math.round(speed / 3.6 * 10) / 10);
        const hourlyWindDir = hourly3DayData.hourly.wind_direction_10m;
        const hourlyClouds = hourly3DayData.hourly.cloud_cover;
        
        // Aktualizace grafu
        updateThreeDayChart('threeDayChart', hourlyTime, hourlyTemp, hourlyPrecip, hourlyWind, hourlyWindDir, hourlyClouds);
        
        // Zpracov√°n√≠ dat pro 24hodinov√Ω graf
        const now = new Date();
        const twentyFourHoursLater = new Date(now.getTime() + 24 * 60 * 60 * 1000);

        // Filtrov√°n√≠ dat pro n√°sleduj√≠c√≠ch 24 hodin
        const twentyFourHourIndices = [];
        for (let i = 0; i < hourlyTime.length; i++) {
          const dataTime = new Date(hourlyTime[i]);
          if (dataTime >= now && dataTime <= twentyFourHoursLater) {
            twentyFourHourIndices.push(i);
          }
        }

        // Extrakce dat pro 24hodinov√Ω graf
        const twentyFourHourTime = twentyFourHourIndices.map(i => hourlyTime[i]);
        const twentyFourHourTemp = twentyFourHourIndices.map(i => hourlyTemp[i]);
        const twentyFourHourPrecip = twentyFourHourIndices.map(i => hourlyPrecip[i]);
        const twentyFourHourWind = twentyFourHourIndices.map(i => hourlyWind[i]);
        const twentyFourHourWindDir = twentyFourHourIndices.map(i => hourlyWindDir[i]);
        const twentyFourHourClouds = twentyFourHourIndices.map(i => hourlyClouds[i]);

        // Aktualizace 24hodinov√©ho grafu
        updateTwentyFourHourChart(
          'twentyFourHourChart',
          twentyFourHourTime,
          twentyFourHourTemp,
          twentyFourHourPrecip,
          twentyFourHourWind,
          twentyFourHourWindDir,
          twentyFourHourClouds
        );
        
        // Zpracov√°n√≠ 10denn√≠ch dat
        const dailyTime = daily10DayData.daily.time;
        const dailyTempMax = daily10DayData.daily.temperature_2m_max;
        const dailyTempMin = daily10DayData.daily.temperature_2m_min;
        const dailyPrecip = daily10DayData.daily.precipitation_sum;
        const dailyWind = daily10DayData.daily.wind_speed_10m_max.map(speed => Math.round(speed / 3.6 * 10) / 10);
        const dailyWindDir = daily10DayData.daily.wind_direction_10m_dominant;
        const dailyClouds = daily10DayData.daily.cloud_cover_mean;
        
        // Aktualizace 10denn√≠ho grafu
        updateTenDayChart(
          'tenDayChart',
          dailyTime,
          dailyTempMax,
          dailyTempMin,
          dailyPrecip,
          dailyWind,
          dailyWindDir,
          dailyClouds
        );
        
        showWeatherData();
        showNotification(`P≈ôedpovƒõƒè naƒçtena pro: ${currentLocationData?.displayName || 'nezn√°mou lokaci'}`, 'success');

      } catch (error) {
        console.error('Chyba:', error);
        showError(`Chyba p≈ôi naƒç√≠t√°n√≠ p≈ôedpovƒõdi: ${error.message}`);
      }
    }

    function updateThreeDayChart(canvasId, time, temp, precip, wind, windDir, clouds) {
      const canvas = document.getElementById(canvasId);

      if (threeDayChart) {
        threeDayChart.destroy();
      }
      const ctx = canvas.getContext('2d');

      const hours72 = Math.min(72, time.length);
      const labels = [];
      const tempData = [];
      const precipData = [];
      const windData = [];
      const windDirData = [];
      const cloudsData = [];

      for (let i = 0; i < hours72; i += 3) {
        const date = new Date(time[i]);
        const hour = date.getHours();

        if (hour === 0) {
          labels.push(date.toLocaleDateString('cs-CZ', {
            weekday: 'short',
            day: 'numeric',
            month: 'numeric'
          }));
        } else {
          labels.push(hour.toString().padStart(2, '0') + ':00');
        }

        tempData.push(temp[i]);
        precipData.push(precip[i]);
        windData.push(wind[i]);
        windDirData.push(windDir[i]);
        cloudsData.push(clouds[i]);
      }

      // Plugin pro kreslen√≠ ≈°ipek smƒõru vƒõtru
      const windArrowPlugin = {
        id: 'windArrows',
        afterDatasetsDraw: (chart) => {
          const ctx = chart.ctx;
          const meta = chart.getDatasetMeta(2);

          if (!meta || !meta.data) return;

          ctx.save();
          ctx.strokeStyle = '#4ecdc4';
          ctx.fillStyle = '#4ecdc4';
          ctx.lineWidth = 2;

          meta.data.forEach((point, index) => {
            const windSpeed = windData[index];
            const windDirection = windDirData[index];

            if (windSpeed > 1 && windDirection !== undefined && windDirection !== null) {
              const x = point.x;
              const y = point.y;
              const arrowSize = Math.min(20, Math.max(10, windSpeed * 2));

              ctx.save();
              ctx.translate(x, y - 15);
              const rotation = ((windDirection + 180) * Math.PI) / 180; // Modified line
              ctx.rotate(rotation);

              ctx.beginPath();
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(0, arrowSize/2);
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(-arrowSize/4, -arrowSize/4);
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(arrowSize/4, -arrowSize/4);

              ctx.stroke();
              ctx.restore();
            }
          });

          ctx.restore();
        }
      };

      // Plugin pro kreslen√≠ ƒç√°ry aktu√°ln√≠ho ƒçasu
      const currentTimePlugin = {
        id: 'currentTimeLine',
        afterDatasetsDraw: (chart) => {
          const ctx = chart.ctx;
          const chartArea = chart.chartArea;
          const now = new Date();

          let currentTimeIndex = -1;
          const currentTimeMs = now.getTime();
          
          for (let i = 0; i < time.length; i += 3) {
            const dataTimeMs = new Date(time[i]).getTime();
            if (dataTimeMs <= currentTimeMs && (i + 3 >= time.length || new Date(time[i + 3]).getTime() > currentTimeMs)) {
              if (i + 3 < time.length) {
                const nextTimeMs = new Date(time[i + 3]).getTime();
                const timeDiff = nextTimeMs - dataTimeMs;
                const currentDiff = currentTimeMs - dataTimeMs;
                const ratio = currentDiff / timeDiff;
                currentTimeIndex = (i / 3) + ratio;
              } else {
                currentTimeIndex = i / 3;
              }
              break;
            }
          }

          if (currentTimeIndex >= 0 && currentTimeIndex < labels.length) {
            const xScale = chart.scales.x;
            const x = xScale.getPixelForValue(currentTimeIndex);

            if (x >= chartArea.left && x <= chartArea.right) {
              ctx.save();
              
              ctx.strokeStyle = '#ff9800';
              ctx.lineWidth = 3;
              ctx.setLineDash([5, 5]);
              
              ctx.beginPath();
              ctx.moveTo(x, chartArea.top);
              ctx.lineTo(x, chartArea.bottom);
              ctx.stroke();
              
              ctx.fillStyle = '#ff9800';
              ctx.font = 'bold 12px sans-serif';
              ctx.textAlign = 'center';
              
              const timeText = now.toLocaleTimeString('cs-CZ', { 
                hour: '2-digit', 
                minute: '2-digit' 
              });
              ctx.fillText(timeText, x, chartArea.top - 5);
              
              ctx.restore();
            }
          }
        }
      };

      threeDayChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Teplota (¬∞C)',
              data: tempData,
              borderColor: '#ff6b6b',
              backgroundColor: '#ff6b6b20',
              borderWidth: 3,
              fill: false,
              tension: 0.4,
              yAxisID: 'y',
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: 'Sr√°≈æky (mm)',
              data: precipData,
              type: 'bar',
              backgroundColor: '#06b6d480',
              borderColor: '#06b6d4',
              borderWidth: 1,
              yAxisID: 'y1'
            },
            {
              label: 'Rychlost vƒõtru (m/s)',
              data: windData,
              borderColor: '#4ecdc4',
              backgroundColor: '#4ecdc420',
              borderWidth: 2,
              fill: false,
              tension: 0.4,
              yAxisID: 'y2',
              pointRadius: 3,
              pointHoverRadius: 5
            },
            {
              label: 'Oblaƒçnost (%)',
              data: cloudsData,
              borderColor: '#6b7280',
              backgroundColor: '#6b728020',
              borderWidth: 2,
              fill: true,
              tension: 0.4,
              yAxisID: 'y3',
              pointRadius: 2,
              pointHoverRadius: 4
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'bottom',
              labels: {
                color: '#e2e8f0',
                font: { size: 12 },
                padding: 20,
                usePointStyle: true,
                pointStyle: 'circle'
              }
            },
            tooltip: {
              backgroundColor: 'rgba(0,0,0,0.8)',
              titleColor: '#e2e8f0',
              bodyColor: '#e2e8f0',
              borderColor: '#6aa6fd',
              borderWidth: 1,
              callbacks: {
                afterBody: function(tooltipItems) {
                  const index = tooltipItems[0].dataIndex;
                  const windSpeed = windData[index];
                  const windDirection = windDirData[index];

                  if (windSpeed > 0 && windDirection !== undefined) {
                    const directions = ['S', 'SSV', 'SV', 'VSV', 'V', 'VJV', 'JV', 'JJV', 'J', 'JJZ', 'JZ', 'ZJZ', 'Z', 'ZSZ', 'SZ', 'SSZ'];
                    const dirIndex = Math.round(windDirection / 22.5) % 16;
                    const dirText = directions[dirIndex];

                    return [`üß≠ Smƒõr vƒõtru: ${dirText} (${Math.round(windDirection)}¬∞)`];
                  }
                  return [];
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: '#94a3b8',
                font: { size: 11 }
              },
              grid: {
                color: function(context) {
                  const labelIndex = context.index;
                  const label = context.chart.data.labels[labelIndex];

                  if (label && (label.includes('.') || label.includes('/'))) {
                    return 'rgba(148, 163, 184, 0.4)';
                  }
                  return 'rgba(148, 163, 184, 0.1)';
                },
                lineWidth: function(context) {
                  const labelIndex = context.index;
                  const label = context.chart.data.labels[labelIndex];

                  if (label && (label.includes('.') || label.includes('/'))) {
                    return 2;
                  }
                  return 1;
                }
              }
            },
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              ticks: {
                color: '#ff6b6b',
                callback: function(value) { return value + '¬∞C'; }
              },
              grid: { color: '#404040' },
              title: {
                display: true,
                text: 'Teplota (¬∞C)',
                color: '#ff6b6b'
              }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              min: 0,
              ticks: {
                color: '#06b6d4',
                callback: function(value) { return value + 'mm'; }
              },
              grid: { drawOnChartArea: false },
              title: {
                display: true,
                text: 'Sr√°≈æky (mm)',
                color: '#06b6d4'
              }
            },
            y2: {
              type: 'linear',
              display: true,
              position: 'right',
              min: 0,
              ticks: {
                color: '#4ecdc4',
                callback: function(value) { return value + 'm/s'; }
              },
              grid: { drawOnChartArea: false },
              title: {
                display: true,
                text: 'Rychlost vƒõtru (m/s)',
                color: '#4ecdc4'
              }
            },
            y3: {
              type: 'linear',
              display: true,
              position: 'right',
              min: 0,
              max: 100,
              ticks: {
                color: '#6b7280',
                callback: function(value) { return value + '%'; }
              },
              grid: { drawOnChartArea: false },
              title: {
                display: true,
                text: 'Oblaƒçnost (%)',
                color: '#6b7280'
              }
            }
          }
        },
        plugins: [windArrowPlugin, currentTimePlugin]
      });
    }

    function updateTwentyFourHourChart(canvasId, time, temp, precip, wind, windDir, clouds) {
      const canvas = document.getElementById(canvasId);

      if (twentyFourHourChart) {
        twentyFourHourChart.destroy();
      }
      const ctx = canvas.getContext('2d');

      const labels = [];
      const tempData = [];
      const precipData = [];
      const windData = [];
      const windDirData = [];
      const cloudsData = [];

      for (let i = 0; i < time.length; i++) {
        const date = new Date(time[i]);
        labels.push(date.toLocaleTimeString('cs-CZ', {
          hour: '2-digit',
          minute: '2-digit'
        }));

        tempData.push(temp[i]);
        precipData.push(precip[i]);
        windData.push(wind[i]);
        windDirData.push(windDir[i]);
        cloudsData.push(clouds[i]);
      }

      // Plugin pro kreslen√≠ ≈°ipek smƒõru vƒõtru
      const windArrowPlugin = {
        id: 'windArrows24',
        afterDatasetsDraw: (chart) => {
          const ctx = chart.ctx;
          const meta = chart.getDatasetMeta(2);

          if (!meta || !meta.data) return;

          ctx.save();
          ctx.strokeStyle = '#4ecdc4';
          ctx.fillStyle = '#4ecdc4';
          ctx.lineWidth = 2;

          meta.data.forEach((point, index) => {
            const windSpeed = windData[index];
            const windDirection = windDirData[index];

            if (windSpeed > 1 && windDirection !== undefined && windDirection !== null) {
              const x = point.x;
              const y = point.y;
              const arrowSize = Math.min(20, Math.max(10, windSpeed * 2));

              ctx.save();
              ctx.translate(x, y - 15);
              const rotation = ((windDirection + 180) * Math.PI) / 180;
              ctx.rotate(rotation);

              ctx.beginPath();
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(0, arrowSize/2);
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(-arrowSize/4, -arrowSize/4);
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(arrowSize/4, -arrowSize/4);

              ctx.stroke();
              ctx.restore();
            }
          });

          ctx.restore();
        }
      };

      // Plugin pro kreslen√≠ ƒç√°ry aktu√°ln√≠ho ƒçasu
      const currentTimePlugin = {
        id: 'currentTimeLine24',
        afterDatasetsDraw: (chart) => {
          const ctx = chart.ctx;
          const chartArea = chart.chartArea;
          const now = new Date();

          let currentTimeIndex = -1;
          const currentTimeMs = now.getTime();
          
          for (let i = 0; i < time.length; i++) {
            const dataTimeMs = new Date(time[i]).getTime();
            if (dataTimeMs <= currentTimeMs && (i + 1 >= time.length || new Date(time[i + 1]).getTime() > currentTimeMs)) {
              if (i + 1 < time.length) {
                const nextTimeMs = new Date(time[i + 1]).getTime();
                const timeDiff = nextTimeMs - dataTimeMs;
                const currentDiff = currentTimeMs - dataTimeMs;
                const ratio = currentDiff / timeDiff;
                currentTimeIndex = i + ratio;
              } else {
                currentTimeIndex = i;
              }
              break;
            }
          }

          if (currentTimeIndex >= 0 && currentTimeIndex < labels.length) {
            const xScale = chart.scales.x;
            const x = xScale.getPixelForValue(currentTimeIndex);

            if (x >= chartArea.left && x <= chartArea.right) {
              ctx.save();
              
              ctx.strokeStyle = '#ff9800';
              ctx.lineWidth = 3;
              ctx.setLineDash([5, 5]);
              
              ctx.beginPath();
              ctx.moveTo(x, chartArea.top);
              ctx.lineTo(x, chartArea.bottom);
              ctx.stroke();
              
              ctx.fillStyle = '#ff9800';
              ctx.font = 'bold 12px sans-serif';
              ctx.textAlign = 'center';
              ctx.fillText('NYN√ç', x, chartArea.top - 5);
              
              ctx.restore();
            }
          }
        }
      };

      twentyFourHourChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Teplota (¬∞C)',
              data: tempData,
              borderColor: '#ff6b6b',
              backgroundColor: '#ff6b6b20',
              borderWidth: 3,
              fill: false,
              tension: 0.4,
              yAxisID: 'y',
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: 'Sr√°≈æky (mm)',
              data: precipData,
              type: 'bar',
              backgroundColor: '#06b6d480',
              borderColor: '#06b6d4',
              borderWidth: 1,
              yAxisID: 'y1'
            },
            {
              label: 'Rychlost vƒõtru (m/s)',
              data: windData,
              borderColor: '#4ecdc4',
              backgroundColor: '#4ecdc420',
              borderWidth: 2,
              fill: false,
              tension: 0.4,
              yAxisID: 'y2',
              pointRadius: 3,
              pointHoverRadius: 5
            },
            {
              label: 'Oblaƒçnost (%)',
              data: cloudsData,
              borderColor: '#6b7280',
              backgroundColor: '#6b728020',
              borderWidth: 2,
              fill: true,
              tension: 0.4,
              yAxisID: 'y3',
              pointRadius: 2,
              pointHoverRadius: 4
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'bottom',
              labels: {
                color: '#e2e8f0',
                font: { size: 12 },
                padding: 20,
                usePointStyle: true,
                pointStyle: 'circle'
              }
            },
            tooltip: {
              backgroundColor: 'rgba(0,0,0,0.8)',
              titleColor: '#e2e8f0',
              bodyColor: '#e2e8f0',
              borderColor: '#6aa6fd',
              borderWidth: 1,
              callbacks: {
                afterBody: function(tooltipItems) {
                  const index = tooltipItems[0].dataIndex;
                  const windSpeed = windData[index];
                  const windDirection = windDirData[index];

                  if (windSpeed > 0 && windDirection !== undefined) {
                    const directions = ['S', 'SSV', 'SV', 'VSV', 'V', 'VJV', 'JV', 'JJV', 'J', 'JJZ', 'JZ', 'ZJZ', 'Z', 'ZSZ', 'SZ', 'SSZ'];
                    const dirIndex = Math.round(windDirection / 22.5) % 16;
                    const dirText = directions[dirIndex];

                    return [`üß≠ Smƒõr vƒõtru: ${dirText} (${Math.round(windDirection)}¬∞)`];
                  }
                  return [];
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: '#94a3b8',
                font: { size: 11 }
              },
              grid: {
                color: 'rgba(148, 163, 184, 0.1)',
                lineWidth: 1
              }
            },
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              ticks: {
                color: '#ff6b6b',
                callback: function(value) { return value + '¬∞C'; }
              },
              grid: { color: '#404040' },
              title: {
                display: true,
                text: 'Teplota (¬∞C)',
                color: '#ff6b6b'
              }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              min: 0,
              ticks: {
                color: '#06b6d4',
                callback: function(value) { return value + 'mm'; }
              },
              grid: { drawOnChartArea: false },
              title: {
                display: true,
                text: 'Sr√°≈æky (mm)',
                color: '#06b6d4'
              }
            },
            y2: {
              type: 'linear',
              display: true,
              position: 'right',
              min: 0,
              ticks: {
                color: '#4ecdc4',
                callback: function(value) { return value + 'm/s'; }
              },
              grid: { drawOnChartArea: false },
              title: {
                display: true,
                text: 'Rychlost vƒõtru (m/s)',
                color: '#4ecdc4'
              }
            },
            y3: {
              type: 'linear',
              display: true,
              position: 'right',
              min: 0,
              max: 100,
              ticks: {
                color: '#6b7280',
                callback: function(value) { return value + '%'; }
              },
              grid: { drawOnChartArea: false },
              title: {
                display: true,
                text: 'Oblaƒçnost (%)',
                color: '#6b7280'
              }
            }
          }
        },
        plugins: [windArrowPlugin, currentTimePlugin]
      });
    }

    function updateTenDayChart(canvasId, time, tempMax, tempMin, precip, wind, windDir, clouds) {
      const canvas = document.getElementById(canvasId);

      if (tenDayChart) {
        tenDayChart.destroy();
      }
      const ctx = canvas.getContext('2d');

      const labels = time.map(dateStr => {
        const date = new Date(dateStr);
        return date.toLocaleDateString('cs-CZ', {
          weekday: 'short',
          day: 'numeric',
          month: 'numeric'
        });
      });

      // Plugin pro kreslen√≠ ≈°ipek smƒõru vƒõtru
      const windArrowPlugin = {
        id: 'windArrows10',
        afterDatasetsDraw: (chart) => {
          const ctx = chart.ctx;
          const meta = chart.getDatasetMeta(3);

          if (!meta || !meta.data) return;

          ctx.save();
          ctx.strokeStyle = '#4ecdc4';
          ctx.fillStyle = '#4ecdc4';
          ctx.lineWidth = 2;

          meta.data.forEach((point, index) => {
            const windSpeed = wind[index];
            const windDirection = windDir[index];

            if (windSpeed > 1 && windDirection !== undefined && windDirection !== null) {
              const x = point.x;
              const y = point.y;
              const arrowSize = Math.min(20, Math.max(10, windSpeed * 2));

              ctx.save();
              ctx.translate(x, y - 15);
              const rotation = ((windDirection + 180) * Math.PI) / 180;
              ctx.rotate(rotation);

              ctx.beginPath();
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(0, arrowSize/2);
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(-arrowSize/4, -arrowSize/4);
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(arrowSize/4, -arrowSize/4);

              ctx.stroke();
              ctx.restore();
            }
          });

          ctx.restore();
        }
      };

      tenDayChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Maxim√°ln√≠ teplota (¬∞C)',
              data: tempMax,
              borderColor: '#ff6b6b',
              backgroundColor: '#ff6b6b20',
              borderWidth: 3,
              fill: false,
              tension: 0.4,
              yAxisID: 'y',
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: 'Minim√°ln√≠ teplota (¬∞C)',
              data: tempMin,
              borderColor: '#6aa6fd',
              backgroundColor: '#6aa6fd20',
              borderWidth: 3,
              fill: false,
              tension: 0.4,
              yAxisID: 'y',
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: 'Sr√°≈æky (mm)',
              data: precip,
              type: 'bar',
              backgroundColor: '#06b6d480',
              borderColor: '#06b6d4',
              borderWidth: 1,
              yAxisID: 'y1'
            },
            {
              label: 'Rychlost vƒõtru (m/s)',
              data: wind,
              borderColor: '#4ecdc4',
              backgroundColor: '#4ecdc420',
              borderWidth: 2,
              fill: false,
              tension: 0.4,
              yAxisID: 'y2',
              pointRadius: 3,
              pointHoverRadius: 5
            },
            {
              label: 'Oblaƒçnost (%)',
              data: clouds,
              borderColor: '#6b7280',
              backgroundColor: '#6b728020',
              borderWidth: 2,
              fill: true,
              tension: 0.4,
              yAxisID: 'y3',
              pointRadius: 2,
              pointHoverRadius: 4
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'bottom',
              labels: {
                color: '#e2e8f0',
                font: { size: 12 },
                padding: 20,
                usePointStyle: true,
                pointStyle: 'circle'
              }
            },
            tooltip: {
              backgroundColor: 'rgba(0,0,0,0.8)',
              titleColor: '#e2e8f0',
              bodyColor: '#e2e8f0',
              borderColor: '#6aa6fd',
              borderWidth: 1,
              callbacks: {
                afterBody: function(tooltipItems) {
                  const index = tooltipItems[0].dataIndex;
                  const windSpeed = wind[index];
                  const windDirection = windDir[index];
                  const cloudCover = clouds[index];

                  const tooltipLines = [];

                  if (windSpeed > 0 && windDirection !== undefined) {
                    const directions = ['S', 'SSV', 'SV', 'VSV', 'V', 'VJV', 'JV', 'JJV', 'J', 'JJZ', 'JZ', 'ZJZ', 'Z', 'ZSZ', 'SZ', 'SSZ'];
                    const dirIndex = Math.round(windDirection / 22.5) % 16;
                    const dirText = directions[dirIndex];
                    tooltipLines.push(`üß≠ Smƒõr vƒõtru: ${dirText} (${Math.round(windDirection)}¬∞)`);
                  }

                  if (cloudCover !== undefined) {
                    tooltipLines.push(`‚òÅÔ∏è Oblaƒçnost: ${Math.round(cloudCover)}%`);
                  }

                  return tooltipLines;
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: '#94a3b8',
                font: { size: 11 }
              },
              grid: {
                color: 'rgba(148, 163, 184, 0.1)',
                lineWidth: 1
              }
            },
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              ticks: {
                color: '#ff6b6b',
                callback: function(value) { return value + '¬∞C'; }
              },
              grid: { color: '#404040' },
              title: {
                display: true,
                text: 'Teplota (¬∞C)',
                color: '#ff6b6b'
              }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              min: 0,
              ticks: {
                color: '#06b6d4',
                callback: function(value) { return value + 'mm'; }
              },
              grid: { drawOnChartArea: false },
              title: {
                display: true,
                text: 'Sr√°≈æky (mm)',
                color: '#06b6d4'
              }
            },
            y2: {
              type: 'linear',
              display: true,
              position: 'right',
              min: 0,
              ticks: {
                color: '#4ecdc4',
                callback: function(value) { return value + 'm/s'; }
              },
              grid: { drawOnChartArea: false },
              title: {
                display: true,
                text: 'Rychlost vƒõtru (m/s)',
                color: '#4ecdc4'
              }
            },
            y3: {
              type: 'linear',
              display: true,
              position: 'right',
              min: 0,
              max: 100,
              ticks: {
                color: '#6b7280',
                callback: function(value) { return value + '%'; }
              },
              grid: { drawOnChartArea: false },
              title: {
                display: true,
                text: 'Oblaƒçnost (%)',
                color: '#6b7280'
              }
            }
          }
        },
        plugins: [windArrowPlugin]
      });
    }

    // Ulo≈æen√≠ lokace do localStorage
    function saveLocation() {
      if (currentLocationData) {
        localStorage.setItem('savedLocation', JSON.stringify(currentLocationData));
        showNotification('Lokace ulo≈æena', 'success');
        updateSavedLocationInfo();
      }
    }

    // Naƒçten√≠ ulo≈æen√© lokace
    function loadSavedLocation() {
      const saved = localStorage.getItem('savedLocation');
      if (saved) {
        try {
          currentLocationData = JSON.parse(saved);
          document.getElementById('location').value = currentLocationData.displayName;
          updateSavedLocationInfo();
          return true;
        } catch (e) {
          console.error('Error parsing saved location:', e);
          localStorage.removeItem('savedLocation');
        }
      }
      return false;
    }

    // Aktualizace informace o ulo≈æen√© lokaci
    function updateSavedLocationInfo() {
      const savedLocationInfo = document.getElementById('savedLocationInfo');
      if (localStorage.getItem('savedLocation')) {
        savedLocationInfo.style.display = 'flex';
      } else {
        savedLocationInfo.style.display = 'none';
      }
    }

    // Inicializace aplikace
    function initApp() {
      // Naƒçten√≠ ulo≈æen√© lokace
      if (loadSavedLocation()) {
        loadWeather();
      }

      // Nastaven√≠ event listener≈Ø
      document.getElementById('loadWeather').addEventListener('click', loadWeather);
      document.getElementById('saveLocationBtn').addEventListener('click', saveLocation);

      const locationInput = document.getElementById('location');
      locationInput.addEventListener('input', function() {
        clearTimeout(searchTimeout);
        const query = this.value.trim();
        
        if (query.length >= 2) {
          searchTimeout = setTimeout(async () => {
            const suggestions = await searchLocations(query);
            displaySuggestions(suggestions);
          }, 300);
        } else {
          document.getElementById('suggestions').classList.remove('show');
        }
      });

      locationInput.addEventListener('keydown', function(e) {
        const suggestionsDiv = document.getElementById('suggestions');
        
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          const nextIndex = Math.min(selectedSuggestionIndex + 1, currentSuggestions.length - 1);
          highlightSuggestion(nextIndex);
          if (nextIndex >= 0) {
            const suggestionItems = suggestionsDiv.querySelectorAll('.suggestion-item');
            suggestionItems[nextIndex].scrollIntoView({ block: 'nearest' });
          }
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          const prevIndex = Math.max(selectedSuggestionIndex - 1, -1);
          highlightSuggestion(prevIndex);
          if (prevIndex >= 0) {
            const suggestionItems = suggestionsDiv.querySelectorAll('.suggestion-item');
            suggestionItems[prevIndex].scrollIntoView({ block: 'nearest' });
          }
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (selectedSuggestionIndex >= 0) {
            selectSuggestion(selectedSuggestionIndex);
          } else {
            loadWeather();
          }
        } else if (e.key === 'Escape') {
          suggestionsDiv.classList.remove('show');
        }
      });

      // Kliknut√≠ mimo input skryje suggestions
      document.addEventListener('click', function(e) {
        if (e.target !== locationInput) {
          document.getElementById('suggestions').classList.remove('show');
        }
      });
    }

    // Spu≈°tƒõn√≠ aplikace po naƒçten√≠ DOM
    document.addEventListener('DOMContentLoaded', initApp);
  </script>
</body>
</html>
