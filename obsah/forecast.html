<html lang="cs">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üå¶Ô∏è P≈ôedpovƒõƒè poƒças√≠</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: #1a1a1a;
      color: #e0e0e0;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 40px;
    }

    .header h1 {
      font-size: 1.4rem;
      font-weight: 600;
      margin: 0;
      margin-bottom: 10px;
      color: #e0e0e0;
    }

    .tabs {
      display: flex;
      margin-bottom: 20px;
      border-bottom: 1px solid #404040;
    }

    .tab {
      padding: 12px 24px;
      background-color: #2a2a2a;
      border: 1px solid #404040;
      border-bottom: none;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s ease;
      margin-right: 5px;
    }

    .tab.active {
      background-color: #404040;
      color: #6aa6fd;
      border-color: #6aa6fd;
    }

    .tab:hover:not(.active) {
      background-color: #353535;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .controls-section {
      background-color: #2a2a2a;
      border: 1px solid #404040;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .search-form {
      display: flex;
      align-items: end;
      gap: 20px;
      flex-wrap: wrap;
    }

    .search-group {
      position: relative;
      flex: 1;
      min-width: 200px;
    }

    .search-group h3 {
      font-size: 0.9rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
      font-weight: 600;
    }

    .search-input {
      width: 100%;
      padding: 8px 12px;
      background-color: #404040;
      border: 1px solid #555;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 0.9rem;
      transition: all 0.3s ease;
    }

    .search-input::placeholder {
      color: #999;
    }

    .search-input:focus {
      outline: none;
      border-color: #6aa6fd;
    }

    .suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background-color: #404040;
      border: 1px solid #555;
      border-top: none;
      border-radius: 0 0 4px 4px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
    }

    .suggestions.show {
      display: block;
    }

    .suggestion-item {
      padding: 10px 12px;
      cursor: pointer;
      color: #e0e0e0;
      font-size: 0.9rem;
      border-bottom: 1px solid #555;
      transition: background-color 0.2s ease;
    }

    .suggestion-item:hover,
    .suggestion-item.selected {
      background-color: #6aa6fd;
    }

    .suggestion-item:last-child {
      border-bottom: none;
    }

    .suggestion-name {
      font-weight: 500;
    }

    .suggestion-details {
      font-size: 0.8rem;
      color: #bbb;
      margin-top: 2px;
    }

    .load-btn {
      background-color: #6aa6fd;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background-color 0.2s ease;
      flex-shrink: 0;
      height: fit-content;
    }

    .load-btn:hover {
      background-color: #5694f0;
    }

    .charts-section {
      display: grid;
      gap: 30px;
      margin-bottom: 30px;
    }

    .chart-container {
      background-color: #2a2a2a;
      border: 1px solid #404040;
      border-radius: 8px;
      padding: 20px;
      box-shadow: none;
    }

    .chart-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 15px;
      color: #e0e0e0;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .chart-wrapper {
      position: relative;
      height: 400px;
      margin-bottom: 20px;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #888;
    }

    .loading .spinner {
      font-size: 3rem;
      animation: spin 2s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .error {
      background-color: #4a2c2c;
      border: 1px solid #8b4444;
      color: #ff8888;
      padding: 15px;
      border-radius: 4px;
      margin: 20px 0;
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 20px;
      border-radius: 4px;
      color: white;
      font-size: 0.9rem;
      z-index: 10000;
      min-width: 300px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: space-between;
      animation: slideIn 0.3s ease-out;
    }

    .notification.success {
      background-color: #4caf50;
      border-left: 4px solid #45a049;
    }

    .notification.info {
      background-color: #2196f3;
      border-left: 4px solid #1976d2;
    }

    .notification.warning {
      background-color: #ff9800;
      border-left: 4px solid #f57c00;
    }

    .notification.error {
      background-color: #f44336;
      border-left: 4px solid #d32f2f;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .saved-location-info {
      background-color: #2d4a2d;
      border: 1px solid #4caf50;
      color: #81c784;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
      height: fit-content;
    }

    /* Radar section styles */
    .radar-container {
      background-color: #2a2a2a;
      border: 1px solid #404040;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 30px;
      position: relative;
    }

    .radar-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .radar-controls-right {
      display: flex;
      align-items: center;
      gap: 20px;
      flex-wrap: wrap;
    }

    .radar-speed-control {
      display: flex;
      align-items: center;
      gap: 10px;
      background: #333;
      padding: 5px 12px;
      border-radius: 4px;
      border: 1px solid #444;
    }

    .radar-speed-control label {
      font-size: 0.85rem;
      color: #bbb;
      white-space: nowrap;
    }

    .radar-speed-control input[type="range"] {
      -webkit-appearance: none;
      width: 120px;
      height: 4px;
      background: #555;
      border-radius: 2px;
      outline: none;
    }

    .radar-speed-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #6aa6fd;
      border-radius: 50%;
      cursor: pointer;
      transition: background .15s ease-in-out;
    }

    .radar-speed-control input[type="range"]::-webkit-slider-thumb:hover {
      background: #5694f0;
      transform: scale(1.1);
    }

    .radar-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: #e0e0e0;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .radar-map {
      height: 500px;
      width: 100%;
      border-radius: 6px;
      overflow: hidden;
      z-index: 1;
    }

    .radar-info {
      margin-top: 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
      color: #bbb;
    }

    .radar-status {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: #4caf50;
      transition: background-color 0.3s ease;
    }

    .status-indicator.loading {
      background-color: #ff9800; 
      animation: none;
    }

    .status-indicator.error {
      background-color: #f44336;
      animation: none; 
    }

    .radar-legend {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-top: 15px;
      padding: 10px;
      background-color: #333;
      border-radius: 4px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 0.8rem;
    }

    .legend-color {
      width: 15px;
      height: 15px;
      border-radius: 3px;
    }

    @media (max-width: 1200px) {
      .search-form {
        flex-direction: column;
        align-items: stretch;
      }
      .search-group {
        min-width: auto;
      }
    }

    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }
      .header h1 {
        fontSize: 1.2rem;
      }
      .chart-wrapper {
        height: 300px;
      }
      .saved-location-info {
        display: none;
      }
      .radar-map {
        height: 350px;
      }
      .radar-controls {
        flex-direction: column;
        align-items: flex-start;
      }
      .radar-controls-right {
        width: 100%;
        justify-content: space-between;
        margin-top: 10px;
      }
    }

    .charts-section {
      display: grid;
      gap: 30px;
      margin-bottom: 30px;
      grid-template-columns: 1fr;
    }

    @media (min-width: 1200px) {
      .weather-icons {
        padding-right: 60px;
        right: -20px;
      }
    }

    .chartjs-legend {
      margin-top: 20px !important;
      text-align: center !important;
    }

    .chartjs-legend ul {
      display: flex !important;
      flex-wrap: wrap !important;
      justify-content: center !important;
      gap: 15px !important;
      padding: 0 !important;
      margin: 0 !important;
    }

    .chartjs-legend li {
      display: flex !important;
      align-items: center !important;
      gap: 5px !important;
    }

    .chartjs-legend li span {
      display: inline-block !important;
      width: 12px !important;
      height: 12px !important;
      margin-right: 5px !important;
    }

    /* Leaflet overrides for dark theme */
    .leaflet-container {
      background: #2a2a2a;
    }
    .leaflet-bar {
      background-color: #2a2a2a;
      border: 1px solid #555;
    }
    .leaflet-bar a {
      background-color: #2a2a2a;
      border-bottom: 1px solid #555;
      color: #e0e0e0;
    }
    .leaflet-bar a:hover {
      background-color: #404040;
    }
    .leaflet-control-zoom-in, .leaflet-control-zoom-out {
      font: bold 18px/20px Arial;
    }
    
    .plus-marker {
      background-color: transparent !important;
      border-radius: 0 !important;
      border: none !important;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="red" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather feather-plus"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>') !important;
      background-size: contain !important;
      width: 24px !important;
      height: 24px !important;
      transform: translate(-50%, -50%) !important;
    }

    /* --- OPTIMALIZACE PRO PLYNULOU ANIMACI RADARU --- */
    .radar-layer {
      /* Zkr√°cen ƒças p≈ôechodu na 0.1s pro podporu rychlosti 100ms */
      transition: opacity 0.1s linear; 
      will-change: opacity;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üå§Ô∏è P≈ôedpovƒõƒè Poƒças√≠</h1>
    </div>
    
    <div class="tabs">
      <div class="tab active" data-tab="forecast">üìä P≈ôedpovƒõƒè</div>
      <div class="tab" data-tab="radar">üì° Radar</div>
    </div>
    
    <div class="tab-content active" id="forecast-tab">
      <div class="controls-section">
        <div class="search-form">
          <div class="search-group">
            <h3>üìç Lokace</h3>
            <input
              id="location"
              class="search-input"
              type="text"
              placeholder="Zaƒçnƒõte ps√°t n√°zev mƒõsta..."
              autocomplete="off"
            />
            <div class="suggestions" id="suggestions"></div>
          </div>
          <div id="savedLocationInfo" class="saved-location-info" style="display: none;">
            <span>üíæ</span>
            <span id="savedLocationText">Pou≈æ√≠v√°m ulo≈æenou lokaci</span>
          </div>
          <button class="load-btn" id="loadWeather">
            üîç Naƒç√≠st p≈ôedpovƒõƒè poƒças√≠
          </button>
          <button class="load-btn" id="saveLocationBtn" style="display: none;">
            üíæ Ulo≈æit lokaci
          </button>
        </div>
      </div>
      
      <div id="loading" class="loading" style="display: none;">
        <div class="spinner">‚è≥</div>
        <p>Naƒç√≠t√°m meteorologick√° data...</p>
      </div>
      
      <div id="error" class="error" style="display: none;"></div>
      
      <div class="charts-section" id="chartsSection" style="display: none;">
        <div class="chart-container">
          <div class="chart-title">‚è∞ 24hodinov√° p≈ôedpovƒõƒè</div>
          <div class="chart-wrapper">
            <canvas id="twentyFourHourChart"></canvas>
          </div>
        </div>
      
        <div class="chart-container">
          <div class="chart-title">üìÖ 3denn√≠ p≈ôedpovƒõƒè</div>
          <div class="chart-wrapper">
            <canvas id="threeDayChart"></canvas>
          </div>
        </div>

        <div class="chart-container">
          <div class="chart-title">üóìÔ∏è 10denn√≠ p≈ôedpovƒõƒè</div>
          <div class="chart-wrapper">
            <canvas id="tenDayChart"></canvas>
          </div>
        </div>
      </div>
    </div>
    
    <div class="tab-content" id="radar-tab">
      <div class="radar-container">
        <div class="radar-controls">
          <div class="radar-title">üì° Radarov√© odrazy</div>
          <div class="radar-controls-right">
            <div class="radar-speed-control">
              <label for="radarSpeed">Rychlost: <span id="radarSpeedValue">500</span>ms</label>
              <input type="range" id="radarSpeed" min="100" max="1000" step="50" value="500">
            </div>
            <button class="load-btn" id="playRadar">‚ñ∂Ô∏è P≈ôehr√°t animaci</button>
          </div>
        </div>
        
        <div id="radar-map" class="radar-map"></div>
        
        <div class="radar-info">
          <div class="radar-status">
            <div class="status-indicator" id="radar-status"></div>
            <span id="radar-status-text">Inicializace radaru...</span>
          </div>
          <div id="radar-time">ƒåas sn√≠mku: --:--</div>
        </div>
        
        <div class="radar-legend">
          <div class="legend-item">
            <div class="legend-color" style="background-color: rgba(181, 208, 208, 0.8);"></div>
            <span>Slab√© (0.1-1 mm/h)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: rgba(99, 140, 198, 0.8);"></div>
            <span>M√≠rn√© (1-2.5 mm/h)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: rgba(0, 158, 30, 0.8);"></div>
            <span>St≈ôedn√≠ (2.5-10 mm/h)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: rgba(255, 255, 0, 0.8);"></div>
            <span>Siln√© (10-20 mm/h)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: rgba(255, 165, 0, 0.8);"></div>
            <span>Velmi siln√© (20-40 mm/h)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background-color: rgba(255, 0, 0, 0.8);"></div>
            <span>Extr√©mn√≠ (40+ mm/h)</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
  <script>
    // Glob√°ln√≠ promƒõnn√©
    let threeDayChart = null;
    let twentyFourHourChart = null;
    let tenDayChart = null;
    let searchTimeout;
    let selectedSuggestionIndex = -1;
    let currentSuggestions = [];
    let currentLocationData = null;

    // Funkce pro vytvo≈ôen√≠ ≈°rafovan√©ho vzoru
    function createHatchPattern(ctx) {
      const patternCanvas = document.createElement('canvas');
      const patternContext = patternCanvas.getContext('2d');
      
      patternCanvas.width = 10;
      patternCanvas.height = 10;
      
      // Pozad√≠
      patternContext.fillStyle = '#06b6d480';
      patternContext.fillRect(0, 0, 10, 10);
      
      // ≈†rafov√°n√≠
      patternContext.strokeStyle = 'rgba(255, 255, 255, 0.6)';
      patternContext.lineWidth = 2;
      
      patternContext.beginPath();
      patternContext.moveTo(0, 0);
      patternContext.lineTo(10, 10);
      patternContext.stroke();
      
      patternContext.beginPath();
      patternContext.moveTo(10, 0);
      patternContext.lineTo(0, 10);
      patternContext.stroke();
      
      return ctx.createPattern(patternCanvas, 'repeat');
    }

    function getPrecipitationColor(temperature, ctx) {
      if (temperature > 2) {
        return '#06b6d480';
      } else if (temperature >= 0) {
        return createHatchPattern(ctx);
      } else {
        return 'rgba(255, 255, 255, 0.8)';
      }
    }
    
    // Radarov√© promƒõnn√©
    let radarMap = null;
    let radarLayers = [];
    let radarAnimation = null;
    let currentRadarFrame = 0;
    let radarData = [];
    let locationMarker = null;
    let animationSpeed = 500; // V√Ωchoz√≠ rychlost v ms

    // Funkce pro zobrazen√≠ notifikace
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.innerHTML = `
        <span>${message}</span>
        <button onclick="this.parentElement.remove()" style="background:none;border:none;color:white;float:right;cursor:pointer;font-size:1.2rem;">√ó</button>
      `;

      document.body.appendChild(notification);

      setTimeout(() => {
        if (notification.parentElement) {
          notification.remove();
        }
      }, 5000);
    }

    // Funkce pro vyhled√°v√°n√≠ lokac√≠
    async function searchLocations(query) {
      if (query.length < 2) {
        return [];
      }
      try {
        const response = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=10&language=cs&format=json`);
        const data = await response.json();

        if (data.results) {
          return data.results.map(location => ({
            name: location.name,
            country: location.country,
            admin1: location.admin1,
            lat: location.latitude,
            lon: location.longitude,
            displayName: `${location.name}${location.admin1 ? ', ' + location.admin1 : ''}, ${location.country}`
          }));
        }

        return [];
      } catch (error) {
        console.error('Geocoding error:', error);
        // Fallback pro ƒçesk√© mƒõsta
        const czechCities = [
          { name: 'Praha', country: 'ƒåesk√° republika', lat: 50.0755, lon: 14.4378 },
          { name: 'Brno', country: 'ƒåesk√° republika', lat: 49.1951, lon: 16.6068 },
          { name: 'Ostrava', country: 'ƒåesk√° republika', lat: 49.8209, lon: 18.2625 },
          { name: 'Plze≈à', country: 'ƒåesk√° republika', lat: 49.7384, lon: 13.3736 }
        ];

        return czechCities
          .filter(city => city.name.toLowerCase().includes(query.toLowerCase()))
          .map(city => ({
            name: city.name,
            country: city.country,
            lat: city.lat,
            lon: city.lon,
            displayName: `${city.name}, ${city.country}`
          }));
      }
    }

    // Funkce pro zobrazen√≠ n√°vrh≈Ø
    function displaySuggestions(suggestions) {
      const suggestionsDiv = document.getElementById('suggestions');
      currentSuggestions = suggestions;
      selectedSuggestionIndex = -1;

      if (suggestions.length === 0) {
        suggestionsDiv.classList.remove('show');
        return;
      }

      suggestionsDiv.innerHTML = suggestions.map((suggestion, index) => `
        <div class="suggestion-item" data-index="${index}" data-lat="${suggestion.lat}" data-lon="${suggestion.lon}">
          <div class="suggestion-name">${suggestion.name}</div>
          <div class="suggestion-details">${suggestion.displayName}</div>
        </div>
      `).join('');

      suggestionsDiv.classList.add('show');

      suggestionsDiv.querySelectorAll('.suggestion-item').forEach(item => {
        item.addEventListener('click', function() {
          const index = parseInt(this.dataset.index);
          selectSuggestion(index);
        });
      });
    }

    // Funkce pro v√Ωbƒõr n√°vrhu
    function selectSuggestion(index) {
      if (index >= 0 && index < currentSuggestions.length) {
        const suggestion = currentSuggestions[index];
        document.getElementById('location').value = suggestion.displayName;
        document.getElementById('suggestions').classList.remove('show');
        selectedSuggestionIndex = -1;
        
        currentLocationData = {
          displayName: suggestion.displayName,
          lat: suggestion.lat,
          lon: suggestion.lon,
          name: suggestion.name,
          country: suggestion.country,
          admin1: suggestion.admin1
        };
        
        loadWeather();
      }
    }

    function highlightSuggestion(index) {
      const suggestions = document.querySelectorAll('.suggestion-item');
      suggestions.forEach(item => item.classList.remove('selected'));

      if (index >= 0 && index < suggestions.length) {
        suggestions[index].classList.add('selected');
        selectedSuggestionIndex = index;
      }
    }

    function showLoading() {
      document.getElementById('loading').style.display = 'block';
      document.getElementById('error').style.display = 'none';
      document.getElementById('chartsSection').style.display = 'none';
    }

    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }

    function showError(message) {
      const errorDiv = document.getElementById('error');
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
      hideLoading();
    }

    function showWeatherData() {
      document.getElementById('chartsSection').style.display = 'block';
      hideLoading();
    }

    async function getCoordinates(location) {
      if (currentLocationData && currentLocationData.displayName === location) {
        return { lat: currentLocationData.lat, lon: currentLocationData.lon };
      }

      const coordPattern = /^-?\d+\.?\d*,-?\d+\.?\d*$/;
      if (coordPattern.test(location)) {
        const [lat, lon] = location.split(',').map(Number);
        return { lat, lon };
      }
      
      if (currentSuggestions.length > 0) {
        const matchingSuggestion = currentSuggestions.find(s =>
          s.displayName === location || s.name === location
        );
        if (matchingSuggestion) {
          currentLocationData = matchingSuggestion;
          return { lat: matchingSuggestion.lat, lon: matchingSuggestion.lon };
        }
      }
      
      try {
        const locations = await searchLocations(location);
        if (locations.length > 0) {
          currentLocationData = locations[0];
          return { lat: locations[0].lat, lon: locations[0].lon };
        } else {
          throw new Error('Lokace nebyla nalezena');
        }
      } catch (error) {
        console.warn('Geocoding failed, using Prague coordinates:', error);
        currentLocationData = {
          displayName: 'Praha, ƒåesk√° republika',
          lat: 50.0755,
          lon: 14.4378,
          name: 'Praha',
          country: 'ƒåesk√° republika'
        };
        return { lat: 50.0755, lon: 14.4378 };
      }
    }

    async function loadWeather() {
      showLoading();

      try {
        const input = document.getElementById('location').value.trim();
        if (!input) {
          showError('Pros√≠m zadejte mƒõsto nebo sou≈ôadnice');
          return;
        }
        
        const coords = await getCoordinates(input);
        
        if (currentLocationData && currentLocationData.displayName !== input) {
          document.getElementById('location').value = currentLocationData.displayName;
        }
        
        document.getElementById('saveLocationBtn').style.display = 'block';
        
        const hourlyParams = [
          'temperature_2m', 'precipitation', 'wind_speed_10m', 'wind_direction_10m', 'cloud_cover', 'relative_humidity_2m'
        ].join(',');

        const hourlyUrl = `https://api.open-meteo.com/v1/forecast?latitude=${coords.lat}&longitude=${coords.lon}&hourly=${hourlyParams}&timezone=Europe%2FPrague&forecast_days=3`;
        
        const dailyParams = [
          'temperature_2m_max', 'temperature_2m_min', 'precipitation_sum', 'wind_speed_10m_max', 
          'wind_direction_10m_dominant', 'cloud_cover_mean'
        ].join(',');

        const dailyUrl = `https://api.open-meteo.com/v1/forecast?latitude=${coords.lat}&longitude=${coords.lon}&daily=${dailyParams}&timezone=Europe%2FPrague&forecast_days=10`;
        
        const [hourlyResponse, dailyResponse] = await Promise.all([
          fetch(hourlyUrl),
          fetch(dailyUrl)
        ]);
        
        if (!hourlyResponse.ok || !dailyResponse.ok) {
          throw new Error('Chyba p≈ôi naƒç√≠t√°n√≠ dat z API');
        }

        const hourly3DayData = await hourlyResponse.json();
        const daily10DayData = await dailyResponse.json();
        
        if (!hourly3DayData.hourly || !daily10DayData.daily) {
          throw new Error('Neplatn√° odpovƒõƒè z API');
        }
        
        // Zpracov√°n√≠ dat
        const hourlyTime = hourly3DayData.hourly.time;
        const hourlyTemp = hourly3DayData.hourly.temperature_2m;
        const hourlyPrecip = hourly3DayData.hourly.precipitation;
        const hourlyWind = hourly3DayData.hourly.wind_speed_10m.map(speed => Math.round(speed / 3.6 * 10) / 10);
        const hourlyWindDir = hourly3DayData.hourly.wind_direction_10m;
        const hourlyClouds = hourly3DayData.hourly.cloud_cover;
        
        updateThreeDayChart('threeDayChart', hourlyTime, hourlyTemp, hourlyPrecip, hourlyWind, hourlyWindDir, hourlyClouds);
        
        const now = new Date();
        const twentyFourHoursLater = new Date(now.getTime() + 24 * 60 * 60 * 1000);

        const twentyFourHourIndices = [];
        for (let i = 0; i < hourlyTime.length; i++) {
          const dataTime = new Date(hourlyTime[i]);
          if (dataTime >= now && dataTime <= twentyFourHoursLater) {
            twentyFourHourIndices.push(i);
          }
        }

        const twentyFourHourTime = twentyFourHourIndices.map(i => hourlyTime[i]);
        const twentyFourHourTemp = twentyFourHourIndices.map(i => hourlyTemp[i]);
        const twentyFourHourPrecip = twentyFourHourIndices.map(i => hourlyPrecip[i]);
        const twentyFourHourWind = twentyFourHourIndices.map(i => hourlyWind[i]);
        const twentyFourHourWindDir = twentyFourHourIndices.map(i => hourlyWindDir[i]);
        const twentyFourHourClouds = twentyFourHourIndices.map(i => hourlyClouds[i]);

        updateTwentyFourHourChart(
          'twentyFourHourChart',
          twentyFourHourTime,
          twentyFourHourTemp,
          twentyFourHourPrecip,
          twentyFourHourWind,
          twentyFourHourWindDir,
          twentyFourHourClouds
        );
        
        const dailyTime = daily10DayData.daily.time;
        const dailyTempMax = daily10DayData.daily.temperature_2m_max;
        const dailyTempMin = daily10DayData.daily.temperature_2m_min;
        const dailyPrecip = daily10DayData.daily.precipitation_sum;
        const dailyWind = daily10DayData.daily.wind_speed_10m_max.map(speed => Math.round(speed / 3.6 * 10) / 10);
        const dailyWindDir = daily10DayData.daily.wind_direction_10m_dominant;
        const dailyClouds = daily10DayData.daily.cloud_cover_mean;
        
        updateTenDayChart(
          'tenDayChart',
          dailyTime,
          dailyTempMax,
          dailyTempMin,
          dailyPrecip,
          dailyWind,
          dailyWindDir,
          dailyClouds
        );
        
        showWeatherData();
        showNotification(`P≈ôedpovƒõƒè naƒçtena pro: ${currentLocationData?.displayName || 'nezn√°mou lokaci'}`, 'success');

      } catch (error) {
        console.error('Chyba:', error);
        showError(`Chyba p≈ôi naƒç√≠t√°n√≠ p≈ôedpovƒõdi: ${error.message}`);
      }
    }

    function updateThreeDayChart(canvasId, time, temp, precip, wind, windDir, clouds) {
      const canvas = document.getElementById(canvasId);

      if (threeDayChart) {
        threeDayChart.destroy();
      }
      const ctx = canvas.getContext('2d');

      const hours72 = Math.min(72, time.length);
      const labels = [];
      const tempData = [];
      const precipData = [];
      const windData = [];
      const windDirData = [];
      const cloudsData = [];

      for (let i = 0; i < hours72; i += 3) {
        const date = new Date(time[i]);
        const hour = date.getHours();

        if (hour === 0) {
          labels.push(date.toLocaleDateString('cs-CZ', {
            weekday: 'short',
            day: 'numeric',
            month: 'numeric'
          }));
        } else {
          labels.push(hour.toString().padStart(2, '0') + ':00');
        }

        tempData.push(temp[i]);
        windData.push(wind[i]);
        windDirData.push(windDir[i]);
        cloudsData.push(clouds[i]);
        
        let totalPrecip = 0;
        for (let j = 0; j < 3 && (i + j) < hours72; j++) {
          totalPrecip += precip[i + j];
        }
        precipData.push(totalPrecip);
      }

      const windArrowPlugin = {
        id: 'windArrows',
        afterDatasetsDraw: (chart) => {
          const ctx = chart.ctx;
          const meta = chart.getDatasetMeta(2);
          if (!meta || !meta.data) return;
          ctx.save();
          ctx.strokeStyle = '#4ecdc4';
          ctx.fillStyle = '#4ecdc4';
          ctx.lineWidth = 2;
          meta.data.forEach((point, index) => {
            const windSpeed = windData[index];
            const windDirection = windDirData[index];
            if (windSpeed > 1 && windDirection !== undefined && windDirection !== null) {
              const x = point.x;
              const y = point.y;
              const arrowSize = Math.min(20, Math.max(10, windSpeed * 2));
              ctx.save();
              ctx.translate(x, y - 15);
              const rotation = ((windDirection + 180) * Math.PI) / 180;
              ctx.rotate(rotation);
              ctx.beginPath();
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(0, arrowSize/2);
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(-arrowSize/4, -arrowSize/4);
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(arrowSize/4, -arrowSize/4);
              ctx.stroke();
              ctx.restore();
            }
          });
          ctx.restore();
        }
      };

      const currentTimePlugin = {
        id: 'currentTimeLine',
        afterDatasetsDraw: (chart) => {
          const ctx = chart.ctx;
          const chartArea = chart.chartArea;
          const now = new Date();
          let currentTimeIndex = -1;
          const currentTimeMs = now.getTime();
          for (let i = 0; i < time.length; i += 3) {
            const dataTimeMs = new Date(time[i]).getTime();
            if (dataTimeMs <= currentTimeMs && (i + 3 >= time.length || new Date(time[i + 3]).getTime() > currentTimeMs)) {
              if (i + 3 < time.length) {
                const nextTimeMs = new Date(time[i + 3]).getTime();
                const timeDiff = nextTimeMs - dataTimeMs;
                const currentDiff = currentTimeMs - dataTimeMs;
                const ratio = currentDiff / timeDiff;
                currentTimeIndex = (i / 3) + ratio;
              } else {
                currentTimeIndex = i / 3;
              }
              break;
            }
          }
          if (currentTimeIndex >= 0 && currentTimeIndex < labels.length) {
            const xScale = chart.scales.x;
            const x = xScale.getPixelForValue(currentTimeIndex);
            if (x >= chartArea.left && x <= chartArea.right) {
              ctx.save();
              ctx.strokeStyle = '#ff9800';
              ctx.lineWidth = 3;
              ctx.setLineDash([5, 5]);
              ctx.beginPath();
              ctx.moveTo(x, chartArea.top);
              ctx.lineTo(x, chartArea.bottom);
              ctx.stroke();
              ctx.fillStyle = '#ff9800';
              ctx.font = 'bold 12px sans-serif';
              ctx.textAlign = 'center';
              const timeText = now.toLocaleTimeString('cs-CZ', { 
                hour: '2-digit', 
                minute: '2-digit' 
              });
              ctx.fillText(timeText, x, chartArea.top - 5);
              ctx.restore();
            }
          }
        }
      };

      threeDayChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Teplota (¬∞C)',
              data: tempData,
              borderColor: '#ff6b6b',
              backgroundColor: '#ff6b6b20',
              borderWidth: 3,
              fill: false,
              tension: 0.4,
              yAxisID: 'y',
              pointRadius: 4,
              pointHoverRadius: 6,
              pointBackgroundColor: tempData.map(t => t < 0 ? '#4a9eff' : '#ff6b6b'),
              pointBorderColor: tempData.map(t => t < 0 ? '#4a9eff' : '#ff6b6b'),
              segment: {
                borderColor: ctx => {
                  const p0 = ctx.p0.parsed.y;
                  const p1 = ctx.p1.parsed.y;
                  if (p0 < 0 && p1 < 0) return '#4a9eff';
                  if (p0 >= 0 && p1 >= 0) return '#ff6b6b';
                  return p0 > p1 ? '#ff6b6b' : '#4a9eff';
                }
              }
            },
            {
              label: 'Sr√°≈æky (mm)',
              data: precipData,
              type: 'bar',
              backgroundColor: function(context) {
                const index = context.dataIndex;
                const temperature = tempData[index];
                return getPrecipitationColor(temperature, context.chart.ctx);
              },
              borderColor: function(context) {
                const index = context.dataIndex;
                const temperature = tempData[index];
                if (temperature > 2) {
                  return '#06b6d4';
                } else if (temperature >= 0) {
                  return '#06b6d4';
                } else {
                  return 'rgba(200, 200, 200, 0.8)';
                }
              },
              borderWidth: 1,
              yAxisID: 'y1'
            },
            {
              label: 'Rychlost vƒõtru (m/s)',
              data: windData,
              borderColor: '#4ecdc4',
              backgroundColor: '#4ecdc420',
              borderWidth: 2,
              fill: false,
              tension: 0.4,
              yAxisID: 'y2',
              pointRadius: 3,
              pointHoverRadius: 5
            },
            {
              label: 'Oblaƒçnost (%)',
              data: cloudsData,
              borderColor: '#6b7280',
              backgroundColor: '#6b728020',
              borderWidth: 2,
              fill: true,
              tension: 0.4,
              yAxisID: 'y3',
              pointRadius: 2,
              pointHoverRadius: 4
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: { padding: { top: 50 } },
          plugins: {
            legend: { position: 'bottom', labels: { color: '#e2e8f0', font: { size: 12 }, padding: 20, usePointStyle: true, pointStyle: 'circle' } },
            tooltip: {
              backgroundColor: 'rgba(0,0,0,0.8)',
              titleColor: '#e2e8f0',
              bodyColor: '#e2e8f0',
              borderColor: '#6aa6fd',
              borderWidth: 1,
              callbacks: {
                afterBody: function(tooltipItems) {
                  const index = tooltipItems[0].dataIndex;
                  const windSpeed = windData[index];
                  const windDirection = windDirData[index];
                  const tooltipLines = [];
                  if (windSpeed > 0 && windDirection !== undefined) {
                    const directions = ['S', 'SSV', 'SV', 'VSV', 'V', 'VJV', 'JV', 'JJV', 'J', 'JJZ', 'JZ', 'ZJZ', 'Z', 'ZSZ', 'SZ', 'SSZ'];
                    const dirIndex = Math.round(windDirection / 22.5) % 16;
                    const dirText = directions[dirIndex];
                    tooltipLines.push(`üß≠ Smƒõr vƒõtru: ${dirText} (${Math.round(windDirection)}¬∞)`);
                  }
                  return tooltipLines;
                }
              }
            }
          },
          scales: {
            x: { ticks: { color: '#94a3b8', font: { size: 11 } }, grid: { color: 'rgba(148, 163, 184, 0.1)', lineWidth: 1 } },
            y: { type: 'linear', display: true, position: 'left', ticks: { color: '#ff6b6b', callback: function(value) { return value + '¬∞C'; } }, grid: { color: context => context.tick.value === 0 ? '#ff9800' : '#404040', lineWidth: context => context.tick.value === 0 ? 2 : 1 }, title: { display: true, text: 'Teplota (¬∞C)', color: '#ff6b6b' } },
            y1: { type: 'linear', display: true, position: 'right', min: 0, ticks: { color: '#06b6d4', callback: function(value) { return value + 'mm'; } }, grid: { drawOnChartArea: false }, title: { display: true, text: 'Sr√°≈æky (mm)', color: '#06b6d4' } },
            y2: { type: 'linear', display: true, position: 'right', min: 0, ticks: { color: '#4ecdc4', callback: function(value) { return value + 'm/s'; } }, grid: { drawOnChartArea: false }, title: { display: true, text: 'Rychlost vƒõtru (m/s)', color: '#4ecdc4' } },
            y3: { type: 'linear', display: true, position: 'right', min: 0, max: 100, ticks: { color: '#6b7280', callback: function(value) { return value + '%'; } }, grid: { drawOnChartArea: false }, title: { display: true, text: 'Oblaƒçnost (%)', color: '#6b7280' } }
          }
        },
        plugins: [windArrowPlugin, currentTimePlugin]
      });
    }

    function updateTwentyFourHourChart(canvasId, time, temp, precip, wind, windDir, clouds) {
      const canvas = document.getElementById(canvasId);

      if (twentyFourHourChart) {
        twentyFourHourChart.destroy();
      }
      const ctx = canvas.getContext('2d');

      const labels = [];
      const tempData = [];
      const precipData = [];
      const windData = [];
      const windDirData = [];
      const cloudsData = [];

      for (let i = 0; i < time.length; i++) {
        const date = new Date(time[i]);
        labels.push(date.toLocaleTimeString('cs-CZ', {
          hour: '2-digit',
          minute: '2-digit'
        }));
        tempData.push(temp[i]);
        precipData.push(precip[i]);
        windData.push(wind[i]);
        windDirData.push(windDir[i]);
        cloudsData.push(clouds[i]);
      }

      const windArrowPlugin = {
        id: 'windArrows24',
        afterDatasetsDraw: (chart) => {
          const ctx = chart.ctx;
          const meta = chart.getDatasetMeta(2);
          if (!meta || !meta.data) return;
          ctx.save();
          ctx.strokeStyle = '#4ecdc4';
          ctx.fillStyle = '#4ecdc4';
          ctx.lineWidth = 2;
          meta.data.forEach((point, index) => {
            const windSpeed = windData[index];
            const windDirection = windDirData[index];
            if (windSpeed > 1 && windDirection !== undefined && windDirection !== null) {
              const x = point.x;
              const y = point.y;
              const arrowSize = Math.min(20, Math.max(10, windSpeed * 2));
              ctx.save();
              ctx.translate(x, y - 15);
              const rotation = ((windDirection + 180) * Math.PI) / 180;
              ctx.rotate(rotation);
              ctx.beginPath();
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(0, arrowSize/2);
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(-arrowSize/4, -arrowSize/4);
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(arrowSize/4, -arrowSize/4);
              ctx.stroke();
              ctx.restore();
            }
          });
          ctx.restore();
        }
      };

      const currentTimePlugin = {
        id: 'currentTimeLine24',
        afterDatasetsDraw: (chart) => {
          const ctx = chart.ctx;
          const chartArea = chart.chartArea;
          const now = new Date();
          let currentTimeIndex = -1;
          const currentTimeMs = now.getTime();
          for (let i = 0; i < time.length; i++) {
            const dataTimeMs = new Date(time[i]).getTime();
            if (dataTimeMs <= currentTimeMs && (i + 1 >= time.length || new Date(time[i + 1]).getTime() > currentTimeMs)) {
              if (i + 1 < time.length) {
                const nextTimeMs = new Date(time[i + 1]).getTime();
                const timeDiff = nextTimeMs - dataTimeMs;
                const currentDiff = currentTimeMs - dataTimeMs;
                const ratio = currentDiff / timeDiff;
                currentTimeIndex = i + ratio;
              } else {
                currentTimeIndex = i;
              }
              break;
            }
          }
          if (currentTimeIndex >= 0 && currentTimeIndex < labels.length) {
            const xScale = chart.scales.x;
            const x = xScale.getPixelForValue(currentTimeIndex);
            if (x >= chartArea.left && x <= chartArea.right) {
              ctx.save();
              ctx.strokeStyle = '#ff9800';
              ctx.lineWidth = 3;
              ctx.setLineDash([5, 5]);
              ctx.beginPath();
              ctx.moveTo(x, chartArea.top);
              ctx.lineTo(x, chartArea.bottom);
              ctx.stroke();
              ctx.fillStyle = '#ff9800';
              ctx.font = 'bold 12px sans-serif';
              ctx.textAlign = 'center';
              ctx.fillText('NYN√ç', x, chartArea.top - 5);
              ctx.restore();
            }
          }
        }
      };

      twentyFourHourChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Teplota (¬∞C)',
              data: tempData,
              borderColor: '#ff6b6b',
              backgroundColor: '#ff6b6b20',
              borderWidth: 3,
              fill: false,
              tension: 0.4,
              yAxisID: 'y',
              pointRadius: 4,
              pointHoverRadius: 6,
              pointBackgroundColor: tempData.map(t => t < 0 ? '#4a9eff' : '#ff6b6b'),
              pointBorderColor: tempData.map(t => t < 0 ? '#4a9eff' : '#ff6b6b'),
              segment: {
                borderColor: ctx => {
                  const p0 = ctx.p0.parsed.y;
                  const p1 = ctx.p1.parsed.y;
                  if (p0 < 0 && p1 < 0) return '#4a9eff';
                  if (p0 >= 0 && p1 >= 0) return '#ff6b6b';
                  return p0 > p1 ? '#ff6b6b' : '#4a9eff';
                }
              }
            },
            {
              label: 'Sr√°≈æky (mm)',
              data: precipData,
              type: 'bar',
              backgroundColor: function(context) {
                const index = context.dataIndex;
                const temperature = tempData[index];
                return getPrecipitationColor(temperature, context.chart.ctx);
              },
              borderColor: function(context) {
                const index = context.dataIndex;
                const temperature = tempData[index];
                if (temperature > 2) {
                  return '#06b6d4';
                } else if (temperature >= 0) {
                  return '#06b6d4';
                } else {
                  return 'rgba(200, 200, 200, 0.8)';
                }
              },
              borderWidth: 1,
              yAxisID: 'y1'
            },
            {
              label: 'Rychlost vƒõtru (m/s)',
              data: windData,
              borderColor: '#4ecdc4',
              backgroundColor: '#4ecdc420',
              borderWidth: 2,
              fill: false,
              tension: 0.4,
              yAxisID: 'y2',
              pointRadius: 3,
              pointHoverRadius: 5
            },
            {
              label: 'Oblaƒçnost (%)',
              data: cloudsData,
              borderColor: '#6b7280',
              backgroundColor: '#6b728020',
              borderWidth: 2,
              fill: true,
              tension: 0.4,
              yAxisID: 'y3',
              pointRadius: 2,
              pointHoverRadius: 4
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: { padding: { top: 40 } },
          plugins: {
            legend: { position: 'bottom', labels: { color: '#e2e8f0', font: { size: 12 }, padding: 20, usePointStyle: true, pointStyle: 'circle' } },
            tooltip: {
              backgroundColor: 'rgba(0,0,0,0.8)',
              titleColor: '#e2e8f0',
              bodyColor: '#e2e8f0',
              borderColor: '#6aa6fd',
              borderWidth: 1,
              callbacks: {
                afterBody: function(tooltipItems) {
                  const index = tooltipItems[0].dataIndex;
                  const windSpeed = windData[index];
                  const windDirection = windDirData[index];
                  const tooltipLines = [];
                  if (windSpeed > 0 && windDirection !== undefined) {
                    const directions = ['S', 'SSV', 'SV', 'VSV', 'V', 'VJV', 'JV', 'JJV', 'J', 'JJZ', 'JZ', 'ZJZ', 'Z', 'ZSZ', 'SZ', 'SSZ'];
                    const dirIndex = Math.round(windDirection / 22.5) % 16;
                    const dirText = directions[dirIndex];
                    tooltipLines.push(`üß≠ Smƒõr vƒõtru: ${dirText} (${Math.round(windDirection)}¬∞)`);
                  }
                  return tooltipLines;
                }
              }
            }
          },
          scales: {
            x: { ticks: { color: '#94a3b8', font: { size: 11 } }, grid: { color: 'rgba(148, 163, 184, 0.1)', lineWidth: 1 } },
            y: { type: 'linear', display: true, position: 'left', ticks: { color: '#ff6b6b', callback: function(value) { return value + '¬∞C'; } }, grid: { color: context => context.tick.value === 0 ? '#ff9800' : '#404040', lineWidth: context => context.tick.value === 0 ? 2 : 1 }, title: { display: true, text: 'Teplota (¬∞C)', color: '#ff6b6b' } },
            y1: { type: 'linear', display: true, position: 'right', min: 0, ticks: { color: '#06b6d4', callback: function(value) { return value + 'mm'; } }, grid: { drawOnChartArea: false }, title: { display: true, text: 'Sr√°≈æky (mm)', color: '#06b6d4' } },
            y2: { type: 'linear', display: true, position: 'right', min: 0, ticks: { color: '#4ecdc4', callback: function(value) { return value + 'm/s'; } }, grid: { drawOnChartArea: false }, title: { display: true, text: 'Rychlost vƒõtru (m/s)', color: '#4ecdc4' } },
            y3: { type: 'linear', display: true, position: 'right', min: 0, max: 100, ticks: { color: '#6b7280', callback: function(value) { return value + '%'; } }, grid: { drawOnChartArea: false }, title: { display: true, text: 'Oblaƒçnost (%)', color: '#6b7280' } }
          }
        },
        plugins: [windArrowPlugin, currentTimePlugin]
      });
    }

    function updateTenDayChart(canvasId, time, tempMax, tempMin, precip, wind, windDir, clouds) {
      const canvas = document.getElementById(canvasId);

      if (tenDayChart) {
        tenDayChart.destroy();
      }
      const ctx = canvas.getContext('2d');

      const labels = time.map(dateStr => {
        const date = new Date(dateStr);
        return date.toLocaleDateString('cs-CZ', {
          weekday: 'short',
          day: 'numeric',
          month: 'numeric'
        });
      });

      const windArrowPlugin = {
        id: 'windArrows10',
        afterDatasetsDraw: (chart) => {
          const ctx = chart.ctx;
          const meta = chart.getDatasetMeta(3);
          if (!meta || !meta.data) return;
          ctx.save();
          ctx.strokeStyle = '#4ecdc4';
          ctx.fillStyle = '#4ecdc4';
          ctx.lineWidth = 2;
          meta.data.forEach((point, index) => {
            const windSpeed = wind[index];
            const windDirection = windDir[index];
            if (windSpeed > 1 && windDirection !== undefined && windDirection !== null) {
              const x = point.x;
              const y = point.y;
              const arrowSize = Math.min(20, Math.max(10, windSpeed * 2));
              ctx.save();
              ctx.translate(x, y - 15);
              const rotation = ((windDirection + 180) * Math.PI) / 180;
              ctx.rotate(rotation);
              ctx.beginPath();
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(0, arrowSize/2);
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(-arrowSize/4, -arrowSize/4);
              ctx.moveTo(0, -arrowSize/2);
              ctx.lineTo(arrowSize/4, -arrowSize/4);
              ctx.stroke();
              ctx.restore();
            }
          });
          ctx.restore();
        }
      };

      tenDayChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Maxim√°ln√≠ teplota (¬∞C)',
              data: tempMax,
              borderColor: '#ff6b6b',
              backgroundColor: '#ff6b6b20',
              borderWidth: 3,
              fill: false,
              tension: 0.4,
              yAxisID: 'y',
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: 'Minim√°ln√≠ teplota (¬∞C)',
              data: tempMin,
              borderColor: '#6aa6fd',
              backgroundColor: '#6aa6fd20',
              borderWidth: 3,
              fill: false,
              tension: 0.4,
              yAxisID: 'y',
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: 'Sr√°≈æky (mm)',
              data: precip,
              type: 'bar',
              backgroundColor: function(context) {
                const index = context.dataIndex;
                const avgTemp = (tempMax[index] + tempMin[index]) / 2;
                return getPrecipitationColor(avgTemp, context.chart.ctx);
              },
              borderColor: function(context) {
                const index = context.dataIndex;
                const avgTemp = (tempMax[index] + tempMin[index]) / 2;
                if (avgTemp > 2) {
                  return '#06b6d4';
                } else if (avgTemp >= 0) {
                  return '#06b6d4';
                } else {
                  return 'rgba(200, 200, 200, 0.8)';
                }
              },
              borderWidth: 1,
              yAxisID: 'y1'
            },
            {
              label: 'Rychlost vƒõtru (m/s)',
              data: wind,
              borderColor: '#4ecdc4',
              backgroundColor: '#4ecdc420',
              borderWidth: 2,
              fill: false,
              tension: 0.4,
              yAxisID: 'y2',
              pointRadius: 3,
              pointHoverRadius: 5
            },
            {
              label: 'Oblaƒçnost (%)',
              data: clouds,
              borderColor: '#6b7280',
              backgroundColor: '#6b728020',
              borderWidth: 2,
              fill: true,
              tension: 0.4,
              yAxisID: 'y3',
              pointRadius: 2,
              pointHoverRadius: 4
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          layout: { padding: { top: 50 } },
          plugins: {
            legend: { position: 'bottom', labels: { color: '#e2e8f0', font: { size: 12 }, padding: 20, usePointStyle: true, pointStyle: 'circle' } },
            tooltip: {
              backgroundColor: 'rgba(0,0,0,0.8)',
              titleColor: '#e2e8f0',
              bodyColor: '#e2e8f0',
              borderColor: '#6aa6fd',
              borderWidth: 1,
              callbacks: {
                afterBody: function(tooltipItems) {
                  const index = tooltipItems[0].dataIndex;
                  const windSpeed = wind[index];
                  const windDirection = windDir[index];
                  const cloudCover = clouds[index];
                  const tooltipLines = [];
                  if (windSpeed > 0 && windDirection !== undefined) {
                    const directions = ['S', 'SSV', 'SV', 'VSV', 'V', 'VJV', 'JV', 'JJV', 'J', 'JJZ', 'JZ', 'ZJZ', 'Z', 'ZSZ', 'SZ', 'SSZ'];
                    const dirIndex = Math.round(windDirection / 22.5) % 16;
                    const dirText = directions[dirIndex];
                    tooltipLines.push(`üß≠ Smƒõr vƒõtru: ${dirText} (${Math.round(windDirection)}¬∞)`);
                  }
                  if (cloudCover !== undefined) {
                    tooltipLines.push(`‚òÅÔ∏è Oblaƒçnost: ${Math.round(cloudCover)}%`);
                  }
                  return tooltipLines;
                }
              }
            }
          },
          scales: {
            x: { ticks: { color: '#94a3b8', font: { size: 11 } }, grid: { color: 'rgba(148, 163, 184, 0.1)', lineWidth: 1 } },
            y: { type: 'linear', display: true, position: 'left', ticks: { color: '#ff6b6b', callback: function(value) { return value + '¬∞C'; } }, grid: { color: context => context.tick.value === 0 ? '#ff9800' : '#404040', lineWidth: context => context.tick.value === 0 ? 2 : 1 }, title: { display: true, text: 'Teplota (¬∞C)', color: '#ff6b6b' } },
            y1: { type: 'linear', display: true, position: 'right', min: 0, ticks: { color: '#06b6d4', callback: function(value) { return value + 'mm'; } }, grid: { drawOnChartArea: false }, title: { display: true, text: 'Sr√°≈æky (mm)', color: '#06b6d4' } },
            y2: { type: 'linear', display: true, position: 'right', min: 0, ticks: { color: '#4ecdc4', callback: function(value) { return value + 'm/s'; } }, grid: { drawOnChartArea: false }, title: { display: true, text: 'Rychlost vƒõtru (m/s)', color: '#4ecdc4' } },
            y3: { type: 'linear', display: true, position: 'right', min: 0, max: 100, ticks: { color: '#6b7280', callback: function(value) { return value + '%'; } }, grid: { drawOnChartArea: false }, title: { display: true, text: 'Oblaƒçnost (%)', color: '#6b7280' } }
          }
        },
        plugins: [windArrowPlugin]
      });
    }

    function saveLocation() {
      if (currentLocationData) {
        localStorage.setItem('savedLocation', JSON.stringify(currentLocationData));
        showNotification('Lokace ulo≈æena', 'success');
        updateSavedLocationInfo();
      }
    }

    function loadSavedLocation() {
      const saved = localStorage.getItem('savedLocation');
      if (saved) {
        try {
          currentLocationData = JSON.parse(saved);
          document.getElementById('location').value = currentLocationData.displayName;
          updateSavedLocationInfo();
          return true;
        } catch (e) {
          console.error('Error parsing saved location:', e);
          localStorage.removeItem('savedLocation');
        }
      }
      return false;
    }

    function updateSavedLocationInfo() {
      const savedLocationInfo = document.getElementById('savedLocationInfo');
      if (localStorage.getItem('savedLocation')) {
        savedLocationInfo.style.display = 'flex';
      } else {
        savedLocationInfo.style.display = 'none';
      }
    }

    const PlusIcon = L.Icon.extend({
      options: {
        iconUrl: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="red" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather feather-plus"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>',
        iconSize: [24, 24],
        iconAnchor: [12, 12],
        popupAnchor: [0, 0]
      }
    });
    const plusIcon = new PlusIcon();

    // ---------------------------------------------------------
    // VYLEP≈†EN√Å IMPLEMENTACE RADARU
    // ---------------------------------------------------------

    function initRadar() {
      const czechRepublicBounds = [
        [48.5, 12.0],
        [51.5, 19.0]
      ];

      if (radarMap) {
        radarMap.remove();
      }
      
      radarMap = L.map('radar-map');

      radarMap.fitBounds(czechRepublicBounds, {
          padding: [20, 20]
      });
      
      if (currentLocationData) {
        if (locationMarker) {
            locationMarker.remove();
        }
        locationMarker = L.marker([currentLocationData.lat, currentLocationData.lon], { icon: plusIcon }).addTo(radarMap);
      }
      
      const baseLayers = {
        'Topografick√° mapa': L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
          attribution: '¬© OpenTopoMap contributors, SRTM | Map style: ¬© OpenTopoMap (CC-BY-SA)',
          maxZoom: 17
        }),
        'OpenStreetMap': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '¬© OpenStreetMap contributors',
          maxZoom: 18
        })
      };

      baseLayers['Topografick√° mapa'].addTo(radarMap);
      L.control.layers(baseLayers).addTo(radarMap);
      
      loadRadarData();
    }

    async function loadRadarData() {
      updateRadarStatus('loading', 'Naƒç√≠t√°m a p≈ôedp≈ôipravuji data...');
      
      try {
        const response = await fetch('https://api.rainviewer.com/public/weather-maps.json');
        const data = await response.json();
        
        if (!data.radar || !data.radar.past) {
          throw new Error('Neplatn√° odpovƒõƒè z API');
        }
        
        radarLayers.forEach(layer => {
            if (radarMap.hasLayer(layer)) radarMap.removeLayer(layer);
        });
        radarLayers = [];

        radarData = data.radar.past.slice(-12);
        
        const layerPromises = radarData.map((frame, index) => {
          return new Promise((resolve) => {
            const tileUrl = `https://tilecache.rainviewer.com/v2/radar/${frame.time}/256/{z}/{x}/{y}/2/1_1.png`;
            
            const layer = L.tileLayer(tileUrl, {
              opacity: 0,
              attribution: 'Radarov√° data: RainViewer',
              className: 'radar-layer',
              zIndex: 100 + index
            });

            layer.on('load', resolve); 
            setTimeout(resolve, 2000);

            layer.addTo(radarMap);
            radarLayers.push(layer);
          });
        });
        
        await Promise.all(layerPromises);

        if (radarLayers.length > 0) {
          currentRadarFrame = radarLayers.length - 1;
          radarLayers.forEach((layer, index) => {
             layer.setOpacity(index === currentRadarFrame ? 0.7 : 0);
          });
          
          const frameTime = new Date(radarData[currentRadarFrame].time * 1000);
          document.getElementById('radar-time').textContent = `ƒåas sn√≠mku: ${frameTime.toLocaleTimeString('cs-CZ')}`;
        }
        
        updateRadarStatus('online', 'Radar p≈ôipraven');
        
      } catch (error) {
        console.error('Chyba p≈ôi naƒç√≠t√°n√≠ radarov√Ωch dat:', error);
        updateRadarStatus('error', 'Chyba naƒç√≠t√°n√≠ dat');
        showNotification('Nepoda≈ôilo se naƒç√≠st radarov√° data', 'error');
      }
    }

    function showRadarFrame(frameIndex) {
      if (!radarLayers[frameIndex]) return;
      
      radarLayers.forEach((layer, index) => {
        if (index === frameIndex) {
            layer.setOpacity(0.7);
        } else {
            layer.setOpacity(0);
        }
      });

      const frameTime = new Date(radarData[frameIndex].time * 1000);
      document.getElementById('radar-time').textContent = `ƒåas sn√≠mku: ${frameTime.toLocaleTimeString('cs-CZ')}`;
    }

    function playRadarAnimation() {
      const playButton = document.getElementById('playRadar');
      
      if (radarAnimation) {
        clearInterval(radarAnimation);
        radarAnimation = null;
        playButton.textContent = '‚ñ∂Ô∏è P≈ôehr√°t animaci';
        updateRadarStatus('online', 'Animace zastavena');
        
        showRadarFrame(radarLayers.length - 1);
        currentRadarFrame = radarLayers.length - 1;
        return;
      }
      
      if (radarLayers.length === 0) {
        showNotification('Nejsou dostupn√° ≈æ√°dn√° data', 'error');
        return;
      }
      
      playButton.textContent = '‚èπÔ∏è Zastavit animaci';
      updateRadarStatus('loading', 'P≈ôehr√°v√°m smyƒçku...');
      
      let frameIndex = 0; 

      showRadarFrame(frameIndex);

      // Spu≈°tƒõn√≠ intervalu s aktu√°ln√≠ rychlost√≠
      radarAnimation = setInterval(() => {
        frameIndex = (frameIndex + 1) % radarLayers.length;
        showRadarFrame(frameIndex);
      }, animationSpeed); 
    }

    function updateRadarStatus(status, message) {
      const statusIndicator = document.getElementById('radar-status');
      const statusText = document.getElementById('radar-status-text');
      
      statusIndicator.className = 'status-indicator';
      
      if (status === 'loading') {
        statusIndicator.classList.add('loading');
      } else if (status === 'error') {
        statusIndicator.classList.add('error');
      }
      
      statusText.textContent = message;
    }

    function switchTab(tabName) {
      document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
      });
      
      document.getElementById(`${tabName}-tab`).classList.add('active');
      
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      
      document.querySelector(`.tab[data-tab="${tabName}"]`).classList.add('active');
      
      if (tabName === 'radar' && !radarMap) {
        setTimeout(initRadar, 100);
      }
      
      if (tabName === 'radar' && radarMap && currentLocationData) {
        if (locationMarker) {
            locationMarker.remove();
        }
        locationMarker = L.marker([currentLocationData.lat, currentLocationData.lon], { icon: plusIcon }).addTo(radarMap);
        radarMap.setView([currentLocationData.lat, currentLocationData.lon], radarMap.getZoom());
      }
    }

    function initApp() {
      if (loadSavedLocation()) {
        loadWeather();
      }

      document.getElementById('loadWeather').addEventListener('click', loadWeather);
      document.getElementById('saveLocationBtn').addEventListener('click', saveLocation);
      document.getElementById('playRadar').addEventListener('click', playRadarAnimation);

      // Event listener pro slider rychlosti
      const speedSlider = document.getElementById('radarSpeed');
      speedSlider.addEventListener('input', function(e) {
          animationSpeed = parseInt(e.target.value);
          document.getElementById('radarSpeedValue').textContent = animationSpeed;
          
          // Pokud animace bƒõ≈æ√≠, okam≈æitƒõ aktualizujeme interval
          if (radarAnimation) {
              clearInterval(radarAnimation);
              // Zjist√≠me aktu√°ln√≠ frame, abychom pokraƒçovali plynule
              // Proto≈æe `setInterval` vol√° funkci asynchronnƒõ, mus√≠me ji zavolat znovu
              let frameIndex = currentRadarFrame; // Pokraƒçujeme od aktu√°ln√≠ho
              
              radarAnimation = setInterval(() => {
                  frameIndex = (frameIndex + 1) % radarLayers.length;
                  showRadarFrame(frameIndex);
              }, animationSpeed);
          }
      });

      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', function() {
          switchTab(this.dataset.tab);
        });
      });

      const locationInput = document.getElementById('location');
      locationInput.addEventListener('input', function() {
        clearTimeout(searchTimeout);
        const query = this.value.trim();
        
        if (query.length >= 2) {
          searchTimeout = setTimeout(async () => {
            const suggestions = await searchLocations(query);
            displaySuggestions(suggestions);
          }, 300);
        } else {
          document.getElementById('suggestions').classList.remove('show');
        }
      });

      locationInput.addEventListener('keydown', function(e) {
        const suggestionsDiv = document.getElementById('suggestions');
        
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          const nextIndex = Math.min(selectedSuggestionIndex + 1, currentSuggestions.length - 1);
          highlightSuggestion(nextIndex);
          if (nextIndex >= 0) {
            const suggestionItems = suggestionsDiv.querySelectorAll('.suggestion-item');
            suggestionItems[nextIndex].scrollIntoView({ block: 'nearest' });
          }
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          const prevIndex = Math.max(selectedSuggestionIndex - 1, -1);
          highlightSuggestion(prevIndex);
          if (prevIndex >= 0) {
            const suggestionItems = suggestionsDiv.querySelectorAll('.suggestion-item');
            suggestionItems[prevIndex].scrollIntoView({ block: 'nearest' });
          }
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (selectedSuggestionIndex >= 0) {
            selectSuggestion(selectedSuggestionIndex);
          } else {
            loadWeather();
          }
        } else if (e.key === 'Escape') {
          suggestionsDiv.classList.remove('show');
        }
      });

      document.addEventListener('click', function(e) {
        if (e.target !== locationInput) {
          document.getElementById('suggestions').classList.remove('show');
        }
      });
    }

    document.addEventListener('DOMContentLoaded', initApp);
  </script>
</body>
</html>
