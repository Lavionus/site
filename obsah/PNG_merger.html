<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üé® Editor kol√°≈æ√≠ v2</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: #121212;
      color: #e0e0e0;
      min-height: 100vh;
      overflow: hidden;
    }

    .app-container {
      display: flex;
      height: 100vh;
    }

    /* ========================================
       LEV√ù TOOLBAR
    ======================================== */
    .toolbar {
      width: 60px;
      background: linear-gradient(180deg, #1a1a1a 0%, #222 100%);
      border-right: 1px solid #333;
      display: flex;
      flex-direction: column;
      padding: 12px 10px;
      gap: 6px;
      box-shadow: 2px 0 12px rgba(0,0,0,0.3);
    }

    .toolbar-section {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .toolbar-divider {
      height: 1px;
      background: linear-gradient(90deg, transparent, #444, transparent);
      margin: 10px 4px;
    }

    .tool-btn {
      width: 40px;
      height: 40px;
      background-color: transparent;
      border: 1px solid transparent;
      border-radius: 10px;
      color: #888;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      transition: all 0.2s ease;
      position: relative;
    }

    .tool-btn:hover {
      background-color: #2d2d2d;
      color: #fff;
      border-color: #444;
      transform: scale(1.05);
    }

    .tool-btn.active {
      background: linear-gradient(135deg, #6aa6fd 0%, #5694f0 100%);
      color: #fff;
      border-color: transparent;
      box-shadow: 0 4px 12px rgba(106, 166, 253, 0.4);
    }

    .tool-btn.active:hover {
      transform: scale(1.05);
    }

    .tool-btn .tooltip {
      position: absolute;
      left: 50px;
      background: linear-gradient(135deg, #333 0%, #2a2a2a 100%);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 0.75rem;
      white-space: nowrap;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: all 0.2s ease;
      box-shadow: 0 4px 16px rgba(0,0,0,0.4);
      border: 1px solid #444;
      transform: translateX(-5px);
    }

    .tool-btn .tooltip::before {
      content: '';
      position: absolute;
      left: -6px;
      top: 50%;
      transform: translateY(-50%);
      border: 6px solid transparent;
      border-right-color: #444;
    }

    .tool-btn:hover .tooltip {
      opacity: 1;
      transform: translateX(0);
    }

    /* ========================================
       HLAVN√ç OBLAST
    ======================================== */
    .canvas-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background-color: #161616;
    }

    .canvas-header {
      background: linear-gradient(180deg, #222 0%, #1a1a1a 100%);
      border-bottom: 1px solid #333;
      padding: 10px 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.3);
      z-index: 10;
    }

    .canvas-header h1 {
      font-size: 1.1rem;
      font-weight: 600;
      color: #fff;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .header-controls {
      display: flex;
      gap: 8px;
      margin-left: auto;
    }

    .btn {
      background: linear-gradient(180deg, #6aa6fd 0%, #5694f0 100%);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 500;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 2px 8px rgba(106, 166, 253, 0.25);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(106, 166, 253, 0.35);
      background: linear-gradient(180deg, #7db3ff 0%, #6aa6fd 100%);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(106, 166, 253, 0.2);
    }

    .btn.secondary {
      background: linear-gradient(180deg, #3a3a3a 0%, #2d2d2d 100%);
      border: 1px solid #4a4a4a;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .btn.secondary:hover {
      background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      border-color: #6aa6fd;
    }

    .btn.icon-only {
      padding: 8px;
      width: 36px;
      height: 36px;
      justify-content: center;
    }

    .btn.success {
      background: linear-gradient(180deg, #4caf50 0%, #43a047 100%);
      box-shadow: 0 2px 8px rgba(76, 175, 80, 0.25);
    }

    .btn.success:hover {
      background: linear-gradient(180deg, #5cb860 0%, #4caf50 100%);
      box-shadow: 0 6px 16px rgba(76, 175, 80, 0.35);
    }

    .btn .btn-text {
      /* Skryje text na mal√Ωch obrazovk√°ch */
    }

    @media (max-width: 900px) {
      .btn .btn-text {
        display: none;
      }
    }

    .btn-group {
      display: flex;
      gap: 2px;
      background-color: #252525;
      border-radius: 8px;
      padding: 3px;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
    }

    .btn-group .btn {
      border-radius: 6px;
      box-shadow: none;
    }

    .btn-group .btn:hover {
      transform: none;
    }

    /* ========================================
       PL√ÅTNO
    ======================================== */
    .canvas-wrapper {
      flex: 1;
      overflow: auto;
      background-color: #0f0f0f;
      background-image: 
        radial-gradient(circle at 50% 50%, #1a1a1a 0%, #0f0f0f 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px;
      position: relative;
    }

    .canvas-container {
      position: relative;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      border-radius: 4px;
      overflow: visible;
      transition: transform 0.1s ease-out;
    }

    .canvas {
      position: relative;
      background-color: #ffffff;
      overflow: hidden;
    }

    .canvas.transparent-bg {
      background-color: transparent;
      background-image: 
        linear-gradient(45deg, #e0e0e0 25%, transparent 25%),
        linear-gradient(-45deg, #e0e0e0 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #e0e0e0 75%),
        linear-gradient(-45deg, transparent 75%, #e0e0e0 75%);
      background-size: 16px 16px;
      background-position: 0 0, 0 8px, 8px -8px, -8px 0px;
    }

    .canvas.show-grid {
      background-image: 
        linear-gradient(rgba(100,100,100,0.15) 1px, transparent 1px),
        linear-gradient(90deg, rgba(100,100,100,0.15) 1px, transparent 1px);
      background-size: 20px 20px;
    }

    .canvas.transparent-bg.show-grid {
      background-image: 
        linear-gradient(45deg, #e0e0e0 25%, transparent 25%),
        linear-gradient(-45deg, #e0e0e0 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #e0e0e0 75%),
        linear-gradient(-45deg, transparent 75%, #e0e0e0 75%),
        linear-gradient(rgba(100,100,100,0.3) 1px, transparent 1px),
        linear-gradient(90deg, rgba(100,100,100,0.3) 1px, transparent 1px);
      background-size: 16px 16px, 16px 16px, 16px 16px, 16px 16px, 20px 20px, 20px 20px;
    }

    /* Status bar */
    .status-bar {
      background: linear-gradient(180deg, #1a1a1a 0%, #161616 100%);
      border-top: 1px solid #333;
      padding: 8px 16px;
      font-size: 0.75rem;
      color: #777;
      display: flex;
      gap: 20px;
      align-items: center;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      background-color: rgba(255,255,255,0.03);
      border-radius: 6px;
      transition: all 0.2s;
    }

    .status-item:hover {
      background-color: rgba(255,255,255,0.06);
      color: #aaa;
    }

    .status-item.saving {
      color: #f0ad4e;
      background-color: rgba(240, 173, 78, 0.1);
      animation: pulse 1s infinite;
    }

    .status-item.saved {
      color: #5cb85c;
      background-color: rgba(92, 184, 92, 0.1);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    /* Zoom controls */
    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-left: auto;
      background-color: rgba(255,255,255,0.03);
      padding: 4px 8px;
      border-radius: 8px;
    }

    .zoom-btn {
      width: 26px;
      height: 26px;
      background-color: #2a2a2a;
      border: 1px solid #404040;
      border-radius: 6px;
      color: #aaa;
      cursor: pointer;
      font-size: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }

    .zoom-btn:hover {
      background-color: #404040;
      color: #fff;
      border-color: #6aa6fd;
    }

    .zoom-value {
      min-width: 50px;
      text-align: center;
      font-variant-numeric: tabular-nums;
      color: #aaa;
      font-weight: 500;
    }

    /* ========================================
       OBR√ÅZKY NA PL√ÅTNƒö
    ======================================== */
    .canvas-image {
      position: absolute;
      cursor: move;
      user-select: none;
      transform-origin: center center;
    }

    .canvas-image.selected {
      outline: 2px solid #6aa6fd;
      outline-offset: 3px;
    }

    .canvas-image.selected::before {
      content: '';
      position: absolute;
      inset: -3px;
      border: 1px dashed rgba(106, 166, 253, 0.5);
    }

    .canvas-image img {
      display: block;
      max-width: none;
      pointer-events: none;
    }

    /* Resize handles */
    .resize-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #fff;
      border: 2px solid #6aa6fd;
      border-radius: 2px;
      z-index: 10;
      transition: transform 0.1s;
    }

    .resize-handle:hover {
      transform: scale(1.2);
    }

    .resize-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
    .resize-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
    .resize-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
    .resize-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }
    .resize-handle.n { top: -5px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
    .resize-handle.s { bottom: -5px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
    .resize-handle.e { right: -5px; top: 50%; transform: translateY(-50%); cursor: e-resize; }
    .resize-handle.w { left: -5px; top: 50%; transform: translateY(-50%); cursor: w-resize; }

    .rotate-handle {
      position: absolute;
      top: -35px;
      left: 50%;
      transform: translateX(-50%);
      width: 24px;
      height: 24px;
      background-color: #6aa6fd;
      border: 2px solid #fff;
      border-radius: 50%;
      cursor: grab;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.65rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }

    .rotate-handle:active {
      cursor: grabbing;
    }

    .rotate-line {
      position: absolute;
      top: -35px;
      left: 50%;
      width: 1px;
      height: 32px;
      background-color: #6aa6fd;
      transform-origin: bottom center;
    }

    /* ========================================
       PRAV√ù PANEL
    ======================================== */
    .properties-panel {
      width: 340px;
      background: linear-gradient(180deg, #1e1e1e 0%, #1a1a1a 100%);
      border-left: 1px solid #333;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .panel-tabs {
      display: flex;
      background-color: #252525;
      border-bottom: 1px solid #333;
    }

    .panel-tab {
      flex: 1;
      padding: 10px;
      background: none;
      border: none;
      color: #888;
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 500;
      transition: all 0.15s;
      border-bottom: 2px solid transparent;
    }

    .panel-tab:hover {
      color: #ccc;
      background-color: #2a2a2a;
    }

    .panel-tab.active {
      color: #6aa6fd;
      border-bottom-color: #6aa6fd;
    }

    .panel-content {
      flex: 1;
      overflow-y: auto;
      display: none;
    }

    .panel-content.active {
      display: block;
    }

    .panel-section {
      padding: 16px;
      border-bottom: 1px solid #2a2a2a;
    }

    .panel-section h3 {
      font-size: 0.75rem;
      color: #6aa6fd;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .property-group {
      margin-bottom: 12px;
    }

    .property-group-label {
      font-size: 0.7rem;
      color: #666;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .property-row {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      gap: 8px;
      overflow: visible;
    }

    .property-row label {
      width: 50px;
      font-size: 0.8rem;
      color: #999;
      flex-shrink: 0;
    }

    .property-row input[type="number"],
    .property-row input[type="text"],
    .property-row select {
      flex: 1;
      padding: 7px 10px;
      background-color: #2a2a2a;
      border: 1px solid #404040;
      border-radius: 6px;
      color: #e0e0e0;
      font-size: 0.8rem;
      transition: border-color 0.15s;
    }

    .property-row input:focus,
    .property-row select:focus {
      outline: none;
      border-color: #6aa6fd;
    }

    .input-with-unit {
      position: relative;
      flex: 1;
      display: flex;
    }

    .input-with-unit input {
      width: 100%;
      padding-right: 28px;
    }

    .input-unit {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      color: #666;
      font-size: 0.75rem;
      pointer-events: none;
    }

    .property-row input[type="range"] {
      flex: 1;
      -webkit-appearance: none;
      background: #2a2a2a;
      height: 6px;
      border-radius: 3px;
      cursor: pointer;
    }

    .property-row input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: #6aa6fd;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 1px 4px rgba(0,0,0,0.3);
      transition: transform 0.1s;
    }

    .property-row input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }

    .range-value {
      width: 42px;
      text-align: right;
      font-size: 0.8rem;
      color: #999;
      font-variant-numeric: tabular-nums;
    }

    /* Dual input */
    .dual-input {
      display: flex;
      gap: 8px;
      flex: 1;
    }

    .dual-input .input-group {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .dual-input .input-group label {
      width: auto;
      font-size: 0.75rem;
      color: #666;
    }

    .dual-input input {
      width: 100%;
    }

    /* Color input */
    .color-input-wrapper {
      display: flex;
      align-items: center;
      gap: 6px;
      flex: 1;
      min-width: 0;
    }

    .color-input-wrapper input[type="color"] {
      width: 32px;
      height: 32px;
      min-width: 32px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      background: none;
      padding: 0;
      flex-shrink: 0;
    }

    .color-input-wrapper input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 2px;
    }

    .color-input-wrapper input[type="color"]::-webkit-color-swatch {
      border-radius: 4px;
      border: 1px solid #404040;
    }

    .color-hex {
      flex: 1;
      min-width: 70px;
      font-family: monospace;
    }

    .eyedropper-btn {
      width: 32px;
      height: 32px;
      min-width: 32px;
      background-color: #2a2a2a;
      border: 1px solid #404040;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      flex-shrink: 0;
    }

    .eyedropper-btn:hover {
      background-color: #404040;
      border-color: #6aa6fd;
    }

    .eyedropper-btn.active {
      background-color: #6aa6fd;
      border-color: #6aa6fd;
    }

    /* Checkbox */
    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }

    .checkbox-row input[type="checkbox"] {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
      accent-color: #6aa6fd;
      cursor: pointer;
    }

    .checkbox-row span {
      font-size: 0.8rem;
      color: #ccc;
      white-space: nowrap;
    }

    /* Quick actions */
    .quick-actions {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
      margin-top: 12px;
    }

    .quick-btn {
      padding: 8px 10px;
      background-color: #2a2a2a;
      border: 1px solid #404040;
      border-radius: 6px;
      color: #ccc;
      cursor: pointer;
      font-size: 0.75rem;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }

    .quick-btn:hover {
      background-color: #353535;
      border-color: #6aa6fd;
      color: #fff;
    }

    .quick-btn.danger {
      border-color: #5a3030;
    }

    .quick-btn.danger:hover {
      background-color: #4a2525;
      border-color: #8b4444;
    }

    /* ========================================
       LAYERS PANEL
    ======================================== */
    .layers-list {
      padding: 8px;
    }

    .layer-item {
      display: flex;
      align-items: center;
      padding: 8px;
      background-color: #252525;
      border: 1px solid #333;
      border-radius: 8px;
      margin-bottom: 4px;
      cursor: pointer;
      gap: 10px;
      transition: all 0.15s ease;
    }

    .layer-item:hover {
      background-color: #2a2a2a;
      border-color: #444;
    }

    .layer-item.selected {
      border-color: #6aa6fd;
      background-color: #1e2a3a;
    }

    .layer-item.dragging {
      opacity: 0.5;
    }

    .layer-drag-handle {
      color: #555;
      cursor: grab;
      font-size: 0.9rem;
    }

    .layer-drag-handle:active {
      cursor: grabbing;
    }

    .layer-visibility {
      width: 24px;
      height: 24px;
      background: none;
      border: none;
      color: #6aa6fd;
      cursor: pointer;
      font-size: 0.9rem;
      border-radius: 4px;
      transition: all 0.15s;
    }

    .layer-visibility:hover {
      background-color: #333;
    }

    .layer-visibility.hidden {
      color: #555;
    }

    .layer-thumb {
      width: 36px;
      height: 36px;
      background-color: #1a1a1a;
      border-radius: 4px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .layer-thumb img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .layer-info {
      flex: 1;
      overflow: hidden;
      min-width: 0;
    }

    .layer-name {
      font-size: 0.8rem;
      color: #e0e0e0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .layer-meta {
      font-size: 0.7rem;
      color: #666;
      margin-top: 2px;
    }

    .layer-actions {
      display: flex;
      gap: 2px;
      opacity: 0;
      transition: opacity 0.15s;
    }

    .layer-item:hover .layer-actions {
      opacity: 1;
    }

    .layer-action-btn {
      width: 26px;
      height: 26px;
      background: none;
      border: none;
      color: #888;
      cursor: pointer;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      transition: all 0.15s;
    }

    .layer-action-btn:hover {
      background-color: #404040;
      color: #fff;
    }

    /* ========================================
       DROP ZONE
    ======================================== */
    .drop-zone {
      position: absolute;
      inset: 0;
      background-color: rgba(106, 166, 253, 0.1);
      border: 3px dashed #6aa6fd;
      border-radius: 8px;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(4px);
    }

    .drop-zone.active {
      display: flex;
    }

    .drop-zone-content {
      background-color: #252525;
      padding: 30px 50px;
      border-radius: 12px;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }

    .drop-zone-icon {
      font-size: 3rem;
      margin-bottom: 10px;
    }

    .drop-zone-text {
      font-size: 1rem;
      color: #6aa6fd;
    }

    /* ========================================
       CROP OVERLAY
    ======================================== */
    .crop-overlay {
      position: fixed;
      inset: 0;
      background-color: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      flex-direction: column;
      gap: 20px;
    }

    .crop-overlay.active {
      display: flex;
    }

    .crop-container {
      position: relative;
      max-width: 80vw;
      max-height: 70vh;
    }

    .crop-image {
      max-width: 100%;
      max-height: 70vh;
      display: block;
    }

    .crop-selection {
      position: absolute;
      border: 2px solid #6aa6fd;
      background-color: rgba(106, 166, 253, 0.1);
      cursor: move;
      box-shadow: 0 0 0 9999px rgba(0,0,0,0.6);
    }

    .crop-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background-color: #6aa6fd;
      border: 2px solid #fff;
    }

    .crop-handle.nw { top: -6px; left: -6px; cursor: nw-resize; }
    .crop-handle.ne { top: -6px; right: -6px; cursor: ne-resize; }
    .crop-handle.sw { bottom: -6px; left: -6px; cursor: sw-resize; }
    .crop-handle.se { bottom: -6px; right: -6px; cursor: se-resize; }

    .crop-toolbar {
      display: flex;
      gap: 10px;
      background-color: #252525;
      padding: 12px 20px;
      border-radius: 8px;
    }

    .crop-info {
      color: #888;
      font-size: 0.85rem;
      padding: 8px 16px;
      background-color: #252525;
      border-radius: 6px;
    }

    /* ========================================
       STATUS BAR NOTIFICATIONS
    ======================================== */
    .status-notification {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4px 12px;
      border-radius: 6px;
      font-size: 0.8rem;
      font-weight: 500;
      min-height: 28px;
      transition: all 0.3s ease;
      opacity: 0;
    }

    .status-notification.visible {
      opacity: 1;
    }

    .status-notification.success {
      background-color: rgba(76, 175, 80, 0.15);
      color: #6fbf73;
      border: 1px solid rgba(76, 175, 80, 0.3);
    }

    .status-notification.error {
      background-color: rgba(244, 67, 54, 0.15);
      color: #f77066;
      border: 1px solid rgba(244, 67, 54, 0.3);
    }

    .status-notification.info {
      background-color: rgba(33, 150, 243, 0.15);
      color: #64b5f6;
      border: 1px solid rgba(33, 150, 243, 0.3);
    }

    /* ========================================
       MODAL
    ======================================== */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background-color: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      backdrop-filter: blur(4px);
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: linear-gradient(180deg, #252525 0%, #1e1e1e 100%);
      border: 1px solid #404040;
      border-radius: 12px;
      padding: 24px;
      min-width: 380px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }

    .modal h2 {
      font-size: 1.1rem;
      margin-bottom: 20px;
      color: #fff;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .modal-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 24px;
    }

    /* ========================================
       SHORTCUTS HELP
    ======================================== */
    .shortcuts-help {
      position: fixed;
      bottom: 70px;
      left: 75px;
      background: linear-gradient(135deg, rgba(30, 30, 30, 0.98) 0%, rgba(25, 25, 25, 0.98) 100%);
      border: 1px solid #3a3a3a;
      border-radius: 16px;
      padding: 20px 24px;
      font-size: 0.8rem;
      color: #888;
      max-width: 340px;
      display: none;
      box-shadow: 0 12px 48px rgba(0,0,0,0.5);
      z-index: 1000;
      backdrop-filter: blur(12px);
      animation: fadeIn 0.2s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .shortcuts-help.visible {
      display: block;
    }

    .shortcuts-help h4 {
      margin-bottom: 16px;
      color: #6aa6fd;
      font-size: 0.9rem;
      font-weight: 600;
      padding-bottom: 10px;
      border-bottom: 1px solid #333;
    }

    .shortcut-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      color: #bbb;
      padding: 4px 0;
    }

    .shortcut-item:last-child {
      margin-bottom: 0;
    }

    .shortcut-key {
      background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
      padding: 4px 10px;
      border-radius: 6px;
      color: #fff;
      font-family: monospace;
      font-size: 0.7rem;
      border: 1px solid #444;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    /* Hidden */
    #fileInput {
      display: none;
    }

    /* Empty state */
    .empty-state {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #666;
      pointer-events: none;
      background: radial-gradient(circle at center, rgba(106, 166, 253, 0.03) 0%, transparent 70%);
    }

    .empty-state-icon {
      font-size: 5rem;
      margin-bottom: 20px;
      opacity: 0.4;
      animation: float 3s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .empty-state-text {
      font-size: 1.1rem;
      margin-bottom: 8px;
      font-weight: 500;
    }

    .empty-state-hint {
      font-size: 0.85rem;
      color: #555;
    }

    .canvas:has(.canvas-image) .empty-state {
      display: none;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Lev√Ω toolbar -->
    <div class="toolbar">
      <div class="toolbar-section">
        <button class="tool-btn active" data-tool="select">
          üñ±Ô∏è
          <span class="tooltip">V√Ωbƒõr (V)</span>
        </button>
        <button class="tool-btn" data-tool="move">
          ‚úã
          <span class="tooltip">Posun pl√°tna (H)</span>
        </button>
      </div>
      
      <div class="toolbar-divider"></div>
      
      <div class="toolbar-section">
        <button class="tool-btn" id="cropBtn" title="O≈ôez">
          ‚úÇÔ∏è
          <span class="tooltip">O≈ôez obr√°zku (C)</span>
        </button>
        <button class="tool-btn" id="gridBtn" title="M≈ô√≠≈æka">
          #Ô∏è‚É£
          <span class="tooltip">M≈ô√≠≈æka (G)</span>
        </button>
      </div>

      <div style="flex: 1;"></div>

      <div class="toolbar-section">
        <button class="tool-btn" id="newProjectBtn" title="Nov√Ω projekt">
          üìÑ
          <span class="tooltip">Nov√Ω projekt</span>
        </button>
        <button class="tool-btn" id="helpBtn">
          ‚ùì
          <span class="tooltip">N√°povƒõda (?)</span>
        </button>
      </div>
    </div>

    <!-- Hlavn√≠ oblast -->
    <div class="canvas-area">
      <div class="canvas-header">
        <h1>üé® Editor kol√°≈æ√≠</h1>
        <div class="header-controls">
          <button class="btn secondary" id="addImageBtn" title="P≈ôidat obr√°zek">
            <span>üìÅ</span> <span class="btn-text">P≈ôidat</span>
          </button>
          
          <div class="btn-group">
            <button class="btn secondary icon-only" id="undoBtn" title="Zpƒõt (Ctrl+Z)">‚Ü©Ô∏è</button>
            <button class="btn secondary icon-only" id="redoBtn" title="Vp≈ôed (Ctrl+Y)">‚Ü™Ô∏è</button>
          </div>

          <div class="btn-group">
            <button class="btn secondary icon-only" id="saveBtn" title="Ulo≈æit projekt (Ctrl+Shift+S)">üíæ</button>
          </div>
          
          <button class="btn" id="exportBtn" title="Exportovat obr√°zek">
            <span>üì§</span> <span class="btn-text">Export</span>
          </button>
        </div>
      </div>

      <div class="canvas-wrapper" id="canvasWrapper">
        <div class="canvas-container">
          <div class="canvas" id="canvas" style="width: 800px; height: 600px;">
            <div class="empty-state">
              <div class="empty-state-icon">üñºÔ∏è</div>
              <div class="empty-state-text">P≈ôet√°hnƒõte obr√°zky sem</div>
              <div class="empty-state-hint">nebo kliknƒõte na "P≈ôidat"</div>
            </div>
          </div>
        </div>
        <div class="drop-zone" id="dropZone">
          <div class="drop-zone-content">
            <div class="drop-zone-icon">üì•</div>
            <div class="drop-zone-text">Pus≈•te obr√°zky pro p≈ôid√°n√≠</div>
          </div>
        </div>
      </div>

      <div class="status-bar">
        <div class="status-item" id="statusCanvas">üìê 800 √ó 600 px</div>
        <div class="status-item" id="statusLayers">üìö 0 vrstev</div>
        <div class="status-item" id="statusSelected">üñ±Ô∏è Nic nevybr√°no</div>
        <div class="status-notification" id="statusNotification"></div>
        <div class="status-item" id="statusSave">üíæ Ulo≈æeno</div>
        <div class="zoom-controls">
          <button class="zoom-btn" id="zoomOut" title="Odd√°lit (-)">‚àí</button>
          <span class="zoom-value" id="zoomValue">100%</span>
          <button class="zoom-btn" id="zoomIn" title="P≈ôibl√≠≈æit (+)">+</button>
          <button class="zoom-btn" id="zoomReset" title="Reset (0)">‚ü≤</button>
        </div>
      </div>
    </div>

    <!-- Prav√Ω panel -->
    <div class="properties-panel">
      <div class="panel-tabs">
        <button class="panel-tab active" data-panel="properties">Vlastnosti</button>
        <button class="panel-tab" data-panel="layers">Vrstvy</button>
      </div>

      <!-- Panel vlastnost√≠ -->
      <div class="panel-content active" id="propertiesPanel">
        <!-- Canvas nastaven√≠ -->
        <div class="panel-section">
          <h3>üìê Pl√°tno</h3>
          <div class="property-row">
            <label>Rozmƒõr</label>
            <div class="dual-input">
              <div class="input-group">
                <label>≈†</label>
                <input type="number" id="canvasWidth" value="800" min="100" max="4000">
              </div>
              <div class="input-group">
                <label>V</label>
                <input type="number" id="canvasHeight" value="600" min="100" max="4000">
              </div>
            </div>
          </div>
          <div class="property-row">
            <label>Pozad√≠</label>
            <div class="color-input-wrapper">
              <input type="color" id="canvasBgColor" value="#ffffff">
              <input type="text" class="color-hex" id="canvasBgHex" value="#ffffff" maxlength="7">
            </div>
          </div>
          <div class="property-row">
            <label></label>
            <label class="checkbox-row">
              <input type="checkbox" id="transparentBg">
              <span>Pr≈Øhledn√© pozad√≠</span>
            </label>
          </div>
          <div class="property-row" style="margin-top: 12px;">
            <label></label>
            <button class="quick-btn danger" id="clearStorageBtn" style="flex: 1;">üóëÔ∏è Vymazat ulo≈æen√° data</button>
          </div>
        </div>

        <!-- Vlastnosti obr√°zku -->
        <div class="panel-section" id="imageProperties" style="display: none;">
          <h3>üñºÔ∏è Vybran√Ω obr√°zek</h3>
          
          <div class="property-group">
            <div class="property-group-label">Pozice</div>
            <div class="property-row">
              <label>Pozice</label>
              <div class="dual-input">
                <div class="input-group">
                  <label>X</label>
                  <input type="number" id="propX" value="0">
                </div>
                <div class="input-group">
                  <label>Y</label>
                  <input type="number" id="propY" value="0">
                </div>
              </div>
            </div>
          </div>

          <div class="property-group">
            <div class="property-group-label">Velikost</div>
            <div class="property-row">
              <label>Rozmƒõr</label>
              <div class="dual-input">
                <div class="input-group">
                  <label>≈†</label>
                  <input type="number" id="propWidth" value="100" min="10">
                </div>
                <div class="input-group">
                  <label>V</label>
                  <input type="number" id="propHeight" value="100" min="10">
                </div>
              </div>
            </div>
            <div class="property-row">
              <label></label>
              <label class="checkbox-row">
                <input type="checkbox" id="lockAspect">
                <span>üîó Zamknout pomƒõr</span>
              </label>
            </div>
          </div>

          <div class="property-group">
            <div class="property-group-label">Transformace</div>
            <div class="property-row">
              <label>Pr≈Øhled.</label>
              <input type="range" id="propOpacity" min="0" max="100" value="100">
              <span class="range-value" id="opacityValue">100%</span>
            </div>
            <!-- Skryt√© inputy pro zachov√°n√≠ funkƒçnosti -->
            <input type="hidden" id="propRotation" value="0">
            <input type="hidden" id="propZIndex" value="1">
            <span id="rotationValue" style="display:none;">0¬∞</span>
          </div>

          <div class="property-group">
            <div class="property-group-label">Barva do pr≈Øhlednosti</div>
            <div class="property-row">
              <label></label>
              <label class="checkbox-row">
                <input type="checkbox" id="chromaKeyEnabled">
                <span>Aktivovat</span>
              </label>
            </div>
            <div class="property-row" id="chromaKeyColorRow" style="display: none;">
              <label>Barva</label>
              <div class="color-input-wrapper">
                <input type="color" id="chromaKeyColor" value="#00ff00">
                <input type="text" class="color-hex" id="chromaKeyHex" value="#00ff00" maxlength="7">
                <button class="eyedropper-btn" id="chromaKeyEyedropper" title="Vybrat barvu z obr√°zku">üíß</button>
              </div>
            </div>
            <div class="property-row" id="chromaKeyToleranceRow" style="display: none;">
              <label>Tolerance</label>
              <input type="range" id="chromaKeyTolerance" min="0" max="100" value="30">
              <span class="range-value" id="toleranceValue">30</span>
            </div>
          </div>

          <div class="quick-actions">
            <button class="quick-btn" id="flipH">‚ÜîÔ∏è Flip H</button>
            <button class="quick-btn" id="flipV">‚ÜïÔ∏è Flip V</button>
            <button class="quick-btn" id="duplicateBtn">üìã Duplikovat</button>
            <button class="quick-btn" id="cropSelectedBtn">‚úÇÔ∏è O≈ô√≠znout</button>
            <button class="quick-btn" id="resetTransformBtn">üîÑ Reset</button>
            <button class="quick-btn danger" id="deleteBtn">üóëÔ∏è Smazat</button>
          </div>
        </div>

        <!-- Placeholder kdy≈æ nic nen√≠ vybr√°no -->
        <div class="panel-section" id="noSelection">
          <div style="text-align: center; color: #555; padding: 30px 0;">
            <div style="font-size: 2.5rem; margin-bottom: 10px; opacity: 0.5;">üñºÔ∏è</div>
            <div style="font-size: 0.85rem;">Vyberte obr√°zek</div>
            <div style="font-size: 0.75rem; margin-top: 5px;">pro √∫pravu vlastnost√≠</div>
          </div>
        </div>
      </div>

      <!-- Panel vrstev -->
      <div class="panel-content" id="layersPanel">
        <div class="layers-list" id="layersList">
          <!-- Vrstvy se generuj√≠ dynamicky -->
        </div>
      </div>
    </div>
  </div>

  <!-- Hidden file input -->
  <input type="file" id="fileInput" accept="image/*" multiple>

  <!-- Shortcuts help -->
  <div class="shortcuts-help" id="shortcutsHelp">
    <h4>‚å®Ô∏è Kl√°vesov√© zkratky</h4>
    <div class="shortcut-item"><span>Posun</span><span class="shortcut-key">‚Üë‚Üì‚Üê‚Üí</span></div>
    <div class="shortcut-item"><span>Rychl√Ω posun</span><span class="shortcut-key">Shift + ≈°ipky</span></div>
    <div class="shortcut-item"><span>Smazat</span><span class="shortcut-key">Delete</span></div>
    <div class="shortcut-item"><span>Duplikovat</span><span class="shortcut-key">Ctrl + D</span></div>
    <div class="shortcut-item"><span>Zpƒõt</span><span class="shortcut-key">Ctrl + Z</span></div>
    <div class="shortcut-item"><span>Vp≈ôed</span><span class="shortcut-key">Ctrl + Y</span></div>
    <div class="shortcut-item"><span>Ulo≈æit</span><span class="shortcut-key">Ctrl + S</span></div>
    <div class="shortcut-item"><span>Export</span><span class="shortcut-key">Ctrl + Shift + S</span></div>
    <div class="shortcut-item"><span>O≈ôez</span><span class="shortcut-key">C</span></div>
    <div class="shortcut-item"><span>M≈ô√≠≈æka</span><span class="shortcut-key">G</span></div>
    <div class="shortcut-item"><span>Vrstva +/-</span><span class="shortcut-key">Page Up/Down</span></div>
    <div class="shortcut-item"><span>Zoom +/-</span><span class="shortcut-key">+ / - / Ctrl+koleƒçko</span></div>
    <div class="shortcut-item"><span>Reset zoom</span><span class="shortcut-key">0</span></div>
  </div>

  <!-- Export modal -->
  <div class="modal-overlay" id="exportModal">
    <div class="modal">
      <h2>üíæ Export obr√°zku</h2>
      <div class="property-row">
        <label>N√°zev</label>
        <input type="text" id="exportFilename" value="kolaz">
      </div>
      <div class="property-row">
        <label>Form√°t</label>
        <select id="exportFormat">
          <option value="png">PNG (s pr≈Øhlednost√≠)</option>
          <option value="jpeg">JPEG (men≈°√≠ soubor)</option>
          <option value="svg">SVG (vektorov√Ω)</option>
        </select>
      </div>
      <div class="property-row" id="jpegQualityRow" style="display: none;">
        <label>Kvalita</label>
        <input type="range" id="exportQuality" min="10" max="100" value="92">
        <span class="range-value" id="qualityValue">92%</span>
      </div>
      <div class="modal-actions">
        <button class="btn secondary" id="cancelExport">Zru≈°it</button>
        <button class="btn" id="confirmExport">Exportovat</button>
      </div>
    </div>
  </div>

  <!-- Crop overlay -->
  <div class="crop-overlay" id="cropOverlay">
    <div class="crop-info" id="cropInfo">Vyberte oblast pro o≈ôez ta≈æen√≠m my≈°i</div>
    <div class="crop-container" id="cropContainer">
      <img class="crop-image" id="cropImage" src="" alt="">
      <div class="crop-selection" id="cropSelection" style="display: none;">
        <div class="crop-handle nw" data-handle="nw"></div>
        <div class="crop-handle ne" data-handle="ne"></div>
        <div class="crop-handle sw" data-handle="sw"></div>
        <div class="crop-handle se" data-handle="se"></div>
      </div>
    </div>
    <div class="crop-toolbar">
      <button class="btn secondary" id="cancelCrop">Zru≈°it</button>
      <button class="btn" id="applyCrop">‚úÇÔ∏è Aplikovat o≈ôez</button>
    </div>
  </div>

  <script>
    // ===============================================
    // HLAVN√ç STAV APLIKACE
    // ===============================================
    const state = {
      images: [],
      selectedImageId: null,
      currentTool: 'select',
      history: [],
      historyIndex: -1,
      isDragging: false,
      isResizing: false,
      isRotating: false,
      dragOffset: { x: 0, y: 0 },
      resizeHandle: null,
      initialState: null,
      initialMousePos: null,
      shiftPressed: false,
      altPressed: false,
      nextId: 1,
      cropData: null,
      zoom: 1,
      gridEnabled: false,
      gridSize: 20,
      lastSaved: null
    };

    // ===============================================
    // DOM REFERENCES
    // ===============================================
    const canvas = document.getElementById('canvas');
    const canvasWrapper = document.getElementById('canvasWrapper');
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const layersList = document.getElementById('layersList');
    const imageProperties = document.getElementById('imageProperties');
    const noSelection = document.getElementById('noSelection');

    // ===============================================
    // UTILITY FUNKCE
    // ===============================================
    let notificationTimeout = null;
    
    function showNotification(message, type = 'info') {
      const notification = document.getElementById('statusNotification');
      
      // Vyƒçistit p≈ôedchoz√≠ timeout
      if (notificationTimeout) {
        clearTimeout(notificationTimeout);
      }
      
      // Resetovat t≈ô√≠dy a nastavit nov√©
      notification.className = 'status-notification';
      notification.textContent = message;
      
      // P≈ôidat t≈ô√≠du typu a viditelnosti (s mal√Ωm zpo≈ædƒõn√≠m pro animaci)
      requestAnimationFrame(() => {
        notification.classList.add(type, 'visible');
      });
      
      // Skr√Ωt po 3 sekund√°ch
      notificationTimeout = setTimeout(() => {
        notification.classList.remove('visible');
      }, 3000);
    }

    function generateId() {
      return state.nextId++;
    }

    function updateStatus() {
      document.getElementById('statusCanvas').textContent = 
        `üìê ${canvas.style.width} √ó ${canvas.style.height}`;
      document.getElementById('statusLayers').textContent = 
        `üìö ${state.images.length} vrstev`;
      
      const selected = getSelectedImage();
      document.getElementById('statusSelected').textContent = selected 
        ? `üñ±Ô∏è ${selected.name}` 
        : 'üñ±Ô∏è Nic nevybr√°no';
    }

    // ===============================================
    // CHROMA KEY (BARVA DO PR≈ÆHLEDNOSTI)
    // ===============================================
    function applyChromaKey(imageData, targetColor, tolerance) {
      const tempCanvas = document.createElement('canvas');
      const ctx = tempCanvas.getContext('2d');
      const img = new Image();
      
      return new Promise((resolve) => {
        img.onload = () => {
          tempCanvas.width = img.naturalWidth;
          tempCanvas.height = img.naturalHeight;
          ctx.drawImage(img, 0, 0);
          
          const imgData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
          const data = imgData.data;
          
          // Parse target color
          const r = parseInt(targetColor.slice(1, 3), 16);
          const g = parseInt(targetColor.slice(3, 5), 16);
          const b = parseInt(targetColor.slice(5, 7), 16);
          
          const tolSq = (tolerance * 2.55) ** 2;
          
          for (let i = 0; i < data.length; i += 4) {
            const dr = data[i] - r;
            const dg = data[i + 1] - g;
            const db = data[i + 2] - b;
            const distSq = dr * dr + dg * dg + db * db;
            
            if (distSq < tolSq) {
              data[i + 3] = 0; // Set alpha to 0
            }
          }
          
          ctx.putImageData(imgData, 0, 0);
          resolve(tempCanvas.toDataURL('image/png'));
        };
        img.src = imageData.originalSrc || imageData.src;
      });
    }

    async function updateImageChromaKey(imageData) {
      if (imageData.chromaKeyEnabled && imageData.chromaKeyColor) {
        // Store original if not stored
        if (!imageData.originalSrc) {
          imageData.originalSrc = imageData.src;
        }
        imageData.src = await applyChromaKey(
          imageData, 
          imageData.chromaKeyColor, 
          imageData.chromaKeyTolerance || 30
        );
      } else if (imageData.originalSrc) {
        imageData.src = imageData.originalSrc;
      }
      renderImage(imageData);
    }

    // ===============================================
    // HISTORY (UNDO/REDO)
    // ===============================================
    function saveHistory() {
      state.history = state.history.slice(0, state.historyIndex + 1);
      state.history.push(JSON.stringify(state.images));
      state.historyIndex = state.history.length - 1;
      if (state.history.length > 50) {
        state.history.shift();
        state.historyIndex--;
      }
    }

    function undo() {
      if (state.historyIndex > 0) {
        state.historyIndex--;
        state.images = JSON.parse(state.history[state.historyIndex]);
        renderAllImages();
        renderLayers();
        selectImage(null);
        updateStatus();
        showNotification('‚Ü©Ô∏è Krok zpƒõt', 'info');
      }
    }

    function redo() {
      if (state.historyIndex < state.history.length - 1) {
        state.historyIndex++;
        state.images = JSON.parse(state.history[state.historyIndex]);
        renderAllImages();
        renderLayers();
        selectImage(null);
        updateStatus();
        showNotification('‚Ü™Ô∏è Krok vp≈ôed', 'info');
      }
    }

    // ===============================================
    // IMAGE MANAGEMENT
    // ===============================================
    function addImage(src, name = 'Obr√°zek') {
      const img = new Image();
      img.onload = () => {
        const imageData = {
          id: generateId(),
          src: src,
          originalSrc: src,
          name: name,
          x: 50,
          y: 50,
          width: img.naturalWidth,
          height: img.naturalHeight,
          originalWidth: img.naturalWidth,
          originalHeight: img.naturalHeight,
          aspectRatio: img.naturalWidth / img.naturalHeight,
          rotation: 0,
          opacity: 100,
          zIndex: state.images.length + 1,
          flipH: false,
          flipV: false,
          visible: true,
          chromaKeyEnabled: false,
          chromaKeyColor: '#00ff00',
          chromaKeyTolerance: 30
        };

        // Scale if too large
        const maxSize = Math.min(canvas.offsetWidth - 100, canvas.offsetHeight - 100);
        if (imageData.width > maxSize || imageData.height > maxSize) {
          const scale = maxSize / Math.max(imageData.width, imageData.height);
          imageData.width = Math.round(imageData.width * scale);
          imageData.height = Math.round(imageData.height * scale);
        }

        state.images.push(imageData);
        saveHistory();
        renderImage(imageData);
        renderLayers();
        selectImage(imageData.id);
        updateStatus();
        showNotification(`‚úÖ P≈ôid√°n: ${name}`, 'success');
      };
      img.src = src;
    }

    function renderImage(imageData) {
      const existing = document.querySelector(`[data-id="${imageData.id}"]`);
      if (existing) existing.remove();

      if (!imageData.visible) return;

      const wrapper = document.createElement('div');
      wrapper.className = 'canvas-image';
      wrapper.dataset.id = imageData.id;
      wrapper.style.left = `${imageData.x}px`;
      wrapper.style.top = `${imageData.y}px`;
      wrapper.style.width = `${imageData.width}px`;
      wrapper.style.height = `${imageData.height}px`;
      wrapper.style.zIndex = imageData.zIndex;
      wrapper.style.opacity = imageData.opacity / 100;

      let transform = `rotate(${imageData.rotation}deg)`;
      if (imageData.flipH) transform += ' scaleX(-1)';
      if (imageData.flipV) transform += ' scaleY(-1)';
      wrapper.style.transform = transform;

      const img = document.createElement('img');
      img.src = imageData.src;
      img.style.width = '100%';
      img.style.height = '100%';
      img.draggable = false;

      wrapper.appendChild(img);

      if (state.selectedImageId === imageData.id) {
        wrapper.classList.add('selected');
        addResizeHandles(wrapper);
        addRotateHandle(wrapper);
      }

      canvas.appendChild(wrapper);
      setupImageEvents(wrapper, imageData);
    }

    function renderAllImages() {
      canvas.querySelectorAll('.canvas-image').forEach(el => el.remove());
      state.images.forEach(img => renderImage(img));
    }

    function addResizeHandles(wrapper) {
      ['nw', 'ne', 'sw', 'se', 'n', 's', 'e', 'w'].forEach(pos => {
        const handle = document.createElement('div');
        handle.className = `resize-handle ${pos}`;
        handle.dataset.handle = pos;
        wrapper.appendChild(handle);
      });
    }

    function addRotateHandle(wrapper) {
      const line = document.createElement('div');
      line.className = 'rotate-line';
      wrapper.appendChild(line);
      
      const handle = document.createElement('div');
      handle.className = 'rotate-handle';
      handle.innerHTML = '‚Üª';
      handle.dataset.handle = 'rotate';
      wrapper.appendChild(handle);
    }

    function setupImageEvents(wrapper, imageData) {
      wrapper.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('resize-handle')) {
          startResize(e, imageData, e.target.dataset.handle);
        } else if (e.target.classList.contains('rotate-handle')) {
          startRotate(e, imageData);
        } else {
          selectImage(imageData.id);
          startDrag(e, imageData);
        }
      });
    }

    function selectImage(id) {
      state.selectedImageId = id;
      
      canvas.querySelectorAll('.canvas-image').forEach(el => {
        el.classList.remove('selected');
        el.querySelectorAll('.resize-handle, .rotate-handle, .rotate-line').forEach(h => h.remove());
      });

      if (id) {
        const wrapper = document.querySelector(`[data-id="${id}"]`);
        if (wrapper) {
          wrapper.classList.add('selected');
          addResizeHandles(wrapper);
          addRotateHandle(wrapper);
        }
        updatePropertiesPanel();
        imageProperties.style.display = 'block';
        noSelection.style.display = 'none';
      } else {
        imageProperties.style.display = 'none';
        noSelection.style.display = 'block';
      }

      renderLayers();
      updateStatus();
    }

    function getSelectedImage() {
      return state.images.find(img => img.id === state.selectedImageId);
    }

    function deleteImage(id) {
      const index = state.images.findIndex(i => i.id === id);
      if (index > -1) {
        state.images.splice(index, 1);
        saveHistory();
        const wrapper = document.querySelector(`[data-id="${id}"]`);
        if (wrapper) wrapper.remove();
        selectImage(null);
        renderLayers();
        updateStatus();
        showNotification('üóëÔ∏è Obr√°zek smaz√°n', 'info');
      }
    }

    function duplicateImage(id) {
      const img = state.images.find(i => i.id === id);
      if (img) {
        const newImg = JSON.parse(JSON.stringify(img));
        newImg.id = generateId();
        newImg.x += 20;
        newImg.y += 20;
        newImg.zIndex = state.images.length + 1;
        newImg.name = img.name + ' (kopie)';
        state.images.push(newImg);
        saveHistory();
        renderImage(newImg);
        renderLayers();
        selectImage(newImg.id);
        updateStatus();
        showNotification('üìã Obr√°zek duplikov√°n', 'success');
      }
    }

    // ===============================================
    // DRAG & DROP
    // ===============================================
    function startDrag(e, imageData) {
      state.isDragging = true;
      state.initialState = { ...imageData };
      state.initialMousePos = { x: e.clientX, y: e.clientY };
      const rect = e.target.closest('.canvas-image').getBoundingClientRect();
      state.dragOffset = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
      e.preventDefault();
    }

    function handleDrag(e) {
      if (!state.isDragging || !state.selectedImageId) return;
      
      const img = getSelectedImage();
      if (!img) return;

      const canvasRect = canvas.getBoundingClientRect();
      const scale = state.zoom;
      let newX = Math.round((e.clientX - canvasRect.left) / scale - state.dragOffset.x);
      let newY = Math.round((e.clientY - canvasRect.top) / scale - state.dragOffset.y);
      
      // Snap to grid
      if (state.gridEnabled) {
        newX = snapToGrid(newX);
        newY = snapToGrid(newY);
      }
      
      img.x = newX;
      img.y = newY;
      
      const wrapper = document.querySelector(`[data-id="${img.id}"]`);
      if (wrapper) {
        wrapper.style.left = `${img.x}px`;
        wrapper.style.top = `${img.y}px`;
      }
      updatePropertiesPanel();
    }

    function stopDrag() {
      if (state.isDragging && state.initialState) {
        const img = getSelectedImage();
        if (img && (img.x !== state.initialState.x || img.y !== state.initialState.y)) {
          saveHistory();
        }
      }
      state.isDragging = false;
      state.initialState = null;
    }

    // ===============================================
    // RESIZE (S PODPOROU SHIFT PRO ZACHOV√ÅN√ç POMƒöRU)
    // ===============================================
    function startResize(e, imageData, handle) {
      state.isResizing = true;
      state.resizeHandle = handle;
      state.initialState = { ...imageData };
      state.initialMousePos = { x: e.clientX, y: e.clientY };
      e.stopPropagation();
      e.preventDefault();
    }

    function handleResize(e) {
      if (!state.isResizing || !state.selectedImageId) return;

      const img = getSelectedImage();
      if (!img) return;

      const init = state.initialState;
      const dx = e.clientX - state.initialMousePos.x;
      const dy = e.clientY - state.initialMousePos.y;
      
      // Check if we should preserve aspect ratio
      const preserveRatio = state.shiftPressed || document.getElementById('lockAspect').checked;
      const ratio = init.aspectRatio || (init.width / init.height);

      let newWidth = init.width;
      let newHeight = init.height;
      let newX = init.x;
      let newY = init.y;

      switch (state.resizeHandle) {
        case 'se':
          newWidth = Math.max(20, init.width + dx);
          newHeight = preserveRatio ? newWidth / ratio : Math.max(20, init.height + dy);
          if (preserveRatio) newWidth = newHeight * ratio;
          break;
        case 'sw':
          newWidth = Math.max(20, init.width - dx);
          newHeight = preserveRatio ? newWidth / ratio : Math.max(20, init.height + dy);
          if (preserveRatio) newWidth = newHeight * ratio;
          newX = init.x + init.width - newWidth;
          break;
        case 'ne':
          newWidth = Math.max(20, init.width + dx);
          newHeight = preserveRatio ? newWidth / ratio : Math.max(20, init.height - dy);
          if (preserveRatio) newWidth = newHeight * ratio;
          newY = init.y + init.height - newHeight;
          break;
        case 'nw':
          newWidth = Math.max(20, init.width - dx);
          newHeight = preserveRatio ? newWidth / ratio : Math.max(20, init.height - dy);
          if (preserveRatio) newWidth = newHeight * ratio;
          newX = init.x + init.width - newWidth;
          newY = init.y + init.height - newHeight;
          break;
        case 'n':
          newHeight = Math.max(20, init.height - dy);
          if (preserveRatio) {
            newWidth = newHeight * ratio;
            newX = init.x - (newWidth - init.width) / 2;
          }
          newY = init.y + init.height - newHeight;
          break;
        case 's':
          newHeight = Math.max(20, init.height + dy);
          if (preserveRatio) {
            newWidth = newHeight * ratio;
            newX = init.x - (newWidth - init.width) / 2;
          }
          break;
        case 'e':
          newWidth = Math.max(20, init.width + dx);
          if (preserveRatio) {
            newHeight = newWidth / ratio;
            newY = init.y - (newHeight - init.height) / 2;
          }
          break;
        case 'w':
          newWidth = Math.max(20, init.width - dx);
          if (preserveRatio) {
            newHeight = newWidth / ratio;
            newY = init.y - (newHeight - init.height) / 2;
          }
          newX = init.x + init.width - newWidth;
          break;
      }

      img.width = Math.round(newWidth);
      img.height = Math.round(newHeight);
      img.x = Math.round(newX);
      img.y = Math.round(newY);

      renderImage(img);
      updatePropertiesPanel();
    }

    function stopResize() {
      if (state.isResizing) {
        saveHistory();
      }
      state.isResizing = false;
      state.resizeHandle = null;
    }

    // ===============================================
    // ROTATE
    // ===============================================
    function startRotate(e, imageData) {
      state.isRotating = true;
      state.initialState = { ...imageData };
      e.stopPropagation();
      e.preventDefault();
    }

    function handleRotate(e) {
      if (!state.isRotating || !state.selectedImageId) return;

      const img = getSelectedImage();
      if (!img) return;

      const wrapper = document.querySelector(`[data-id="${img.id}"]`);
      const rect = wrapper.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      let angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
      let degrees = Math.round((angle * 180 / Math.PI) + 90);
      
      // Snap to 15¬∞ when shift is pressed
      if (state.shiftPressed) {
        degrees = Math.round(degrees / 15) * 15;
      }
      
      img.rotation = degrees;
      renderImage(img);
      updatePropertiesPanel();
    }

    function stopRotate() {
      if (state.isRotating) {
        saveHistory();
      }
      state.isRotating = false;
    }

    // ===============================================
    // CROP (O≈òEZ)
    // ===============================================
    function openCropTool() {
      const img = getSelectedImage();
      if (!img) {
        showNotification('‚ùå Nejprve vyberte obr√°zek', 'error');
        return;
      }

      state.cropData = {
        imageId: img.id,
        selection: null,
        displayWidth: img.width,
        displayHeight: img.height
      };

      const cropOverlay = document.getElementById('cropOverlay');
      const cropImage = document.getElementById('cropImage');
      const cropSelection = document.getElementById('cropSelection');
      
      cropImage.src = img.originalSrc || img.src;
      cropSelection.style.display = 'none';
      cropOverlay.classList.add('active');

      // Setup crop drawing
      const container = document.getElementById('cropContainer');
      let isDrawing = false;
      let isResizingCrop = false;
      let isDraggingCrop = false;
      let startX, startY;
      let resizeHandle = null;
      let dragStartX, dragStartY, selStartX, selStartY;

      const updateCropSelection = () => {
        const scaleX = cropImage.naturalWidth / cropImage.offsetWidth;
        const scaleY = cropImage.naturalHeight / cropImage.offsetHeight;
        const w = parseInt(cropSelection.style.width) || 0;
        const h = parseInt(cropSelection.style.height) || 0;
        document.getElementById('cropInfo').textContent = 
          `V√Ωbƒõr: ${Math.round(w * scaleX)} √ó ${Math.round(h * scaleY)} px`;
        
        state.cropData.selection = {
          x: parseInt(cropSelection.style.left) * scaleX,
          y: parseInt(cropSelection.style.top) * scaleY,
          width: w * scaleX,
          height: h * scaleY
        };
      };

      const onMouseDown = (e) => {
        const rect = cropImage.getBoundingClientRect();
        
        // Check if clicking on a resize handle
        if (e.target.classList.contains('crop-handle')) {
          isResizingCrop = true;
          resizeHandle = e.target.dataset.handle;
          startX = e.clientX;
          startY = e.clientY;
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        
        // Check if clicking inside crop selection (for dragging)
        if (e.target === cropSelection || cropSelection.contains(e.target)) {
          isDraggingCrop = true;
          dragStartX = e.clientX;
          dragStartY = e.clientY;
          selStartX = parseInt(cropSelection.style.left) || 0;
          selStartY = parseInt(cropSelection.style.top) || 0;
          e.preventDefault();
          return;
        }
        
        // Start new selection
        if (e.target === cropImage) {
          isDrawing = true;
          startX = e.clientX - rect.left;
          startY = e.clientY - rect.top;
          
          cropSelection.style.left = `${startX}px`;
          cropSelection.style.top = `${startY}px`;
          cropSelection.style.width = '0px';
          cropSelection.style.height = '0px';
          cropSelection.style.display = 'block';
        }
      };

      const onMouseMove = (e) => {
        const imgRect = cropImage.getBoundingClientRect();
        
        if (isDraggingCrop) {
          const dx = e.clientX - dragStartX;
          const dy = e.clientY - dragStartY;
          let newX = selStartX + dx;
          let newY = selStartY + dy;
          const w = parseInt(cropSelection.style.width);
          const h = parseInt(cropSelection.style.height);
          
          // Clamp to image bounds
          newX = Math.max(0, Math.min(newX, cropImage.offsetWidth - w));
          newY = Math.max(0, Math.min(newY, cropImage.offsetHeight - h));
          
          cropSelection.style.left = `${newX}px`;
          cropSelection.style.top = `${newY}px`;
          updateCropSelection();
          return;
        }
        
        if (isResizingCrop) {
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          
          let left = parseInt(cropSelection.style.left);
          let top = parseInt(cropSelection.style.top);
          let width = parseInt(cropSelection.style.width);
          let height = parseInt(cropSelection.style.height);
          
          switch (resizeHandle) {
            case 'nw':
              left += dx; top += dy; width -= dx; height -= dy;
              break;
            case 'ne':
              top += dy; width += dx; height -= dy;
              break;
            case 'sw':
              left += dx; width -= dx; height += dy;
              break;
            case 'se':
              width += dx; height += dy;
              break;
          }
          
          // Clamp to valid values
          if (width >= 20 && left >= 0 && left + width <= cropImage.offsetWidth) {
            cropSelection.style.left = `${left}px`;
            cropSelection.style.width = `${width}px`;
          }
          if (height >= 20 && top >= 0 && top + height <= cropImage.offsetHeight) {
            cropSelection.style.top = `${top}px`;
            cropSelection.style.height = `${height}px`;
          }
          
          startX = e.clientX;
          startY = e.clientY;
          updateCropSelection();
          return;
        }
        
        if (!isDrawing) return;
        
        const currentX = Math.max(0, Math.min(e.clientX - imgRect.left, cropImage.offsetWidth));
        const currentY = Math.max(0, Math.min(e.clientY - imgRect.top, cropImage.offsetHeight));
        
        const x = Math.min(startX, currentX);
        const y = Math.min(startY, currentY);
        const w = Math.abs(currentX - startX);
        const h = Math.abs(currentY - startY);
        
        cropSelection.style.left = `${x}px`;
        cropSelection.style.top = `${y}px`;
        cropSelection.style.width = `${w}px`;
        cropSelection.style.height = `${h}px`;
        
        updateCropSelection();
      };

      const onMouseUp = () => {
        isDrawing = false;
        isResizingCrop = false;
        isDraggingCrop = false;
        resizeHandle = null;
        updateCropSelection();
      };

      container.addEventListener('mousedown', onMouseDown);
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);

      // Store cleanup function
      state.cropData.cleanup = () => {
        container.removeEventListener('mousedown', onMouseDown);
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      };
    }

    function applyCrop() {
      if (!state.cropData || !state.cropData.selection) {
        showNotification('‚ùå Nejprve vyberte oblast', 'error');
        return;
      }

      const img = state.images.find(i => i.id === state.cropData.imageId);
      if (!img) return;

      const sel = state.cropData.selection;
      if (sel.width < 10 || sel.height < 10) {
        showNotification('‚ùå V√Ωbƒõr je p≈ô√≠li≈° mal√Ω', 'error');
        return;
      }

      // Ulo≈æ√≠me p≈Øvodn√≠ zobrazovanou velikost
      const prevDisplayWidth = state.cropData.displayWidth;
      const prevDisplayHeight = state.cropData.displayHeight;

      // Create cropped image
      const tempCanvas = document.createElement('canvas');
      const ctx = tempCanvas.getContext('2d');
      tempCanvas.width = sel.width;
      tempCanvas.height = sel.height;

      const sourceImg = new Image();
      sourceImg.onload = () => {
        ctx.drawImage(
          sourceImg,
          sel.x, sel.y, sel.width, sel.height,
          0, 0, sel.width, sel.height
        );

        img.src = tempCanvas.toDataURL('image/png');
        img.originalSrc = img.src;
        
        // Zachovat p≈Øvodn√≠ zobrazenou velikost
        img.width = prevDisplayWidth;
        img.height = prevDisplayHeight;
        img.originalWidth = sel.width;
        img.originalHeight = sel.height;
        img.aspectRatio = sel.width / sel.height;

        saveHistory();
        renderImage(img);
        renderLayers();
        updatePropertiesPanel();
        closeCrop();
        showNotification('‚úÇÔ∏è Obr√°zek o≈ô√≠znut', 'success');
      };
      sourceImg.src = img.originalSrc || img.src;
    }

    function closeCrop() {
      if (state.cropData && state.cropData.cleanup) {
        state.cropData.cleanup();
      }
      state.cropData = null;
      document.getElementById('cropOverlay').classList.remove('active');
    }

    // ===============================================
    // PROPERTIES PANEL
    // ===============================================
    function updatePropertiesPanel() {
      const img = getSelectedImage();
      if (!img) return;

      document.getElementById('propX').value = img.x;
      document.getElementById('propY').value = img.y;
      document.getElementById('propWidth').value = img.width;
      document.getElementById('propHeight').value = img.height;
      document.getElementById('propRotation').value = img.rotation;
      document.getElementById('rotationValue').textContent = `${img.rotation}¬∞`;
      document.getElementById('propOpacity').value = img.opacity;
      document.getElementById('opacityValue').textContent = `${img.opacity}%`;
      document.getElementById('propZIndex').value = img.zIndex;
      
      // Chroma key
      document.getElementById('chromaKeyEnabled').checked = img.chromaKeyEnabled;
      document.getElementById('chromaKeyColor').value = img.chromaKeyColor || '#00ff00';
      document.getElementById('chromaKeyHex').value = img.chromaKeyColor || '#00ff00';
      document.getElementById('chromaKeyTolerance').value = img.chromaKeyTolerance || 30;
      document.getElementById('toleranceValue').textContent = img.chromaKeyTolerance || 30;
      
      // Show/hide chroma key controls
      const showChroma = img.chromaKeyEnabled;
      document.getElementById('chromaKeyColorRow').style.display = showChroma ? 'flex' : 'none';
      document.getElementById('chromaKeyToleranceRow').style.display = showChroma ? 'flex' : 'none';
    }

    function setupPropertyListeners() {
      // Position and size
      ['X', 'Y', 'Width', 'Height', 'ZIndex'].forEach(prop => {
        document.getElementById(`prop${prop}`).addEventListener('change', (e) => {
          const img = getSelectedImage();
          if (img) {
            const key = prop.toLowerCase();
            const value = parseInt(e.target.value) || 0;
            
            // Handle aspect ratio lock
            if ((key === 'width' || key === 'height') && document.getElementById('lockAspect').checked) {
              if (key === 'width') {
                img.width = value;
                img.height = Math.round(value / img.aspectRatio);
              } else {
                img.height = value;
                img.width = Math.round(value * img.aspectRatio);
              }
            } else {
              img[key] = value;
            }
            
            saveHistory();
            renderImage(img);
            renderLayers();
            updatePropertiesPanel();
          }
        });
      });

      // Rotation
      document.getElementById('propRotation').addEventListener('input', (e) => {
        const img = getSelectedImage();
        if (img) {
          img.rotation = parseInt(e.target.value);
          document.getElementById('rotationValue').textContent = `${img.rotation}¬∞`;
          renderImage(img);
        }
      });
      document.getElementById('propRotation').addEventListener('change', saveHistory);

      // Opacity
      document.getElementById('propOpacity').addEventListener('input', (e) => {
        const img = getSelectedImage();
        if (img) {
          img.opacity = parseInt(e.target.value);
          document.getElementById('opacityValue').textContent = `${img.opacity}%`;
          renderImage(img);
        }
      });
      document.getElementById('propOpacity').addEventListener('change', saveHistory);

      // Chroma key
      document.getElementById('chromaKeyEnabled').addEventListener('change', async (e) => {
        const img = getSelectedImage();
        if (img) {
          img.chromaKeyEnabled = e.target.checked;
          updatePropertiesPanel();
          await updateImageChromaKey(img);
          saveHistory();
        }
      });

      document.getElementById('chromaKeyColor').addEventListener('input', (e) => {
        document.getElementById('chromaKeyHex').value = e.target.value;
      });

      document.getElementById('chromaKeyColor').addEventListener('change', async (e) => {
        const img = getSelectedImage();
        if (img) {
          img.chromaKeyColor = e.target.value;
          await updateImageChromaKey(img);
          saveHistory();
        }
      });

      document.getElementById('chromaKeyHex').addEventListener('change', async (e) => {
        const value = e.target.value;
        if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
          document.getElementById('chromaKeyColor').value = value;
          const img = getSelectedImage();
          if (img) {
            img.chromaKeyColor = value;
            await updateImageChromaKey(img);
            saveHistory();
          }
        }
      });

      document.getElementById('chromaKeyTolerance').addEventListener('input', (e) => {
        document.getElementById('toleranceValue').textContent = e.target.value;
      });

      document.getElementById('chromaKeyTolerance').addEventListener('change', async (e) => {
        const img = getSelectedImage();
        if (img) {
          img.chromaKeyTolerance = parseInt(e.target.value);
          await updateImageChromaKey(img);
          saveHistory();
        }
      });

      // Eyedropper for chroma key
      document.getElementById('chromaKeyEyedropper').addEventListener('click', () => {
        const img = getSelectedImage();
        if (!img) return;
        
        const eyedropperBtn = document.getElementById('chromaKeyEyedropper');
        
        // Check if browser supports EyeDropper API
        if (window.EyeDropper) {
          const eyeDropper = new EyeDropper();
          eyeDropper.open().then(result => {
            const color = result.sRGBHex;
            document.getElementById('chromaKeyColor').value = color;
            document.getElementById('chromaKeyHex').value = color;
            img.chromaKeyColor = color;
            updateImageChromaKey(img);
            saveHistory();
          }).catch(err => {
            // User cancelled
          });
        } else {
          // Fallback: pick from image on canvas
          showNotification('üíß Kliknƒõte na obr√°zek pro v√Ωbƒõr barvy', 'info');
          eyedropperBtn.classList.add('active');
          
          const wrapper = document.querySelector(`[data-id="${img.id}"]`);
          if (!wrapper) return;
          
          const imgEl = wrapper.querySelector('img');
          
          const pickColor = (e) => {
            const rect = imgEl.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Create temp canvas to read pixel
            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d');
            tempCanvas.width = imgEl.naturalWidth;
            tempCanvas.height = imgEl.naturalHeight;
            
            const tempImg = new Image();
            tempImg.crossOrigin = 'anonymous';
            tempImg.onload = () => {
              ctx.drawImage(tempImg, 0, 0);
              const scaleX = tempImg.naturalWidth / imgEl.offsetWidth;
              const scaleY = tempImg.naturalHeight / imgEl.offsetHeight;
              const px = Math.floor(x * scaleX);
              const py = Math.floor(y * scaleY);
              
              try {
                const pixel = ctx.getImageData(px, py, 1, 1).data;
                const color = `#${pixel[0].toString(16).padStart(2, '0')}${pixel[1].toString(16).padStart(2, '0')}${pixel[2].toString(16).padStart(2, '0')}`;
                
                document.getElementById('chromaKeyColor').value = color;
                document.getElementById('chromaKeyHex').value = color;
                img.chromaKeyColor = color;
                updateImageChromaKey(img);
                saveHistory();
                showNotification(`üíß Barva vybr√°na: ${color}`, 'success');
              } catch (err) {
                showNotification('‚ùå Nelze p≈ôeƒç√≠st barvu', 'error');
              }
            };
            tempImg.src = img.originalSrc || img.src;
            
            wrapper.removeEventListener('click', pickColor);
            eyedropperBtn.classList.remove('active');
          };
          
          wrapper.addEventListener('click', pickColor, { once: true });
          
          // Cancel on escape
          const cancelPick = (e) => {
            if (e.key === 'Escape') {
              wrapper.removeEventListener('click', pickColor);
              eyedropperBtn.classList.remove('active');
              document.removeEventListener('keydown', cancelPick);
            }
          };
          document.addEventListener('keydown', cancelPick);
        }
      });

      // Quick actions
      document.getElementById('flipH').addEventListener('click', () => {
        const img = getSelectedImage();
        if (img) {
          img.flipH = !img.flipH;
          saveHistory();
          renderImage(img);
        }
      });

      document.getElementById('flipV').addEventListener('click', () => {
        const img = getSelectedImage();
        if (img) {
          img.flipV = !img.flipV;
          saveHistory();
          renderImage(img);
        }
      });

      document.getElementById('duplicateBtn').addEventListener('click', () => {
        if (state.selectedImageId) duplicateImage(state.selectedImageId);
      });

      document.getElementById('deleteBtn').addEventListener('click', () => {
        if (state.selectedImageId) deleteImage(state.selectedImageId);
      });

      document.getElementById('cropSelectedBtn').addEventListener('click', openCropTool);

      document.getElementById('resetTransformBtn').addEventListener('click', () => {
        const img = getSelectedImage();
        if (img) {
          img.rotation = 0;
          img.flipH = false;
          img.flipV = false;
          img.opacity = 100;
          saveHistory();
          renderImage(img);
          updatePropertiesPanel();
          showNotification('üîÑ Transformace resetov√°na', 'info');
        }
      });
    }

    // ===============================================
    // LAYERS PANEL
    // ===============================================
    function renderLayers() {
      layersList.innerHTML = '';
      
      const sorted = [...state.images].sort((a, b) => b.zIndex - a.zIndex);
      
      sorted.forEach(img => {
        const item = document.createElement('div');
        item.className = 'layer-item' + (img.id === state.selectedImageId ? ' selected' : '');
        item.dataset.id = img.id;
        
        item.innerHTML = `
          <span class="layer-drag-handle">‚ãÆ‚ãÆ</span>
          <button class="layer-visibility ${img.visible ? '' : 'hidden'}">
            ${img.visible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'}
          </button>
          <div class="layer-thumb"><img src="${img.src}" alt=""></div>
          <div class="layer-info">
            <div class="layer-name">${img.name}</div>
            <div class="layer-meta">${img.width} √ó ${img.height}px ‚Ä¢ Z: ${img.zIndex}</div>
          </div>
          <div class="layer-actions">
            <button class="layer-action-btn" data-action="up" title="Posunout v√Ω≈°">‚¨ÜÔ∏è</button>
            <button class="layer-action-btn" data-action="down" title="Posunout n√≠≈æ">‚¨áÔ∏è</button>
            <button class="layer-action-btn" data-action="delete" title="Smazat">üóëÔ∏è</button>
          </div>
        `;

        // Visibility toggle
        item.querySelector('.layer-visibility').addEventListener('click', (e) => {
          e.stopPropagation();
          img.visible = !img.visible;
          saveHistory();
          renderImage(img);
          renderLayers();
        });

        // Layer actions
        item.querySelectorAll('.layer-action-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            handleLayerAction(img.id, btn.dataset.action);
          });
        });

        // Select on click
        item.addEventListener('click', () => selectImage(img.id));

        layersList.appendChild(item);
      });
    }

    function handleLayerAction(id, action) {
      const img = state.images.find(i => i.id === id);
      if (!img) return;

      switch (action) {
        case 'up':
          img.zIndex++;
          break;
        case 'down':
          img.zIndex = Math.max(1, img.zIndex - 1);
          break;
        case 'delete':
          deleteImage(id);
          return;
      }
      
      saveHistory();
      renderAllImages();
      renderLayers();
      selectImage(id);
    }

    // ===============================================
    // CANVAS SETTINGS
    // ===============================================
    function setupCanvasSettings() {
      document.getElementById('canvasWidth').addEventListener('change', (e) => {
        canvas.style.width = `${e.target.value}px`;
        updateStatus();
        autoSave();
      });

      document.getElementById('canvasHeight').addEventListener('change', (e) => {
        canvas.style.height = `${e.target.value}px`;
        updateStatus();
        autoSave();
      });

      document.getElementById('canvasBgColor').addEventListener('input', (e) => {
        document.getElementById('canvasBgHex').value = e.target.value;
        if (!document.getElementById('transparentBg').checked) {
          canvas.style.backgroundColor = e.target.value;
          canvas.classList.remove('transparent-bg');
        }
      });

      document.getElementById('canvasBgColor').addEventListener('change', (e) => {
        autoSave();
      });

      document.getElementById('canvasBgHex').addEventListener('change', (e) => {
        const value = e.target.value;
        if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
          document.getElementById('canvasBgColor').value = value;
          if (!document.getElementById('transparentBg').checked) {
            canvas.style.backgroundColor = value;
          }
          autoSave();
        }
      });

      document.getElementById('transparentBg').addEventListener('change', (e) => {
        if (e.target.checked) {
          canvas.classList.add('transparent-bg');
        } else {
          canvas.classList.remove('transparent-bg');
          canvas.style.backgroundColor = document.getElementById('canvasBgColor').value;
        }
        autoSave();
      });

      document.getElementById('clearStorageBtn').addEventListener('click', () => {
        if (confirm('Opravdu chcete vymazat v≈°echna ulo≈æen√° data? Tato akce je nevratn√°.')) {
          clearLocalStorage();
          location.reload();
        }
      });
    }

    // ===============================================
    // FILE HANDLING
    // ===============================================
    function handleFiles(files) {
      Array.from(files).forEach(file => {
        if (!file.type.startsWith('image/')) {
          showNotification(`‚ùå ${file.name} nen√≠ obr√°zek`, 'error');
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => addImage(e.target.result, file.name);
        reader.readAsDataURL(file);
      });
    }

    function setupFileHandling() {
      document.getElementById('addImageBtn').addEventListener('click', () => fileInput.click());

      fileInput.addEventListener('change', (e) => {
        handleFiles(e.target.files);
        e.target.value = '';
      });

      canvasWrapper.addEventListener('dragenter', (e) => {
        e.preventDefault();
        dropZone.classList.add('active');
      });

      canvasWrapper.addEventListener('dragover', (e) => e.preventDefault());

      canvasWrapper.addEventListener('dragleave', (e) => {
        if (!canvasWrapper.contains(e.relatedTarget)) {
          dropZone.classList.remove('active');
        }
      });

      canvasWrapper.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('active');
        handleFiles(e.dataTransfer.files);
      });
    }

    // ===============================================
    // EXPORT
    // ===============================================
    function setupExport() {
      const modal = document.getElementById('exportModal');
      const formatSelect = document.getElementById('exportFormat');
      const qualityRow = document.getElementById('jpegQualityRow');
      const qualitySlider = document.getElementById('exportQuality');
      const qualityValue = document.getElementById('qualityValue');

      document.getElementById('exportBtn').addEventListener('click', () => modal.classList.add('active'));
      document.getElementById('cancelExport').addEventListener('click', () => modal.classList.remove('active'));

      formatSelect.addEventListener('change', () => {
        qualityRow.style.display = formatSelect.value === 'jpeg' ? 'flex' : 'none';
      });

      qualitySlider.addEventListener('input', () => {
        qualityValue.textContent = `${qualitySlider.value}%`;
      });

      document.getElementById('confirmExport').addEventListener('click', async () => {
        const filename = document.getElementById('exportFilename').value || 'kolaz';
        const format = formatSelect.value;
        const quality = qualitySlider.value / 100;

        const prevSelected = state.selectedImageId;
        selectImage(null);

        try {
          if (format === 'svg') {
            // SVG Export
            await exportAsSVG(filename);
          } else {
            // PNG/JPEG Export
            const exportCanvas = await html2canvas(canvas, {
              backgroundColor: document.getElementById('transparentBg').checked ? null : canvas.style.backgroundColor,
              scale: 2,
              useCORS: true
            });

            const link = document.createElement('a');
            link.download = `${filename}.${format}`;
            link.href = format === 'jpeg' 
              ? exportCanvas.toDataURL('image/jpeg', quality)
              : exportCanvas.toDataURL('image/png');
            link.click();
            
            showNotification('‚úÖ Obr√°zek exportov√°n!', 'success');
          }
        } catch (err) {
          showNotification('‚ùå Chyba p≈ôi exportu', 'error');
          console.error(err);
        }

        selectImage(prevSelected);
        modal.classList.remove('active');
      });
    }

    async function exportAsSVG(filename) {
      const canvasWidth = canvas.offsetWidth;
      const canvasHeight = canvas.offsetHeight;
      const isTransparent = document.getElementById('transparentBg').checked;
      const bgColor = canvas.style.backgroundColor || '#ffffff';

      // Se≈ôadit obr√°zky podle z-index
      const sortedImages = [...state.images].sort((a, b) => a.zIndex - b.zIndex);

      let svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
     width="${canvasWidth}" height="${canvasHeight}" viewBox="0 0 ${canvasWidth} ${canvasHeight}">
  <defs>
    <style>
      .canvas-bg { fill: ${isTransparent ? 'none' : bgColor}; }
    </style>
  </defs>
  <rect class="canvas-bg" width="100%" height="100%"/>
`;

      for (const img of sortedImages) {
        const centerX = img.x + img.width / 2;
        const centerY = img.y + img.height / 2;
        
        // Sestavit transformace
        const transforms = [];
        transforms.push(`translate(${centerX}, ${centerY})`);
        
        if (img.rotation) {
          transforms.push(`rotate(${img.rotation})`);
        }
        
        const scaleX = img.flipH ? -1 : 1;
        const scaleY = img.flipV ? -1 : 1;
        if (scaleX !== 1 || scaleY !== 1) {
          transforms.push(`scale(${scaleX}, ${scaleY})`);
        }
        
        transforms.push(`translate(${-img.width / 2}, ${-img.height / 2})`);
        
        const transformStr = transforms.join(' ');
        const opacity = (img.opacity || 100) / 100;

        svgContent += `  <image 
    xlink:href="${img.src}" 
    width="${img.width}" 
    height="${img.height}"
    transform="${transformStr}"
    opacity="${opacity}"
    preserveAspectRatio="none"
  />
`;
      }

      svgContent += `</svg>`;

      // St√°hnout SVG
      const blob = new Blob([svgContent], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.download = `${filename}.svg`;
      link.href = url;
      link.click();
      URL.revokeObjectURL(url);

      showNotification('‚úÖ SVG exportov√°no!', 'success');
    }

    // ===============================================
    // KEYBOARD SHORTCUTS
    // ===============================================
    function setupKeyboard() {
      document.addEventListener('keydown', (e) => {
        state.shiftPressed = e.shiftKey;
        state.altPressed = e.altKey;
        
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        const img = getSelectedImage();
        const step = e.shiftKey ? 10 : 1;

        switch (e.key) {
          case 'ArrowUp':
            if (img) { 
              img.y = state.gridEnabled ? snapToGrid(img.y - step) : img.y - step;
              saveHistory(); renderImage(img); updatePropertiesPanel(); 
            }
            e.preventDefault();
            break;
          case 'ArrowDown':
            if (img) { 
              img.y = state.gridEnabled ? snapToGrid(img.y + step) : img.y + step;
              saveHistory(); renderImage(img); updatePropertiesPanel(); 
            }
            e.preventDefault();
            break;
          case 'ArrowLeft':
            if (img) { 
              img.x = state.gridEnabled ? snapToGrid(img.x - step) : img.x - step;
              saveHistory(); renderImage(img); updatePropertiesPanel(); 
            }
            e.preventDefault();
            break;
          case 'ArrowRight':
            if (img) { 
              img.x = state.gridEnabled ? snapToGrid(img.x + step) : img.x + step;
              saveHistory(); renderImage(img); updatePropertiesPanel(); 
            }
            e.preventDefault();
            break;
          case 'Delete':
          case 'Backspace':
            if (state.selectedImageId) deleteImage(state.selectedImageId);
            e.preventDefault();
            break;
          case 'd':
            if (e.ctrlKey && state.selectedImageId) { duplicateImage(state.selectedImageId); e.preventDefault(); }
            break;
          case 'z':
            if (e.ctrlKey) { undo(); e.preventDefault(); }
            break;
          case 'y':
            if (e.ctrlKey) { redo(); e.preventDefault(); }
            break;
          case 's':
            if (e.ctrlKey && e.shiftKey) { 
              document.getElementById('exportBtn').click(); 
              e.preventDefault(); 
            } else if (e.ctrlKey) { 
              manualSave(); 
              e.preventDefault(); 
            }
            break;
          case 'c':
            if (!e.ctrlKey && state.selectedImageId) { openCropTool(); e.preventDefault(); }
            break;
          case 'g':
            if (!e.ctrlKey) { toggleGrid(); e.preventDefault(); }
            break;
          case 'PageUp':
            if (img) { img.zIndex++; saveHistory(); renderAllImages(); renderLayers(); selectImage(img.id); }
            e.preventDefault();
            break;
          case 'PageDown':
            if (img) { img.zIndex = Math.max(1, img.zIndex - 1); saveHistory(); renderAllImages(); renderLayers(); selectImage(img.id); }
            e.preventDefault();
            break;
          case '+':
          case '=':
            zoomIn();
            e.preventDefault();
            break;
          case '-':
            zoomOut();
            e.preventDefault();
            break;
          case '0':
            if (!e.ctrlKey) { resetZoom(); e.preventDefault(); }
            break;
          case '?':
            document.getElementById('shortcutsHelp').classList.toggle('visible');
            break;
          case 'Escape':
            selectImage(null);
            document.getElementById('shortcutsHelp').classList.remove('visible');
            document.getElementById('exportModal').classList.remove('active');
            closeCrop();
            break;
        }
      });

      document.addEventListener('keyup', (e) => {
        state.shiftPressed = e.shiftKey;
        state.altPressed = e.altKey;
      });
    }

    // ===============================================
    // ZOOM FUNCTIONS
    // ===============================================
    function setZoom(newZoom) {
      state.zoom = Math.max(0.25, Math.min(3, newZoom));
      const container = document.querySelector('.canvas-container');
      container.style.transform = `scale(${state.zoom})`;
      document.getElementById('zoomValue').textContent = `${Math.round(state.zoom * 100)}%`;
    }

    function zoomIn() {
      setZoom(state.zoom + 0.1);
    }

    function zoomOut() {
      setZoom(state.zoom - 0.1);
    }

    function resetZoom() {
      setZoom(1);
    }

    // ===============================================
    // GRID FUNCTIONS
    // ===============================================
    function toggleGrid() {
      state.gridEnabled = !state.gridEnabled;
      canvas.classList.toggle('show-grid', state.gridEnabled);
      document.getElementById('gridBtn').classList.toggle('active', state.gridEnabled);
      showNotification(state.gridEnabled ? '#Ô∏è‚É£ M≈ô√≠≈æka zapnuta' : '#Ô∏è‚É£ M≈ô√≠≈æka vypnuta', 'info');
    }

    function snapToGrid(value) {
      if (!state.gridEnabled) return value;
      return Math.round(value / state.gridSize) * state.gridSize;
    }

    // ===============================================
    // MOUSE EVENTS
    // ===============================================
    function setupMouseEvents() {
      document.addEventListener('mousemove', (e) => {
        handleDrag(e);
        handleResize(e);
        handleRotate(e);
      });

      document.addEventListener('mouseup', () => {
        stopDrag();
        stopResize();
        stopRotate();
      });

      canvas.addEventListener('mousedown', (e) => {
        if (e.target === canvas || e.target.classList.contains('empty-state')) {
          selectImage(null);
        }
      });

      // Wheel zoom
      canvasWrapper.addEventListener('wheel', (e) => {
        if (e.ctrlKey) {
          e.preventDefault();
          const delta = e.deltaY > 0 ? -0.1 : 0.1;
          setZoom(state.zoom + delta);
        }
      }, { passive: false });
    }

    // ===============================================
    // TOOLBAR & PANELS
    // ===============================================
    function setupToolbar() {
      document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          state.currentTool = btn.dataset.tool;
        });
      });

      document.getElementById('undoBtn').addEventListener('click', undo);
      document.getElementById('redoBtn').addEventListener('click', redo);
      document.getElementById('helpBtn').addEventListener('click', () => {
        document.getElementById('shortcutsHelp').classList.toggle('visible');
      });
      document.getElementById('cropBtn').addEventListener('click', openCropTool);
      document.getElementById('gridBtn').addEventListener('click', toggleGrid);
      
      // Ruƒçn√≠ ulo≈æen√≠
      document.getElementById('saveBtn').addEventListener('click', manualSave);
      
      // Nov√Ω projekt
      document.getElementById('newProjectBtn').addEventListener('click', () => {
        if (state.images.length === 0 || confirm('Opravdu chcete vytvo≈ôit nov√Ω projekt? Neulo≈æen√© zmƒõny budou ztraceny.')) {
          newProject();
        }
      });

      // Zoom controls
      document.getElementById('zoomIn').addEventListener('click', zoomIn);
      document.getElementById('zoomOut').addEventListener('click', zoomOut);
      document.getElementById('zoomReset').addEventListener('click', resetZoom);

      // Panel tabs
      document.querySelectorAll('.panel-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.panel-content').forEach(p => p.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById(`${tab.dataset.panel}Panel`).classList.add('active');
        });
      });

      // Crop controls
      document.getElementById('cancelCrop').addEventListener('click', closeCrop);
      document.getElementById('applyCrop').addEventListener('click', applyCrop);
    }

    // ===============================================
    // NEW PROJECT
    // ===============================================
    function newProject() {
      state.images = [];
      state.selectedImageId = null;
      state.history = [];
      state.historyIndex = -1;
      state.nextId = 1;
      
      // Reset canvas
      canvas.style.width = '800px';
      canvas.style.height = '600px';
      canvas.style.backgroundColor = '#ffffff';
      canvas.classList.remove('transparent-bg', 'show-grid');
      document.getElementById('canvasWidth').value = 800;
      document.getElementById('canvasHeight').value = 600;
      document.getElementById('canvasBgColor').value = '#ffffff';
      document.getElementById('canvasBgHex').value = '#ffffff';
      document.getElementById('transparentBg').checked = false;
      
      // Reset zoom & grid
      resetZoom();
      state.gridEnabled = false;
      document.getElementById('gridBtn').classList.remove('active');
      
      // Clear canvas
      canvas.querySelectorAll('.canvas-image').forEach(el => el.remove());
      const emptyState = canvas.querySelector('.empty-state');
      if (emptyState) emptyState.style.display = '';
      
      renderLayers();
      saveHistory();
      updateStatus();
      clearLocalStorage();
      
      showNotification('üìÑ Nov√Ω projekt vytvo≈ôen', 'success');
    }

    // ===============================================
    // LOCAL STORAGE - UKL√ÅD√ÅN√ç A NAƒå√çT√ÅN√ç
    // ===============================================
    const STORAGE_KEY = 'imageEditorState';

    function updateSaveStatus(status) {
      const el = document.getElementById('statusSave');
      if (status === 'saving') {
        el.textContent = 'üíæ Ukl√°d√°m...';
        el.className = 'status-item saving';
      } else if (status === 'saved') {
        el.textContent = 'üíæ Ulo≈æeno';
        el.className = 'status-item saved';
        state.lastSaved = Date.now();
      } else {
        el.textContent = 'üíæ Neulo≈æeno';
        el.className = 'status-item';
      }
    }

    function saveToLocalStorage() {
      try {
        updateSaveStatus('saving');
        
        const dataToSave = {
          images: state.images,
          canvasWidth: canvas.style.width,
          canvasHeight: canvas.style.height,
          canvasBgColor: document.getElementById('canvasBgColor').value,
          transparentBg: document.getElementById('transparentBg').checked,
          nextId: state.nextId,
          zoom: state.zoom,
          gridEnabled: state.gridEnabled,
          savedAt: Date.now()
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
        
        updateSaveStatus('saved');
        return true;
      } catch (err) {
        console.warn('Nelze ulo≈æit do localStorage:', err);
        updateSaveStatus('error');
        return false;
      }
    }

    function manualSave() {
      if (saveToLocalStorage()) {
        showNotification('üíæ Projekt ulo≈æen!', 'success');
      } else {
        showNotification('‚ùå Chyba p≈ôi ukl√°d√°n√≠', 'error');
      }
    }

    function loadFromLocalStorage() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (!saved) return false;

        const data = JSON.parse(saved);
        
        // Obnovit nastaven√≠ pl√°tna
        if (data.canvasWidth) {
          canvas.style.width = data.canvasWidth;
          document.getElementById('canvasWidth').value = parseInt(data.canvasWidth);
        }
        if (data.canvasHeight) {
          canvas.style.height = data.canvasHeight;
          document.getElementById('canvasHeight').value = parseInt(data.canvasHeight);
        }
        if (data.canvasBgColor) {
          document.getElementById('canvasBgColor').value = data.canvasBgColor;
          document.getElementById('canvasBgHex').value = data.canvasBgColor;
          canvas.style.backgroundColor = data.canvasBgColor;
        }
        if (data.transparentBg) {
          document.getElementById('transparentBg').checked = true;
          canvas.classList.add('transparent-bg');
        }
        if (data.nextId) {
          state.nextId = data.nextId;
        }
        if (data.zoom) {
          setZoom(data.zoom);
        }
        if (data.gridEnabled) {
          state.gridEnabled = true;
          canvas.classList.add('show-grid');
          document.getElementById('gridBtn').classList.add('active');
        }

        // Obnovit obr√°zky
        if (data.images && data.images.length > 0) {
          state.images = data.images;
          state.images.forEach(img => renderImage(img));
          renderLayers();
          updateStatus();
          
          // Skr√Ωt empty state
          const emptyState = canvas.querySelector('.empty-state');
          if (emptyState) emptyState.style.display = 'none';
          
          updateSaveStatus('saved');
          return true;
        }
        
        return false;
      } catch (err) {
        console.warn('Nelze naƒç√≠st z localStorage:', err);
        return false;
      }
    }

    function clearLocalStorage() {
      try {
        localStorage.removeItem(STORAGE_KEY);
      } catch (err) {
        console.warn('Nelze vymazat localStorage:', err);
      }
    }

    // Auto-save p≈ôi zmƒõn√°ch (debounced)
    let saveTimeout = null;
    function autoSave() {
      updateSaveStatus('');
      if (saveTimeout) clearTimeout(saveTimeout);
      saveTimeout = setTimeout(saveToLocalStorage, 500);
    }

    // ===============================================
    // INICIALIZACE
    // ===============================================
    function init() {
      setupToolbar();
      setupFileHandling();
      setupPropertyListeners();
      setupCanvasSettings();
      setupMouseEvents();
      setupKeyboard();
      setupExport();
      
      // Naƒç√≠st ulo≈æen√° data
      const hasData = loadFromLocalStorage();
      
      saveHistory();
      updateStatus();
      
      if (hasData) {
        showNotification('‚úÖ P≈ôedchoz√≠ pr√°ce obnovena', 'success');
      } else {
        showNotification('üé® Editor p≈ôipraven! P≈ôet√°hnƒõte obr√°zky na pl√°tno.', 'info');
      }
    }

    // P≈ôepsat saveHistory aby tak√© ukl√°dalo do localStorage
    const originalSaveHistory = saveHistory;
    saveHistory = function() {
      originalSaveHistory();
      autoSave();
    };

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
