<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üç™ Gener√°tor vykrajov√°tek na cukrov√≠</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: #1a1a1a;
      color: #e0e0e0;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .header h1 {
      font-size: 1.4rem;
      font-weight: 600;
      margin: 0;
      margin-bottom: 10px;
      color: #e0e0e0;
    }

    .main-content {
      display: grid;
      grid-template-columns: 420px 1fr;
      gap: 20px;
    }

    .controls-section {
      background-color: #2a2a2a;
      border: 1px solid #404040;
      border-radius: 8px;
      padding: 20px;
      height: fit-content;
      max-height: calc(100vh - 120px);
      overflow-y: auto;
    }

    .controls-section h2 {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 20px;
      color: #e0e0e0;
    }

    .section-divider {
      border: none;
      border-top: 1px solid #404040;
      margin: 20px 0;
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-group label {
      display: block;
      font-size: 0.85rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
      font-weight: 600;
    }

    .form-group input[type="number"] {
      width: 100%;
      padding: 8px 12px;
      background-color: #404040;
      border: 1px solid #555;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 0.9rem;
      transition: all 0.3s ease;
    }

    .form-group input[type="number"]:focus {
      outline: none;
      border-color: #6aa6fd;
    }

    .form-group input[type="range"] {
      width: 100%;
      height: 6px;
      background: linear-gradient(to right, #404040 0%, #6aa6fd 100%);
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      cursor: pointer;
    }

    .form-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: #6aa6fd;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .form-group input[type="range"]::-webkit-slider-thumb:hover {
      background: #5694f0;
      transform: scale(1.1);
    }

    .form-group input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #6aa6fd;
      border-radius: 50%;
      border: none;
      cursor: pointer;
    }

    .form-group input[type="color"] {
      width: 100%;
      height: 40px;
      padding: 4px;
      background-color: #404040;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .form-group input[type="color"]:hover {
      border-color: #6aa6fd;
    }

    .form-group select {
      width: 100%;
      padding: 8px 12px;
      background-color: #404040;
      border: 1px solid #555;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 0.9rem;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .form-group select:focus {
      outline: none;
      border-color: #6aa6fd;
    }

    .form-group select option {
      background-color: #404040;
      color: #e0e0e0;
    }

    .slider-value {
      display: inline-block;
      float: right;
      color: #6aa6fd;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .shape-options {
      display: none;
      margin-top: 10px;
    }

    .shape-options.active {
      display: block;
    }

    .inline-group {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    .btn {
      flex: 1;
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.3s ease;
      font-weight: 500;
    }

    .btn-primary {
      background-color: #6aa6fd;
      color: #1a1a1a;
    }

    .btn-primary:hover {
      background-color: #5694f0;
    }

    .btn-secondary {
      background-color: #404040;
      color: #e0e0e0;
      border: 1px solid #555;
    }

    .btn-secondary:hover {
      background-color: #505050;
      border-color: #666;
    }

    .btn-success {
      background-color: #4CAF50;
      color: white;
    }

    .btn-success:hover {
      background-color: #45a049;
    }

    .preview-section {
      background-color: #2a2a2a;
      border: 1px solid #404040;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }

    #preview-container {
      width: 100%;
      height: calc(100vh - 140px);
      min-height: 500px;
    }

    .info-panel {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background-color: rgba(42, 42, 42, 0.9);
      padding: 10px 15px;
      border-radius: 4px;
      font-size: 0.85rem;
      color: #888;
    }

    .info-panel span {
      color: #6aa6fd;
      font-weight: 600;
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 12px 20px;
      border-radius: 4px;
      font-size: 0.9rem;
      z-index: 1000;
      animation: slideIn 0.3s ease-out;
    }

    .notification.success {
      background-color: #4CAF50;
      color: white;
    }

    .notification.warning {
      background-color: #ff9800;
      color: white;
    }

    .notification.info {
      background-color: #6aa6fd;
      color: #1a1a1a;
    }

    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    @keyframes slideOut {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }

    .collar-info {
      background-color: #3a3a3a;
      border-radius: 4px;
      padding: 10px;
      margin-top: 10px;
      font-size: 0.85rem;
      color: #888;
    }

    .collar-info strong {
      color: #6aa6fd;
    }

    @media (max-width: 900px) {
      .main-content {
        grid-template-columns: 1fr;
      }
      
      #preview-container {
        height: 400px;
        min-height: 400px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üç™ Gener√°tor vykrajov√°tek na cukrov√≠</h1>
    </div>

    <div class="main-content">
      <div class="controls-section">
        <h2>‚öôÔ∏è Parametry vykrajov√°tka</h2>
        
        <div class="form-group">
          <label>Tvar vykrajov√°tka</label>
          <select id="shapeType" onchange="handleShapeChange()">
            <option value="star">‚≠ê Hvƒõzda</option>
            <option value="heart">‚ù§Ô∏è Srd√≠ƒçko</option>
            <option value="circle">‚ö™ Kruh</option>
            <option value="square">‚¨ú ƒåtverec</option>
            <option value="tree">üéÑ V√°noƒçn√≠ stromek</option>
            <option value="bell">üîî Zvoneƒçek</option>
            <option value="moon">üåô Mƒõs√≠c</option>
            <option value="gingerbread">üßç Pern√≠ƒçek</option>
            <option value="flower">üå∏ Kvƒõt</option>
          </select>
        </div>

        <div class="shape-options active" id="starOptions">
          <div class="form-group">
            <label>Poƒçet c√≠p≈Ø hvƒõzdy <span class="slider-value" id="starPointsValue">5</span></label>
            <input type="range" id="starPoints" min="3" max="12" value="5" oninput="updateStarPoints()">
          </div>
          <div class="form-group">
            <label>Hloubka z√°≈ôez≈Ø (%) <span class="slider-value" id="starDepthValue">50</span></label>
            <input type="range" id="starDepth" min="20" max="80" value="50" oninput="updateStarDepth()">
          </div>
        </div>

        <div class="shape-options" id="flowerOptions">
          <div class="form-group">
            <label>Poƒçet okvƒõtn√≠ch l√≠stk≈Ø <span class="slider-value" id="flowerPetalsValue">6</span></label>
            <input type="range" id="flowerPetals" min="4" max="12" value="6" oninput="updateFlowerPetals()">
          </div>
        </div>

        <hr class="section-divider">

        <div class="inline-group">
          <div class="form-group">
            <label>≈†√≠≈ôka (mm)</label>
            <input type="number" id="width" value="60" min="10" max="200" step="1">
          </div>
          <div class="form-group">
            <label>D√©lka (mm)</label>
            <input type="number" id="length" value="60" min="10" max="200" step="1">
          </div>
        </div>

        <div class="inline-group">
          <div class="form-group">
            <label>V√Ω≈°ka (mm)</label>
            <input type="number" id="height" value="15" min="5" max="50" step="1">
          </div>
          <div class="form-group">
            <label>Tlou≈°≈•ka stƒõny (mm)</label>
            <input type="number" id="wallThickness" value="1.2" min="0.4" max="5" step="0.1">
          </div>
        </div>

        <hr class="section-divider">

        <div class="form-group">
          <label>Zmƒõna velikosti (%) <span class="slider-value" id="scaleValue">100</span></label>
          <input type="range" id="scalePercent" min="50" max="200" value="100" oninput="updateScale()">
        </div>

        <div class="collar-info">
          <strong>üìê Automatick√© √∫pravy:</strong><br>
          ‚Ä¢ L√≠mec: v√Ω≈°ka 1 mm, ≈°√≠≈ôka +1 mm smƒõrem ven<br>
          ‚Ä¢ Horn√≠ hrana: zkosen√≠ na 50% tlou≈°≈•ky pro lep≈°√≠ ≈ôez√°n√≠
        </div>

        <hr class="section-divider">
        <h2>üé® Vzhled n√°hledu</h2>

        <div class="form-group">
          <label>Pr≈Øhlednost <span class="slider-value" id="opacityValue">100%</span></label>
          <input type="range" id="opacitySlider" min="20" max="100" value="100" oninput="updateOpacity()">
        </div>

        <div class="inline-group">
          <div class="form-group">
            <label>Barva pozad√≠</label>
            <input type="color" id="bgColorPicker" value="#1a1a1a" onchange="updateBgColor()">
          </div>
          <div class="form-group">
            <label>Barva objektu</label>
            <input type="color" id="objectColorPicker" value="#6aa6fd" onchange="generateCutter()">
          </div>
        </div>

        <div class="form-group">
          <label>Kvalita exportu</label>
          <select id="exportQuality">
            <option value="32">N√≠zk√° (rychl√Ω tisk)</option>
            <option value="64" selected>St≈ôedn√≠</option>
            <option value="128">Vysok√° (hlad≈°√≠ k≈ôivky)</option>
          </select>
        </div>

        <div class="button-group">
          <button class="btn btn-primary" onclick="generateCutter()">üîÑ Generovat</button>
          <button class="btn btn-secondary" onclick="resetParameters()">‚Ü©Ô∏è Reset</button>
        </div>

        <div class="button-group">
          <button class="btn btn-success" onclick="exportSTL()">üì• Export STL</button>
        </div>
      </div>

      <div class="preview-section">
        <div id="preview-container"></div>
        <div class="info-panel">
          Rozmƒõry: <span id="dimensionsInfo">60 √ó 60 √ó 15 mm</span> | 
          Stƒõna: <span id="wallInfo">1.2 mm</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    let scene, camera, renderer, cutterMesh;
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let rotation = { x: 0.3, y: 0 };
    let currentOpacity = 1.0;

    // Inicializace Three.js sc√©ny
    function initScene() {
      const container = document.getElementById('preview-container');
      
      scene = new THREE.Scene();
      scene.background = new THREE.Color('#1a1a1a');

      camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 2000);
      camera.position.set(0, 80, 150);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);

      // Osvƒõtlen√≠
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight1.position.set(100, 100, 100);
      scene.add(directionalLight1);

      const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
      directionalLight2.position.set(-100, 50, -100);
      scene.add(directionalLight2);

      // Event listeners pro rotaci
      container.addEventListener('mousedown', onMouseDown);
      container.addEventListener('mousemove', onMouseMove);
      container.addEventListener('mouseup', onMouseUp);
      container.addEventListener('mouseleave', onMouseUp);
      container.addEventListener('wheel', onMouseWheel);

      // Touch events
      container.addEventListener('touchstart', onTouchStart);
      container.addEventListener('touchmove', onTouchMove);
      container.addEventListener('touchend', onTouchEnd);

      window.addEventListener('resize', onWindowResize);

      generateCutter();
      animate();
    }

    function onMouseDown(event) {
      isDragging = true;
      previousMousePosition = { x: event.clientX, y: event.clientY };
    }

    function onMouseMove(event) {
      if (!isDragging) return;
      
      const deltaX = event.clientX - previousMousePosition.x;
      const deltaY = event.clientY - previousMousePosition.y;

      rotation.y += deltaX * 0.01;
      rotation.x += deltaY * 0.01;
      rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.x));

      previousMousePosition = { x: event.clientX, y: event.clientY };
    }

    function onMouseUp() {
      isDragging = false;
    }

    function onMouseWheel(event) {
      event.preventDefault();
      camera.position.z += event.deltaY * 0.1;
      camera.position.z = Math.max(50, Math.min(400, camera.position.z));
    }

    function onTouchStart(event) {
      if (event.touches.length === 1) {
        isDragging = true;
        previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
      }
    }

    function onTouchMove(event) {
      if (!isDragging || event.touches.length !== 1) return;
      
      const deltaX = event.touches[0].clientX - previousMousePosition.x;
      const deltaY = event.touches[0].clientY - previousMousePosition.y;

      rotation.y += deltaX * 0.01;
      rotation.x += deltaY * 0.01;
      rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.x));

      previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
    }

    function onTouchEnd() {
      isDragging = false;
    }

    function onWindowResize() {
      const container = document.getElementById('preview-container');
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      if (cutterMesh) {
        cutterMesh.rotation.x = rotation.x;
        cutterMesh.rotation.y = rotation.y;
      }
      
      renderer.render(scene, camera);
    }

    // Generov√°n√≠ 2D tvaru - vrac√≠ pole bod≈Ø {x, y}
    function generateShape(type, width, length, segments) {
      const points = [];
      const w = width / 2;
      const l = length / 2;

      switch (type) {
        case 'star': {
          const starPointsCount = parseInt(document.getElementById('starPoints').value);
          const starDepth = parseInt(document.getElementById('starDepth').value) / 100;
          const outerR = Math.min(w, l);
          const innerR = outerR * (1 - starDepth);
          
          for (let i = 0; i < starPointsCount * 2; i++) {
            const angle = (i * Math.PI / starPointsCount) - Math.PI / 2;
            const r = i % 2 === 0 ? outerR : innerR;
            points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
          }
          break;
        }

        case 'heart': {
          const steps = segments;
          for (let i = 0; i < steps; i++) {
            const t = (i / steps) * Math.PI * 2 - Math.PI; // Start od spodn√≠ ≈°piƒçky
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            points.push({ x: x * w / 18, y: y * l / 18 });
          }
          break;
        }

        case 'circle': {
          const steps = segments;
          for (let i = 0; i < steps; i++) {
            const angle = (i / steps) * Math.PI * 2;
            points.push({ x: Math.cos(angle) * w, y: Math.sin(angle) * l });
          }
          break;
        }

        case 'square': {
          const cornerR = Math.min(w, l) * 0.12;
          const cornerSteps = 6;
          
          // Zaƒç√≠n√°me vpravo naho≈ôe a jdeme CCW
          // Horn√≠ hrana (zleva doprava ukonƒçen√° p≈ôed rohem)
          // Prav√Ω horn√≠ roh
          for (let i = 0; i <= cornerSteps; i++) {
            const angle = -Math.PI/2 + (i / cornerSteps) * (Math.PI / 2);
            points.push({ 
              x: w - cornerR + Math.cos(angle) * cornerR, 
              y: l - cornerR - Math.sin(angle) * cornerR 
            });
          }
          // Prav√Ω doln√≠ roh
          for (let i = 0; i <= cornerSteps; i++) {
            const angle = 0 + (i / cornerSteps) * (Math.PI / 2);
            points.push({ 
              x: w - cornerR + Math.cos(angle) * cornerR, 
              y: -l + cornerR - Math.sin(angle) * cornerR 
            });
          }
          // Lev√Ω doln√≠ roh
          for (let i = 0; i <= cornerSteps; i++) {
            const angle = Math.PI/2 + (i / cornerSteps) * (Math.PI / 2);
            points.push({ 
              x: -w + cornerR + Math.cos(angle) * cornerR, 
              y: -l + cornerR - Math.sin(angle) * cornerR 
            });
          }
          // Lev√Ω horn√≠ roh
          for (let i = 0; i <= cornerSteps; i++) {
            const angle = Math.PI + (i / cornerSteps) * (Math.PI / 2);
            points.push({ 
              x: -w + cornerR + Math.cos(angle) * cornerR, 
              y: l - cornerR - Math.sin(angle) * cornerR 
            });
          }
          break;
        }

        case 'tree': {
          // Stromek - ≈°piƒçka naho≈ôe, kmen dole
          const treePoints = [
            [0, l],                    // ≈†piƒçka
            [w * 0.4, l * 0.35],       // Prav√° strana horn√≠ vƒõtve
            [w * 0.2, l * 0.35],       // Z√°≈ôez
            [w * 0.55, l * 0.0],       // Prav√° strana st≈ôedn√≠ vƒõtve
            [w * 0.3, l * 0.0],        // Z√°≈ôez
            [w * 0.7, -l * 0.4],       // Prav√° strana doln√≠ vƒõtve
            [w * 0.15, -l * 0.4],      // Kmen prav√° strana naho≈ôe
            [w * 0.15, -l],            // Kmen prav√° strana dole
            [-w * 0.15, -l],           // Kmen lev√° strana dole
            [-w * 0.15, -l * 0.4],     // Kmen lev√° strana naho≈ôe
            [-w * 0.7, -l * 0.4],      // Lev√° strana doln√≠ vƒõtve
            [-w * 0.3, l * 0.0],       // Z√°≈ôez
            [-w * 0.55, l * 0.0],      // Lev√° strana st≈ôedn√≠ vƒõtve
            [-w * 0.2, l * 0.35],      // Z√°≈ôez
            [-w * 0.4, l * 0.35],      // Lev√° strana horn√≠ vƒõtve
          ];
          treePoints.forEach(p => points.push({ x: p[0], y: p[1] }));
          break;
        }

        case 'bell': {
          // Zvoneƒçek - jednoduch√© body
          const bellPoints = [
            // Ou≈°ko naho≈ôe
            [0, l * 0.95],
            [w * 0.1, l * 0.85],
            [w * 0.08, l * 0.72],
            // Prav√° strana tƒõla - plynule se roz≈°i≈ôuje
            [w * 0.18, l * 0.65],
            [w * 0.28, l * 0.45],
            [w * 0.42, l * 0.2],
            [w * 0.58, -l * 0.1],
            [w * 0.75, -l * 0.4],
            [w * 0.88, -l * 0.7],
            // Spodn√≠ okraj - m√≠rnƒõ prohnut√Ω
            [w * 0.85, -l * 0.95],
            [w * 0.5, -l * 0.85],
            [0, -l * 0.8],
            [-w * 0.5, -l * 0.85],
            [-w * 0.85, -l * 0.95],
            // Lev√° strana tƒõla
            [-w * 0.88, -l * 0.7],
            [-w * 0.75, -l * 0.4],
            [-w * 0.58, -l * 0.1],
            [-w * 0.42, l * 0.2],
            [-w * 0.28, l * 0.45],
            [-w * 0.18, l * 0.65],
            // Ou≈°ko lev√° strana
            [-w * 0.08, l * 0.72],
            [-w * 0.1, l * 0.85],
          ];
          bellPoints.forEach(p => points.push({ x: p[0], y: p[1] }));
          break;
        }

        case 'moon': {
          // Srpek mƒõs√≠ce - klasick√Ω tvar C
          const steps = 32;
          
          // Vnƒõj≈°√≠ oblouk (cel√Ω p≈Ølkruh + trochu)
          for (let i = 0; i <= steps; i++) {
            const angle = Math.PI * 0.25 + (i / steps) * Math.PI * 1.5;
            points.push({ 
              x: Math.cos(angle) * w, 
              y: Math.sin(angle) * l 
            });
          }
          
          // Vnit≈ôn√≠ oblouk (men≈°√≠, posunut√Ω) - zpƒõt nahoru
          for (let i = steps; i >= 0; i--) {
            const angle = Math.PI * 0.35 + (i / steps) * Math.PI * 1.3;
            points.push({ 
              x: Math.cos(angle) * w * 0.55 + w * 0.35, 
              y: Math.sin(angle) * l * 0.55
            });
          }
          break;
        }

        case 'gingerbread': {
          const gPoints = [
            [0, l * 0.95],
            [-w * 0.2, l * 0.9],
            [-w * 0.25, l * 0.75],
            [-w * 0.2, l * 0.55],
            [-w * 0.15, l * 0.5],
            [-w * 0.35, l * 0.45],
            [-w * 0.9, l * 0.35],
            [-w * 0.95, l * 0.2],
            [-w * 0.85, l * 0.15],
            [-w * 0.35, l * 0.25],
            [-w * 0.25, l * 0.1],
            [-w * 0.3, -l * 0.15],
            [-w * 0.45, -l * 0.85],
            [-w * 0.4, -l * 0.95],
            [-w * 0.2, -l * 0.9],
            [-w * 0.1, -l * 0.25],
            [0, -l * 0.2],
            [w * 0.1, -l * 0.25],
            [w * 0.2, -l * 0.9],
            [w * 0.4, -l * 0.95],
            [w * 0.45, -l * 0.85],
            [w * 0.3, -l * 0.15],
            [w * 0.25, l * 0.1],
            [w * 0.35, l * 0.25],
            [w * 0.85, l * 0.15],
            [w * 0.95, l * 0.2],
            [w * 0.9, l * 0.35],
            [w * 0.35, l * 0.45],
            [w * 0.15, l * 0.5],
            [w * 0.2, l * 0.55],
            [w * 0.25, l * 0.75],
            [w * 0.2, l * 0.9]
          ];
          gPoints.forEach(p => points.push({ x: p[0], y: p[1] }));
          break;
        }

        case 'flower': {
          const petals = parseInt(document.getElementById('flowerPetals').value);
          const steps = segments;
          const outerR = Math.min(w, l);
          
          for (let i = 0; i < steps; i++) {
            const angle = (i / steps) * Math.PI * 2;
            const petalPhase = angle * petals;
            const r = outerR * (0.5 + 0.5 * Math.pow(Math.abs(Math.sin(petalPhase)), 0.7));
            points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
          }
          break;
        }
      }

      return points;
    }

    // V√Ωpoƒçet signed area pro urƒçen√≠ orientace polygonu
    function getSignedArea(points) {
      let area = 0;
      const n = points.length;
      for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        area += points[i].x * points[j].y;
        area -= points[j].x * points[i].y;
      }
      return area / 2;
    }

    // Offset cesty smƒõrem ven (kladn√Ω) nebo dovnit≈ô (z√°porn√Ω)
    function offsetPath(points, offset) {
      const n = points.length;
      const result = [];
      
      // Zjistit orientaci polygonu
      const area = getSignedArea(points);
      // Invertovat smƒõr podle orientace
      const direction = area >= 0 ? -1 : 1;
      
      for (let i = 0; i < n; i++) {
        const prev = points[(i - 1 + n) % n];
        const curr = points[i];
        const next = points[(i + 1) % n];
        
        const d1x = curr.x - prev.x;
        const d1y = curr.y - prev.y;
        const len1 = Math.sqrt(d1x * d1x + d1y * d1y) || 0.001;
        
        const d2x = next.x - curr.x;
        const d2y = next.y - curr.y;
        const len2 = Math.sqrt(d2x * d2x + d2y * d2y) || 0.001;
        
        // Norm√°ly kolm√© na hrany, smƒõr podle orientace polygonu
        const n1x = -d1y / len1 * direction;
        const n1y = d1x / len1 * direction;
        const n2x = -d2y / len2 * direction;
        const n2y = d2x / len2 * direction;
        
        // Pr≈Ømƒõrn√° norm√°la
        let nx = n1x + n2x;
        let ny = n1y + n2y;
        const nlen = Math.sqrt(nx * nx + ny * ny) || 0.001;
        nx /= nlen;
        ny /= nlen;
        
        // Miter korekce
        const dot = n1x * n2x + n1y * n2y;
        const miterScale = 1 / Math.max(0.5, Math.sqrt((1 + dot) / 2));
        const finalScale = Math.min(miterScale, 2.5);
        
        result.push({
          x: curr.x + nx * offset * finalScale,
          y: curr.y + ny * offset * finalScale
        });
      }
      
      return result;
    }

    // Vytvo≈ôen√≠ geometrie vykrajov√°tka
    function createCutterGeometry(params) {
      const { width, length, height, wallThickness, collarHeight, collarWidth, segments } = params;
      
      // V√Ω≈°ka zkosen√≠ (2mm nebo 20% v√Ω≈°ky, co je men≈°√≠)
      const taperHeight = Math.min(2, height * 0.2);
      const taperStart = height - taperHeight;
      
      // Z√°kladn√≠ obrys
      const baseShape = generateShape(
        document.getElementById('shapeType').value,
        width, length, segments
      );
      
      // Vnit≈ôn√≠ obrys (dovnit≈ô o tlou≈°≈•ku stƒõny)
      const innerShape = offsetPath(baseShape, -wallThickness);
      
      // Horn√≠ vnƒõj≈°√≠ obrys - z√∫≈æen√Ω o 50% tlou≈°≈•ky stƒõny
      const topOuterShape = offsetPath(baseShape, -wallThickness * 0.5);
      
      // L√≠mec - vnƒõj≈°√≠ obrys roz≈°√≠≈ôen√Ω smƒõrem VEN
      const collarOuter = offsetPath(baseShape, collarWidth);
      
      const vertices = [];
      const indices = [];
      const n = baseShape.length;

      // === VNƒöJ≈†√ç STƒöNA SPODN√ç ƒå√ÅST (od collarHeight do taperStart) ===
      const outerWallStart = 0;
      for (let i = 0; i < n; i++) {
        vertices.push(baseShape[i].x, collarHeight, baseShape[i].y);
        vertices.push(baseShape[i].x, taperStart, baseShape[i].y);
      }
      
      for (let i = 0; i < n; i++) {
        const next = (i + 1) % n;
        const i0 = outerWallStart + i * 2;
        const i1 = outerWallStart + i * 2 + 1;
        const i2 = outerWallStart + next * 2;
        const i3 = outerWallStart + next * 2 + 1;
        indices.push(i0, i2, i1);
        indices.push(i1, i2, i3);
      }
      
      // === VNƒöJ≈†√ç STƒöNA ZKOSEN√Å ƒå√ÅST (od taperStart do height) ===
      const taperWallStart = vertices.length / 3;
      for (let i = 0; i < n; i++) {
        vertices.push(baseShape[i].x, taperStart, baseShape[i].y);
        vertices.push(topOuterShape[i].x, height, topOuterShape[i].y);
      }
      
      for (let i = 0; i < n; i++) {
        const next = (i + 1) % n;
        const i0 = taperWallStart + i * 2;
        const i1 = taperWallStart + i * 2 + 1;
        const i2 = taperWallStart + next * 2;
        const i3 = taperWallStart + next * 2 + 1;
        indices.push(i0, i2, i1);
        indices.push(i1, i2, i3);
      }
      
      // === VNIT≈òN√ç STƒöNA (od 0 do height) ===
      const innerWallStart = vertices.length / 3;
      for (let i = 0; i < n; i++) {
        vertices.push(innerShape[i].x, 0, innerShape[i].y);
        vertices.push(innerShape[i].x, height, innerShape[i].y);
      }
      
      for (let i = 0; i < n; i++) {
        const next = (i + 1) % n;
        const i0 = innerWallStart + i * 2;
        const i1 = innerWallStart + i * 2 + 1;
        const i2 = innerWallStart + next * 2;
        const i3 = innerWallStart + next * 2 + 1;
        indices.push(i0, i1, i2);
        indices.push(i1, i3, i2);
      }
      
      // === L√çMEC - VNƒöJ≈†√ç STƒöNA (od 0 do collarHeight) ===
      const collarWallStart = vertices.length / 3;
      for (let i = 0; i < n; i++) {
        vertices.push(collarOuter[i].x, 0, collarOuter[i].y);
        vertices.push(collarOuter[i].x, collarHeight, collarOuter[i].y);
      }
      
      for (let i = 0; i < n; i++) {
        const next = (i + 1) % n;
        const i0 = collarWallStart + i * 2;
        const i1 = collarWallStart + i * 2 + 1;
        const i2 = collarWallStart + next * 2;
        const i3 = collarWallStart + next * 2 + 1;
        indices.push(i0, i2, i1);
        indices.push(i1, i2, i3);
      }
      
      // === SPODN√ç PLOCHA (mezi collarOuter a innerShape na Y=0) ===
      const bottomStart = vertices.length / 3;
      for (let i = 0; i < n; i++) {
        vertices.push(collarOuter[i].x, 0, collarOuter[i].y);
      }
      for (let i = 0; i < n; i++) {
        vertices.push(innerShape[i].x, 0, innerShape[i].y);
      }
      
      for (let i = 0; i < n; i++) {
        const next = (i + 1) % n;
        const o0 = bottomStart + i;
        const o1 = bottomStart + next;
        const i0 = bottomStart + n + i;
        const i1 = bottomStart + n + next;
        indices.push(o0, i0, o1);
        indices.push(o1, i0, i1);
      }
      
      // === HORN√ç PLOCHA L√çMCE (mezi collarOuter a baseShape na Y=collarHeight) ===
      const collarTopStart = vertices.length / 3;
      for (let i = 0; i < n; i++) {
        vertices.push(collarOuter[i].x, collarHeight, collarOuter[i].y);
      }
      for (let i = 0; i < n; i++) {
        vertices.push(baseShape[i].x, collarHeight, baseShape[i].y);
      }
      
      for (let i = 0; i < n; i++) {
        const next = (i + 1) % n;
        const o0 = collarTopStart + i;
        const o1 = collarTopStart + next;
        const i0 = collarTopStart + n + i;
        const i1 = collarTopStart + n + next;
        indices.push(o0, o1, i0);
        indices.push(i0, o1, i1);
      }
      
      // === HORN√ç UZAV≈òEN√ç (mezi topOuterShape a innerShape na Y=height) ===
      const topStart = vertices.length / 3;
      for (let i = 0; i < n; i++) {
        vertices.push(topOuterShape[i].x, height, topOuterShape[i].y);
      }
      for (let i = 0; i < n; i++) {
        vertices.push(innerShape[i].x, height, innerShape[i].y);
      }
      
      for (let i = 0; i < n; i++) {
        const next = (i + 1) % n;
        const o0 = topStart + i;
        const o1 = topStart + next;
        const i0 = topStart + n + i;
        const i1 = topStart + n + next;
        indices.push(o0, i0, o1);
        indices.push(o1, i0, i1);
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();

      return geometry;
    }

    // Generov√°n√≠ vykrajov√°tka
    function generateCutter() {
      const scale = parseInt(document.getElementById('scalePercent').value) / 100;
      const width = parseFloat(document.getElementById('width').value) * scale;
      const length = parseFloat(document.getElementById('length').value) * scale;
      const height = parseFloat(document.getElementById('height').value);
      const wallThickness = parseFloat(document.getElementById('wallThickness').value);
      
      const collarHeight = 1;
      const collarWidth = 1;
      
      const segments = 64;

      const params = {
        width,
        length,
        height,
        wallThickness,
        collarHeight,
        collarWidth,
        segments
      };

      if (cutterMesh) {
        scene.remove(cutterMesh);
        cutterMesh.geometry.dispose();
        cutterMesh.material.dispose();
      }

      const geometry = createCutterGeometry(params);
      const color = document.getElementById('objectColorPicker').value;
      
      const material = new THREE.MeshPhongMaterial({
        color: color,
        transparent: currentOpacity < 1,
        opacity: currentOpacity,
        side: THREE.DoubleSide
      });

      cutterMesh = new THREE.Mesh(geometry, material);
      scene.add(cutterMesh);

      document.getElementById('dimensionsInfo').textContent = 
        `${width.toFixed(1)} √ó ${length.toFixed(1)} √ó ${height.toFixed(1)} mm`;
      document.getElementById('wallInfo').textContent = `${wallThickness.toFixed(1)} mm`;
    }

    // Export do STL
    function exportSTL() {
      if (!cutterMesh) {
        showNotification('Nejprve vygenerujte vykrajov√°tko', 'warning');
        return;
      }

      showNotification('Generuji STL soubor...', 'info');

      const scale = parseInt(document.getElementById('scalePercent').value) / 100;
      const width = parseFloat(document.getElementById('width').value) * scale;
      const length = parseFloat(document.getElementById('length').value) * scale;
      const height = parseFloat(document.getElementById('height').value);
      const wallThickness = parseFloat(document.getElementById('wallThickness').value);
      const segments = parseInt(document.getElementById('exportQuality').value);

      const params = {
        width,
        length,
        height,
        wallThickness,
        collarHeight: 1,
        collarWidth: 1,
        segments
      };

      const exportGeometry = createCutterGeometry(params);
      exportGeometry.computeVertexNormals();

      const nonIndexed = exportGeometry.toNonIndexed();
      const vertices = nonIndexed.attributes.position.array;

      let stl = 'solid cookie_cutter\n';

      for (let i = 0; i < vertices.length; i += 9) {
        const v1 = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
        const v2 = new THREE.Vector3(vertices[i + 3], vertices[i + 4], vertices[i + 5]);
        const v3 = new THREE.Vector3(vertices[i + 6], vertices[i + 7], vertices[i + 8]);

        const normal = new THREE.Vector3()
          .crossVectors(
            new THREE.Vector3().subVectors(v2, v1),
            new THREE.Vector3().subVectors(v3, v1)
          )
          .normalize();

        stl += `  facet normal ${normal.x} ${normal.y} ${normal.z}\n`;
        stl += '    outer loop\n';
        stl += `      vertex ${v1.x} ${v1.y} ${v1.z}\n`;
        stl += `      vertex ${v2.x} ${v2.y} ${v2.z}\n`;
        stl += `      vertex ${v3.x} ${v3.y} ${v3.z}\n`;
        stl += '    endloop\n';
        stl += '  endfacet\n';
      }

      stl += 'endsolid cookie_cutter\n';

      exportGeometry.dispose();
      nonIndexed.dispose();

      const shapeName = document.getElementById('shapeType').value;
      downloadFile(stl, `vykrajovatko_${shapeName}.stl`, 'text/plain');
      showNotification('STL soubor exportov√°n', 'success');
    }

    function downloadFile(content, filename, contentType) {
      const blob = new Blob([content], { type: contentType });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    function handleShapeChange() {
      const shape = document.getElementById('shapeType').value;
      
      document.querySelectorAll('.shape-options').forEach(el => el.classList.remove('active'));
      
      if (shape === 'star') {
        document.getElementById('starOptions').classList.add('active');
      } else if (shape === 'flower') {
        document.getElementById('flowerOptions').classList.add('active');
      }
      
      generateCutter();
    }

    function updateStarPoints() {
      const value = document.getElementById('starPoints').value;
      document.getElementById('starPointsValue').textContent = value;
      generateCutter();
    }

    function updateStarDepth() {
      const value = document.getElementById('starDepth').value;
      document.getElementById('starDepthValue').textContent = value;
      generateCutter();
    }

    function updateFlowerPetals() {
      const value = document.getElementById('flowerPetals').value;
      document.getElementById('flowerPetalsValue').textContent = value;
      generateCutter();
    }

    function updateScale() {
      const value = document.getElementById('scalePercent').value;
      document.getElementById('scaleValue').textContent = value;
      generateCutter();
    }

    function updateOpacity() {
      const value = document.getElementById('opacitySlider').value;
      document.getElementById('opacityValue').textContent = value + '%';
      currentOpacity = value / 100;
      
      if (cutterMesh) {
        cutterMesh.material.transparent = currentOpacity < 1;
        cutterMesh.material.opacity = currentOpacity;
      }
    }

    function updateBgColor() {
      const color = document.getElementById('bgColorPicker').value;
      scene.background = new THREE.Color(color);
    }

    function resetParameters() {
      document.getElementById('shapeType').value = 'star';
      document.getElementById('starPoints').value = 5;
      document.getElementById('starPointsValue').textContent = '5';
      document.getElementById('starDepth').value = 50;
      document.getElementById('starDepthValue').textContent = '50';
      document.getElementById('flowerPetals').value = 6;
      document.getElementById('flowerPetalsValue').textContent = '6';
      document.getElementById('width').value = 60;
      document.getElementById('length').value = 60;
      document.getElementById('height').value = 15;
      document.getElementById('wallThickness').value = 1.2;
      document.getElementById('scalePercent').value = 100;
      document.getElementById('scaleValue').textContent = '100';
      document.getElementById('opacitySlider').value = 100;
      document.getElementById('opacityValue').textContent = '100%';
      document.getElementById('bgColorPicker').value = '#1a1a1a';
      document.getElementById('objectColorPicker').value = '#6aa6fd';
      document.getElementById('exportQuality').value = '64';
      
      currentOpacity = 1.0;
      rotation.x = 0.3;
      rotation.y = 0;
      
      scene.background = new THREE.Color('#1a1a1a');
      
      document.querySelectorAll('.shape-options').forEach(el => el.classList.remove('active'));
      document.getElementById('starOptions').classList.add('active');
      
      generateCutter();
      showNotification('Parametry resetov√°ny', 'info');
    }

    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      document.body.appendChild(notification);

      setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-out';
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    }

    document.querySelectorAll('input[type="number"]').forEach(input => {
      input.addEventListener('change', generateCutter);
    });

    window.addEventListener('DOMContentLoaded', initScene);
  </script>
</body>
</html>
