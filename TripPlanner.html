<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokroƒçil√Ω spr√°vce mapov√Ωch tras</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 380px;
            background: #2d2d2d;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: transform 0.3s ease;
        }

        .sidebar-header {
            padding: 20px;
            background: #333;
            border-bottom: 1px solid #444;
        }

        .sidebar-header h2 {
            color: #4CAF50;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .tabs {
            display: flex;
            margin-bottom: 15px;
        }

        .tab {
            flex: 1;
            padding: 8px 12px;
            background: #444;
            border: none;
            color: #bbb;
            cursor: pointer;
            font-size: 11px;
            border-radius: 4px 4px 0 0;
            margin-right: 2px;
        }

        .tab.active {
            background: #4CAF50;
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .map-controls {
            margin-bottom: 15px;
        }

        .map-controls label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #bbb;
        }

        .map-controls select, .map-controls input {
            width: 100%;
            padding: 8px;
            background: #444;
            border: 1px solid #555;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 12px;
            margin-bottom: 10px;
        }

        .control-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .control-group input {
            flex: 1;
            margin-bottom: 0;
        }

        .color-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .color-item {
            flex: 1;
        }

        .color-item label {
            font-size: 11px;
            margin-bottom: 3px;
        }

        .color-item input[type="color"] {
            width: 100%;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .list-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 12px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .btn:hover {
            background: #45a049;
            transform: translateY(-1px);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .btn-danger {
            background: #f44336;
        }

        .btn-danger:hover {
            background: #da190b;
        }

        .btn-secondary {
            background: #666;
        }

        .btn-secondary:hover {
            background: #555;
        }

        .btn-warning {
            background: #ff9800;
        }

        .btn-warning:hover {
            background: #e68900;
        }

        .btn-info {
            background: #2196F3;
        }

        .btn-info:hover {
            background: #1976D2;
        }

        .btn-success {
            background: #4CAF50;
        }

        .btn-success:hover {
            background: #45a049;
        }

        .routes-list {
            flex: 1;
            overflow-y: auto;
            padding: 0 20px 20px;
        }

        .route-item {
            background: #383838;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .route-item:hover {
            background: #404040;
            border-color: #4CAF50;
            transform: translateX(2px);
        }

        .route-item.selected {
            border-color: #4CAF50;
            background: #404040;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
        }

        .route-item.highlighted {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { background: #404040; }
            50% { background: #4CAF50; }
            100% { background: #404040; }
        }

        .route-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .route-name {
            font-weight: bold;
            color: #4CAF50;
            flex: 1;
        }

        .route-type {
            background: #555;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            color: #bbb;
        }

        .route-info {
            font-size: 12px;
            color: #bbb;
            margin-bottom: 4px;
        }

        .route-distance {
            font-size: 12px;
            color: #ffeb3b;
        }

        .route-notes {
            font-size: 11px;
            color: #aaa;
            font-style: italic;
            margin-top: 4px;
        }

        .route-actions {
            display: flex;
            gap: 4px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .point-item {
            background: #444;
            border: 1px solid #666;
            border-radius: 4px;
            padding: 8px;
            margin: 4px 0;
            font-size: 11px;
        }

        .point-item.selected {
            border-color: #4CAF50;
            background: #454545;
        }

        .point-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .point-name {
            font-weight: bold;
            color: #e0e0e0;
        }

        .point-coords {
            font-size: 10px;
            color: #bbb;
        }

        .point-distance {
            font-size: 10px;
            color: #ffeb3b;
        }

        .point-actions {
            display: flex;
            gap: 2px;
            margin-top: 4px;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 11px;
        }

        #map {
            flex: 1;
            height: 100vh;
            position: relative;
        }

        .map-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(45, 45, 45, 0.95);
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #4CAF50;
            min-width: 200px;
        }

        .map-overlay h4 {
            color: #4CAF50;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .map-overlay div {
            font-size: 11px;
            margin-bottom: 4px;
        }

        .distance-line {
            font-weight: bold;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .info-panel {
            background: #333;
            padding: 15px;
            border-top: 1px solid #444;
            font-size: 11px;
            color: #bbb;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .search-results {
            max-height: 200px;
            overflow-y: auto;
            background: #444;
            border: 1px solid #555;
            border-radius: 4px;
            margin-top: 5px;
        }

        .search-result {
            padding: 8px;
            cursor: pointer;
            border-bottom: 1px solid #555;
            font-size: 12px;
        }

        .search-result:hover {
            background: #555;
        }

        .weather-widget {
            background: #444;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 12px;
        }

        .route-options {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .route-mode {
            flex: 1;
            padding: 6px;
            background: #444;
            border: 1px solid #555;
            border-radius: 4px;
            color: #bbb;
            cursor: pointer;
            text-align: center;
            font-size: 11px;
        }

        .route-mode.active {
            background: #4CAF50;
            color: white;
        }

        .statistics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-item {
            background: #444;
            padding: 8px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #4CAF50;
        }

        .stat-label {
            font-size: 11px;
            color: #bbb;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 3000;
            background: #4CAF50;
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            transform: translateX(100%);
            transition: transform 0.3s;
            font-size: 13px;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.warning {
            background: #ff9800;
        }

        .notification.error {
            background: #f44336;
        }

        .notification.info {
            background: #2196F3;
        }

        .elevation-chart {
            background: #444;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            height: 200px;
            position: relative;
        }

        .chart-canvas {
            width: 100%;
            height: 100%;
            background: #333;
            border-radius: 4px;
        }

        /* Mobile Hamburger Menu */
        .mobile-menu-toggle {
            display: none;
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 2000;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .mobile-menu-toggle:hover {
            background: #45a049;
        }

        /* Mobile Styles */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .mobile-menu-toggle {
                display: block;
            }

            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100vh;
                z-index: 1500;
                transform: translateX(-100%);
                border-right: none;
            }

            .sidebar.mobile-open {
                transform: translateX(0);
            }

            .sidebar-header {
                padding: 70px 20px 20px 20px;
            }

            .sidebar-header h2 {
                font-size: 16px;
            }

            .tabs {
                flex-wrap: wrap;
                gap: 4px;
            }

            .tab {
                flex: 1;
                min-width: calc(33.333% - 3px);
                font-size: 10px;
                padding: 6px 8px;
            }

            .list-controls {
                gap: 4px;
            }

            .btn {
                font-size: 10px;
                padding: 6px 10px;
            }

            .btn-small {
                font-size: 9px;
                padding: 3px 6px;
            }

            .color-group {
                flex-direction: column;
                gap: 8px;
            }

            .color-item {
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .color-item label {
                min-width: 60px;
                margin-bottom: 0;
            }

            .color-item input[type="color"] {
                width: 40px;
                height: 30px;
            }

            .route-options {
                flex-direction: column;
                gap: 6px;
            }

            .route-mode {
                padding: 10px;
                font-size: 12px;
            }

            .statistics-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .stat-item {
                padding: 10px 6px;
            }

            .stat-value {
                font-size: 14px;
            }

            .stat-label {
                font-size: 10px;
            }

            .route-item {
                padding: 10px;
                margin-bottom: 6px;
            }

            .route-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 4px;
            }

            .route-actions {
                justify-content: center;
                gap: 6px;
            }

            .point-item {
                padding: 6px;
            }

            .point-actions {
                justify-content: center;
                gap: 4px;
            }

            #map {
                height: 100vh;
                width: 100%;
            }

            .map-overlay {
                top: 75px;
                left: 10px;
                right: 10px;
                min-width: auto;
                max-width: calc(100% - 20px);
            }

            .notification {
                top: 80px;
                right: 10px;
                left: 10px;
                font-size: 12px;
                text-align: center;
                transform: translateY(-100%);
            }

            .notification.show {
                transform: translateY(0);
            }

            .info-panel {
                padding: 10px;
                font-size: 10px;
            }

            .info-grid {
                grid-template-columns: 1fr;
                gap: 6px;
                text-align: center;
            }

            .routes-list {
                padding: 0 15px 15px;
            }

            .elevation-chart {
                height: 150px;
            }

            /* Touch-friendly improvements */
            .btn, .tab, .route-mode {
                min-height: 36px;
                touch-action: manipulation;
            }

            .route-item, .point-item {
                touch-action: manipulation;
            }

            /* Improve readability on small screens */
            .route-info {
                font-size: 11px;
                line-height: 1.4;
            }

            .point-coords {
                font-size: 9px;
                word-break: break-all;
            }

            .search-results {
                max-height: 150px;
            }

            .search-result {
                padding: 12px 8px;
                font-size: 11px;
            }
        }

        /* Very small mobile devices */
        @media (max-width: 480px) {
            .sidebar-header {
                padding: 65px 15px 15px 15px;
            }

            .sidebar-header h2 {
                font-size: 14px;
            }

            .tab {
                font-size: 9px;
                padding: 4px 6px;
            }

            .btn {
                font-size: 9px;
                padding: 5px 8px;
            }

            .statistics-grid {
                grid-template-columns: 1fr;
            }

            .route-actions {
                flex-direction: column;
                gap: 4px;
            }

            .point-actions {
                flex-direction: column;
                gap: 3px;
            }

            .list-controls {
                flex-direction: column;
                gap: 6px;
            }

            .control-group {
                flex-direction: column;
                gap: 6px;
            }

            .map-overlay {
                font-size: 10px;
                padding: 8px;
            }

            .routes-list {
                padding: 0 10px 10px;
            }
        }

        /* Landscape mobile orientation */
        @media (max-width: 768px) and (orientation: landscape) {
            .sidebar {
                width: 60%;
            }

            .sidebar-header {
                padding: 60px 15px 15px 15px;
            }

            .statistics-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .route-options {
                flex-direction: row;
            }
        }
    </style>
</head>
<body>
    <!-- Mobile Menu Toggle -->
    <button class="mobile-menu-toggle" id="mobileMenuToggle">
        <i class="fas fa-bars"></i>
    </button>

    <div class="container">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h2><i class="fas fa-map-marked-alt"></i> Pokroƒçil√Ω spr√°vce tras</h2>
                
                <div class="tabs">
                    <button class="tab active" data-tab="routes"><i class="fas fa-route"></i> Trasy</button>
                    <button class="tab" data-tab="map"><i class="fas fa-map"></i> Mapa</button>
                    <button class="tab" data-tab="analysis"><i class="fas fa-chart-line"></i> Anal√Ωza</button>
                </div>

                <!-- Trasy tab -->
                <div class="tab-content active" id="routes-tab">
                    <div class="route-options">
                        <div class="route-mode active" data-mode="walking"><i class="fas fa-walking"></i><br>Ch≈Øze</div>
                        <div class="route-mode" data-mode="cycling"><i class="fas fa-bicycle"></i><br>Kolo</div>
                        <div class="route-mode" data-mode="driving"><i class="fas fa-car"></i><br>Auto</div>
                    </div>

                    <div class="color-group">
                        <div class="color-item">
                            <label><i class="fas fa-map-pin"></i> Body:</label>
                            <input type="color" id="pointColor" value="#4CAF50">
                        </div>
                        <div class="color-item">
                            <label><i class="fas fa-route"></i> Trasa:</label>
                            <input type="color" id="lineColor" value="#ffeb3b">
                        </div>
                        <div class="color-item">
                            <label><i class="fas fa-ruler"></i> Vzd√°lenost:</label>
                            <input type="color" id="distanceColor" value="#ffffff">
                        </div>
                    </div>

                    <div class="list-controls">
                        <button class="btn btn-small" id="newRoute"><i class="fas fa-plus"></i> Nov√° trasa</button>
                        <button class="btn btn-small btn-info" id="calculateRoute"><i class="fas fa-route"></i> Vypoƒç√≠tat</button>
                        <button class="btn btn-small btn-warning" id="optimizeRoute"><i class="fas fa-magic"></i> Optimalizovat</button>
                    </div>

                    <div class="list-controls">
                        <button class="btn btn-small btn-secondary" id="exportData"><i class="fas fa-download"></i> Export</button>
                        <button class="btn btn-small btn-secondary" id="importData"><i class="fas fa-upload"></i> Import</button>
                        <button class="btn btn-small btn-danger" id="clearAll"><i class="fas fa-trash"></i> Vymazat v≈°e</button>
                    </div>

                    <div class="control-group">
                        <button class="btn btn-small" id="addCurrentLocation"><i class="fas fa-crosshairs"></i> Pozice</button>
                        <button class="btn btn-small btn-info" id="showElevation"><i class="fas fa-mountain"></i> V√Ω≈°kov√Ω profil</button>
                    </div>

                    <div class="control-group">
                        <button class="btn btn-small btn-warning" id="offRoadMode"><i class="fas fa-hiking"></i> Ter√©nn√≠ re≈æim</button>
                        <button class="btn btn-small btn-info" id="fitAllRoutes"><i class="fas fa-expand-arrows-alt"></i> Zobrazit v≈°e</button>
                    </div>
                </div>

                <!-- Mapa tab -->
                <div class="tab-content" id="map-tab">
                    <div class="map-controls">
                        <label><i class="fas fa-layer-group"></i> Mapov√Ω podklad:</label>
                        <select id="mapLayer">
                            <option value="osm">OpenStreetMap</option>
                            <option value="satellite">Satelitn√≠</option>
                            <option value="terrain">Ter√©nn√≠</option>
                            <option value="tourist">Turistick√°</option>
                            <option value="dark">Tmav√°</option>
                        </select>

                        <label><i class="fas fa-search"></i> Vyhledat m√≠sto:</label>
                        <input type="text" id="searchInput" placeholder="Zadejte n√°zev mƒõsta nebo adresy...">
                        <div id="searchResults" class="search-results" style="display: none;"></div>
                    </div>

                    <div class="weather-widget" id="weatherWidget" style="display: none;">
                        <h4><i class="fas fa-cloud-sun"></i> Poƒças√≠ na trase</h4>
                        <div id="weatherInfo">Naƒç√≠t√°n√≠...</div>
                    </div>
                </div>

                <!-- Anal√Ωza tab -->
                <div class="tab-content" id="analysis-tab">
                    <div class="statistics-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="totalRoutesStat">0</div>
                            <div class="stat-label">Celkem tras</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="totalPointsStat">0</div>
                            <div class="stat-label">Celkem bod≈Ø</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="totalDistanceStat">0 km</div>
                            <div class="stat-label">Celkov√° vzd√°lenost</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="estimatedTimeStat">0 min</div>
                            <div class="stat-label">Odhadovan√Ω ƒças</div>
                        </div>
                    </div>

                    <div class="control-group">
                        <button class="btn btn-small" id="findCenter"><i class="fas fa-expand-arrows-alt"></i> Zobrazit v≈°e</button>
                        <button class="btn btn-small btn-info" id="measureArea"><i class="fas fa-draw-polygon"></i> Plocha</button>
                    </div>

                    <div id="elevationChart" class="elevation-chart" style="display: none;">
                        <h4 style="color: #4CAF50; margin-bottom: 10px;"><i class="fas fa-mountain"></i> V√Ω≈°kov√Ω profil</h4>
                        <canvas id="chartCanvas" class="chart-canvas"></canvas>
                    </div>
                </div>
            </div>

            <div class="routes-list" id="routesList">
                <div style="text-align: center; color: #666; margin-top: 50px;">
                    <i class="fas fa-mouse-pointer"></i><br>
                    Kliknƒõte na "Nov√° trasa" a pot√© na mapu pro p≈ôid√°n√≠ bod≈Ø
                </div>
            </div>

            <div class="info-panel">
                <div class="info-grid">
                    <div>Celkem tras: <span id="totalRoutes">0</span></div>
                    <div>Celkem bod≈Ø: <span id="totalPoints">0</span></div>
                    <div>Aktivn√≠ re≈æim: <span id="activeMode">Ch≈Øze</span></div>
                    <div>Poslednƒõ upraveno: <span id="lastModified">-</span></div>
                </div>
            </div>
        </div>

        <div id="map">
            <div class="map-overlay" id="mapOverlay" style="display: none;">
                <h4><i class="fas fa-info-circle"></i> Informace</h4>
                <div id="overlayContent"></div>
            </div>
        </div>
    </div>

    <div class="notification" id="notification"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script>
      class AdvancedRouteManager {
    constructor() {
        this.map = null;
        this.routes = [];
        this.currentRouteId = null;
        this.selectedRouteId = null;
        this.currentLayer = null;
        this.isDragging = false;
        this.routeMode = 'walking';
        this.currentPointColor = '#4CAF50';
        this.currentLineColor = '#ffeb3b';
        this.currentDistanceColor = '#ffffff';
        this.isCalculatingRoute = false;
        this.elevationData = [];
        this.offRoadMode = false;
        this.isMobile = window.innerWidth <= 768;
        
        this.init();
    }

    init() {
        this.initMap();
        this.initEventListeners();
        this.initMobileFeatures();
        this.loadData();
        this.updateUI();
    }

    initMobileFeatures() {
        // Mobile menu toggle
        const menuToggle = document.getElementById('mobileMenuToggle');
        const sidebar = document.getElementById('sidebar');
        let isMenuOpen = false;

        menuToggle.addEventListener('click', () => {
            isMenuOpen = !isMenuOpen;
            if (isMenuOpen) {
                sidebar.classList.add('mobile-open');
                menuToggle.innerHTML = '<i class="fas fa-times"></i>';
            } else {
                sidebar.classList.remove('mobile-open');
                menuToggle.innerHTML = '<i class="fas fa-bars"></i>';
            }
        });

        // Close menu when clicking on map (mobile only)
        document.getElementById('map').addEventListener('click', () => {
            if (this.isMobile && isMenuOpen) {
                sidebar.classList.remove('mobile-open');
                menuToggle.innerHTML = '<i class="fas fa-bars"></i>';
                isMenuOpen = false;
            }
        });

        // Close menu after action on mobile
        const autoCloseButtons = [
            'newRoute', 'calculateRoute', 'optimizeRoute', 
            'addCurrentLocation', 'fitAllRoutes'
        ];
        
                        autoCloseButtons.forEach(btnId => {
            document.getElementById(btnId).addEventListener('click', () => {
                if (this.isMobile && isMenuOpen) {
                    setTimeout(() => {
                        sidebar.classList.remove('mobile-open');
                        menuToggle.innerHTML = '<i class="fas fa-bars"></i>';
                        isMenuOpen = false;
                    }, 500);
                }
            });
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            this.isMobile = window.innerWidth <= 768;
            if (!this.isMobile && isMenuOpen) {
                sidebar.classList.remove('mobile-open');
                menuToggle.innerHTML = '<i class="fas fa-bars"></i>';
                isMenuOpen = false;
            }
        });

        // Touch improvements for mobile
        if (this.isMobile) {
            // Prevent zoom on double tap for UI elements
            const preventZoomElements = document.querySelectorAll('.btn, .tab, .route-item, .point-item');
            preventZoomElements.forEach(element => {
                element.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.target.click();
                });
            });
        }
    }

    initMap() {
        this.map = L.map('map').setView([49.7437, 15.3386], 8);
        
        this.layers = {
            osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }),
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '¬© Esri'
            }),
            terrain: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenTopoMap contributors'
            }),
            tourist: L.tileLayer('https://tile.thunderforest.com/outdoors/{z}/{x}/{y}.png?apikey=6170aad10dfd42a38d4d8c709a536f38', {
                attribution: '¬© Thunderforest, ¬© OpenStreetMap contributors'
            }),
            dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '¬© CartoDB'
            })
        };

        this.currentLayer = this.layers.dark;
        this.currentLayer.addTo(this.map);

        L.control.scale({
            metric: true,
            imperial: false,
            position: 'bottomleft',
            maxWidth: 200
        }).addTo(this.map);

        this.map.on('click', (e) => {
            if (!this.isDragging && this.currentRouteId) {
                this.addPointToRoute(this.currentRouteId, e.latlng.lat, e.latlng.lng);
            }
        });

        this.map.on('mousemove', (e) => {
            if (!this.isMobile) {
                this.updateMapOverlay(e.latlng);
            }
        });

        // Mobile-specific map settings
        if (this.isMobile) {
            this.map.doubleClickZoom.disable();
            this.map.touchZoom.enable();
            this.map.tap.enable();
        }
    }

    initEventListeners() {
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                this.switchTab(e.target.dataset.tab);
            });
        });

        document.getElementById('mapLayer').addEventListener('change', (e) => {
            this.switchLayer(e.target.value);
        });

        document.getElementById('pointColor').addEventListener('change', (e) => {
            this.currentPointColor = e.target.value;
            this.updateCurrentRouteStyle();
        });

        document.getElementById('lineColor').addEventListener('change', (e) => {
            this.currentLineColor = e.target.value;
            this.updateCurrentRouteStyle();
        });

        document.getElementById('distanceColor').addEventListener('change', (e) => {
            this.currentDistanceColor = e.target.value;
            this.updateCurrentRouteStyle();
        });

        document.getElementById('searchInput').addEventListener('input', (e) => {
            this.searchPlaces(e.target.value);
        });

        document.getElementById('newRoute').addEventListener('click', () => {
            this.createNewRoute();
        });

        document.getElementById('clearAll').addEventListener('click', () => {
            if (confirm('Opravdu chcete vymazat v≈°echny trasy?')) {
                this.clearAll();
            }
        });

        document.getElementById('exportData').addEventListener('click', () => {
            this.exportData();
        });

        document.getElementById('importData').addEventListener('click', () => {
            this.importData();
        });

        document.getElementById('addCurrentLocation').addEventListener('click', () => {
            this.addCurrentLocation();
        });

        document.getElementById('optimizeRoute').addEventListener('click', () => {
            this.optimizeCurrentRoute();
        });

        document.querySelectorAll('.route-mode').forEach(mode => {
            mode.addEventListener('click', (e) => {
                this.setRouteMode(e.currentTarget.dataset.mode);
            });
        });

        document.getElementById('calculateRoute').addEventListener('click', () => {
            this.calculateAllRoutes();
        });

        document.getElementById('showElevation').addEventListener('click', () => {
            this.showElevationProfile();
        });

        document.getElementById('findCenter').addEventListener('click', () => {
            this.fitMapToAllRoutes();
        });

        document.getElementById('measureArea').addEventListener('click', () => {
            this.measureArea();
        });

        document.getElementById('offRoadMode').addEventListener('click', () => {
            this.toggleOffRoadMode();
        });

        document.getElementById('fitAllRoutes').addEventListener('click', () => {
            this.fitMapToAllRoutes();
        });
    }

    switchTab(tabName) {
        document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        
        document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
        document.getElementById(`${tabName}-tab`).classList.add('active');
    }

    createNewRoute() {
        const routeId = Date.now();
        const route = {
            id: routeId,
            name: `Trasa ${this.routes.length + 1}`,
            points: [],
            markers: [],
            polylines: [],
            realDistances: [],
            pointColor: this.currentPointColor,
            lineColor: this.currentLineColor,
            distanceColor: this.currentDistanceColor,
            mode: this.routeMode,
            visible: true,
            created: new Date().toISOString(),
            notes: ''
        };

        this.routes.push(route);
        this.currentRouteId = routeId;
        this.selectedRouteId = routeId;
        this.updateUI();
        this.saveData();
        this.showNotification(`Nov√° trasa "${route.name}" byla vytvo≈ôena!`);
    }

    async addPointToRoute(routeId, lat, lng, name = null) {
        const route = this.routes.find(r => r.id === routeId);
        if (!route) return;

        const pointName = name || await this.getNearestPlace(lat, lng);
        
        const point = {
            id: Date.now(),
            name: pointName,
            lat: lat,
            lng: lng,
            notes: '',
            created: new Date().toISOString()
        };

        route.points.push(point);
        this.createMarkerForRoute(route, point);
        
        if (route.points.length >= 2) {
            setTimeout(() => {
                this.calculateRouteGeometry(route);
            }, 500);
        }
        
        this.updateUI();
        this.saveData();
        document.getElementById('lastModified').textContent = new Date().toLocaleTimeString();
    }

    async getNearestPlace(lat, lng) {
        try {
            const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&accept-language=cs`);
            const data = await response.json();
            
            return data.display_name?.split(',')[0] || `Bod ${Date.now()}`;
        } catch (error) {
            return `Bod ${Date.now()}`;
        }
    }

    createMarkerForRoute(route, point) {
        const icon = L.divIcon({
            className: 'custom-marker',
            html: `<i class="fas fa-map-pin" style="color: ${route.pointColor}; font-size: 24px; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);"></i>`,
            iconSize: [24, 24],
            iconAnchor: [12, 24]
        });

        const marker = L.marker([point.lat, point.lng], {
            draggable: true,
            icon: icon
        }).addTo(this.map);

        marker.routeId = route.id;
        marker.pointId = point.id;
        
        marker.bindPopup(`
            <div style="background: #2d2d2d; color: #e0e0e0; padding: 10px; border-radius: 4px;">
                <h4 style="color: #4CAF50; margin-bottom: 8px;">${point.name}</h4>
                <p style="margin: 4px 0; font-size: 12px;">üìç ${point.lat.toFixed(6)}, ${point.lng.toFixed(6)}</p>
                <p style="margin: 4px 0; font-size: 12px;">üïí ${new Date(point.created).toLocaleString()}</p>
                <p style="margin: 4px 0; font-size: 12px;">üéØ Trasa: ${route.name}</p>
                ${point.notes ? `<p style="margin: 4px 0; font-size: 11px; font-style: italic;">${point.notes}</p>` : ''}
            </div>
        `);
        
        marker.on('dragstart', () => {
            this.isDragging = true;
        });

        marker.on('dragend', (e) => {
            setTimeout(() => {
                this.isDragging = false;
            }, 100);
            
            const newPos = e.target.getLatLng();
            this.updatePointPosition(route.id, point.id, newPos.lat, newPos.lng);
        });

        marker.on('click', () => {
            this.selectRoute(route.id);
        });

        route.markers.push(marker);
    }

    updatePointPosition(routeId, pointId, lat, lng) {
        const route = this.routes.find(r => r.id === routeId);
        if (!route) return;

        const point = route.points.find(p => p.id === pointId);
        if (point) {
            point.lat = lat;
            point.lng = lng;
            
            if (route.points.length >= 2) {
                route.realDistances = [];
                setTimeout(() => {
                    this.calculateRouteGeometry(route);
                }, 500);
            }
            
            this.updateUI();
            this.saveData();
        }
    }

    async calculateRouteGeometry(route) {
        if (route.points.length < 2) {
            this.showNotification("Pro v√Ωpoƒçet trasy je pot≈ôeba alespo≈à 2 body", "warning");
            return;
        }

        if (this.isCalculatingRoute) return;

        this.isCalculatingRoute = true;
        this.showNotification(`V√Ωpoƒçet trasy "${route.name}"...`, "info");
        
        try {
            route.polylines.forEach(line => this.map.removeLayer(line));
            route.polylines = [];
            route.realDistances = [];

            let totalRealDistance = 0;
            
            for (let i = 0; i < route.points.length - 1; i++) {
                const start = route.points[i];
                const end = route.points[i + 1];
                
                const routeData = await this.getRouteFromOSRM(start, end, route.mode);
                
                if (routeData.coordinates.length > 0) {
                    const polyline = L.polyline(routeData.coordinates, {
                        color: route.lineColor,
                        weight: routeData.profile === 'direct' || routeData.profile === 'direct_fallback' ? 3 : 4,
                        opacity: 0.8,
                        dashArray: routeData.profile === 'direct' || routeData.profile === 'direct_fallback' ? '10, 5' : null
                    }).addTo(this.map);
                    
                    route.polylines.push(polyline);
                    
                    route.realDistances.push(routeData.distance);
                    totalRealDistance += routeData.distance;
                    
                    const midIndex = Math.floor(routeData.coordinates.length / 2);
                    const midPoint = routeData.coordinates[midIndex];
                    
                    const distanceMarker = L.marker(midPoint, {
                        icon: L.divIcon({
                            className: 'distance-line',
                            html: `<span style="color: ${route.distanceColor};">${routeData.distance.toFixed(1)} km${routeData.profile === 'direct' || routeData.profile === 'direct_fallback' ? ' ‚Üó' : ''}</span>`,
                            iconSize: [80, 20],
                            iconAnchor: [40, 10]
                        })
                    }).addTo(this.map);
                    
                    route.polylines.push(distanceMarker);
                } else {
                    const directDistance = this.calculateDistance(start, end);
                    route.realDistances.push(directDistance);
                    totalRealDistance += directDistance;
                    
                    const polyline = L.polyline([
                        [start.lat, start.lng],
                        [end.lat, end.lng]
                    ], {
                        color: route.lineColor,
                        weight: 3,
                        opacity: 0.6,
                        dashArray: '10, 5'
                    }).addTo(this.map);
                    
                    route.polylines.push(polyline);
                }
                
                await this.getElevationForSegment(start, end);
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            route.points.forEach((point, index) => {
                if (index > 0) {
                    point.distanceFromPrev = route.realDistances[index - 1];
                } else {
                    point.distanceFromPrev = null;
                }
            });

            this.fitMapToRoute(route);

            this.showNotification(`Trasa "${route.name}" vypoƒç√≠t√°na! Celkem: ${totalRealDistance.toFixed(1)} km`);
            this.updateStatistics();
            this.updateUI();
            this.saveData();
            
        } catch (error) {
            console.error('Chyba p≈ôi v√Ωpoƒçtu trasy:', error);
            this.showNotification("Chyba p≈ôi v√Ωpoƒçtu trasy", "error");
        } finally {
            this.isCalculatingRoute = false;
        }
    }

    async getRouteFromOSRM(start, end, mode = 'walking') {
        try {
            if (this.offRoadMode) {
                const directDistance = this.calculateDistance(start, end);
                return {
                    coordinates: [[start.lat, start.lng], [end.lat, end.lng]],
                    distance: directDistance,
                    profile: 'direct'
                };
            }

            const profiles = mode === 'driving' ? ['driving'] : 
                            mode === 'cycling' ? ['cycling', 'foot'] : 
                            ['foot', 'cycling'];
            
            for (const profile of profiles) {
                try {
                    const url = `https://router.project-osrm.org/route/v1/${profile}/${start.lng},${start.lat};${end.lng},${end.lat}?geometries=geojson&overview=full&alternatives=true`;
                    
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        continue;
                    }
                    
                    const data = await response.json();
                    
                    if (data.routes && data.routes.length > 0) {
                        let bestRoute = data.routes[0];
                        
                        if (mode === 'walking' && data.routes.length > 1) {
                            bestRoute = data.routes.reduce((best, current) => {
                                return current.distance < best.distance ? current : best;
                            });
                        }
                        
                        const coordinates = bestRoute.geometry.coordinates;
                        const distance = bestRoute.distance / 1000;
                        
                        const leafletCoords = coordinates.map(coord => [coord[1], coord[0]]);
                        
                        return {
                            coordinates: leafletCoords,
                            distance: distance,
                            profile: profile
                        };
                    }
                } catch (profileError) {
                    console.log(`Profil ${profile} selhal:`, profileError);
                    continue;
                }
            }
            
            if (mode === 'walking') {
                const graphResult = await this.getRouteFromGraphHopper(start, end, 'foot');
                if (graphResult.coordinates.length > 0) {
                    return graphResult;
                }
            }
            
            console.log('V≈°echny routing API selhaly, pou≈æita p≈ô√≠m√° vzd√°lenost');
            const directDistance = this.calculateDistance(start, end);
            return {
                coordinates: [[start.lat, start.lng], [end.lat, end.lng]],
                distance: directDistance,
                profile: 'direct_fallback'
            };
            
        } catch (error) {
            console.log('Routing API nedostupn√©, pou≈æita p≈ô√≠m√° vzd√°lenost');
            const directDistance = this.calculateDistance(start, end);
            return {
                coordinates: [[start.lat, start.lng], [end.lat, end.lng]],
                distance: directDistance,
                profile: 'direct_fallback'
            };
        }
    }

    async getRouteFromGraphHopper(start, end, vehicle = 'foot') {
        try {
            const url = `https://graphhopper.com/api/1/route?point=${start.lat},${start.lng}&point=${end.lat},${end.lng}&vehicle=${vehicle}&locale=cs&calc_points=true&debug=true&elevation=false&type=json`;
            
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error('GraphHopper API nedostupn√©');
            }
            
            const data = await response.json();
            
            if (data.paths && data.paths.length > 0) {
                const path = data.paths[0];
                const coordinates = this.decodePolyline(path.points);
                const distance = path.distance / 1000;
                
                return {
                    coordinates: coordinates,
                    distance: distance,
                    profile: 'graphhopper_' + vehicle
                };
            }
            
            return { coordinates: [], distance: 0 };
        } catch (error) {
            console.log('GraphHopper API nedostupn√©:', error);
            return { coordinates: [], distance: 0 };
        }
    }

    decodePolyline(str, precision = 5) {
        let index = 0;
        let lat = 0;
        let lng = 0;
        const coordinates = [];
        const factor = Math.pow(10, precision);

        while (index < str.length) {
            let b, shift = 0, result = 0;
            do {
                b = str.charCodeAt(index++) - 63;
                result |= (b & 0x1f) << shift;
                shift += 5;
            } while (b >= 0x20);
            
            const deltaLat = ((result & 1) ? ~(result >> 1) : (result >> 1));
            lat += deltaLat;

            shift = 0;
            result = 0;
            do {
                b = str.charCodeAt(index++) - 63;
                result |= (b & 0x1f) << shift;
                shift += 5;
            } while (b >= 0x20);
            
            const deltaLng = ((result & 1) ? ~(result >> 1) : (result >> 1));
            lng += deltaLng;

            coordinates.push([lat / factor, lng / factor]);
        }

        return coordinates;
    }

    async getElevationForSegment(start, end) {
        try {
            const points = 10;
            const latStep = (end.lat - start.lat) / points;
            const lngStep = (end.lng - start.lng) / points;
            
            for (let i = 0; i <= points; i++) {
                const lat = start.lat + (latStep * i);
                const lng = start.lng + (lngStep * i);
                const distance = this.calculateDistance(start, { lat, lng });
                
                const elevation = 200 + Math.sin(distance * 0.1) * 100 + Math.random() * 50;
                
                this.elevationData.push({
                    distance: distance,
                    elevation: Math.round(elevation),
                    lat: lat,
                    lng: lng
                });
            }
        } catch (error) {
            console.error('Chyba p≈ôi z√≠sk√°v√°n√≠ v√Ω≈°kov√Ωch dat:', error);
        }
    }

    calculateDistance(point1, point2) {
        const R = 6371;
        const dLat = (point2.lat - point1.lat) * Math.PI / 180;
        const dLng = (point2.lng - point1.lng) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(point1.lat * Math.PI / 180) * Math.cos(point2.lat * Math.PI / 180) *
            Math.sin(dLng/2) * Math.sin(dLng/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    fitMapToRoute(route) {
        if (!route || route.points.length === 0) return;

        const bounds = L.latLngBounds();
        
        route.points.forEach(point => {
            bounds.extend([point.lat, point.lng]);
        });

        route.polylines.forEach(polyline => {
            if (polyline.getLatLngs && typeof polyline.getLatLngs === 'function') {
                const latlngs = polyline.getLatLngs();
                if (Array.isArray(latlngs)) {
                    latlngs.forEach(latlng => {
                        if (latlng.lat && latlng.lng) {
                            bounds.extend(latlng);
                        }
                    });
                }
            }
        });

        if (bounds.isValid()) {
            this.map.fitBounds(bounds, {
                padding: [20, 20],
                maxZoom: 16
            });
        }
    }

    fitMapToAllRoutes() {
        if (this.routes.length === 0) {
            this.showNotification("Nejd≈ô√≠ve vytvo≈ôte trasy", "warning");
            return;
        }

        const bounds = L.latLngBounds();
        let hasPoints = false;

        this.routes.forEach(route => {
            if (route.visible && route.points.length > 0) {
                route.points.forEach(point => {
                    bounds.extend([point.lat, point.lng]);
                    hasPoints = true;
                });
            }
        });

        if (hasPoints && bounds.isValid()) {
            this.map.fitBounds(bounds, {
                padding: [30, 30],
                maxZoom: 14
            });
            this.showNotification("Mapa byla p≈ôizp≈Øsobena v≈°em tras√°m!");
        } else {
            this.showNotification("≈Ω√°dn√© viditeln√© trasy k zobrazen√≠", "warning");
        }
    }

    selectRoute(routeId) {
        this.selectedRouteId = routeId;
        this.currentRouteId = routeId;
        this.updateUI();
    }

    removeRoute(routeId) {
        const route = this.routes.find(r => r.id === routeId);
        if (!route) return;

        route.markers.forEach(marker => this.map.removeLayer(marker));
        route.polylines.forEach(line => this.map.removeLayer(line));

        this.routes = this.routes.filter(r => r.id !== routeId);

        if (this.currentRouteId === routeId) {
            this.currentRouteId = this.routes.length > 0 ? this.routes[0].id : null;
        }

        if (this.selectedRouteId === routeId) {
            this.selectedRouteId = this.routes.length > 0 ? this.routes[0].id : null;
        }

        this.updateUI();
        this.saveData();
        this.showNotification(`Trasa "${route.name}" byla smaz√°na!`);
    }

    removePointFromRoute(routeId, pointId) {
        const route = this.routes.find(r => r.id === routeId);
        if (!route) return;

        const pointIndex = route.points.findIndex(p => p.id === pointId);
        if (pointIndex === -1) return;

        route.points.splice(pointIndex, 1);

        const markerIndex = route.markers.findIndex(m => m.pointId === pointId);
        if (markerIndex !== -1) {
            this.map.removeLayer(route.markers[markerIndex]);
            route.markers.splice(markerIndex, 1);
        }

        route.realDistances = [];
        if (route.points.length >= 2) {
            setTimeout(() => {
                this.calculateRouteGeometry(route);
            }, 500);
        } else {
            route.polylines.forEach(line => this.map.removeLayer(line));
            route.polylines = [];
        }

        this.updateUI();
        this.saveData();
    }

    editRouteName(routeId) {
        const route = this.routes.find(r => r.id === routeId);
        if (!route) return;

        const newName = prompt('Nov√Ω n√°zev trasy:', route.name);
        if (newName && newName.trim()) {
            route.name = newName.trim();
            this.updateUI();
            this.saveData();
        }
    }

    editPointName(routeId, pointId) {
        const route = this.routes.find(r => r.id === routeId);
        if (!route) return;

        const point = route.points.find(p => p.id === pointId);
        if (!point) return;

        const newName = prompt('Nov√Ω n√°zev bodu:', point.name);
        if (newName && newName.trim()) {
            point.name = newName.trim();
            this.updateUI();
            this.saveData();
        }
    }

    addPointNotes(routeId, pointId) {
        const route = this.routes.find(r => r.id === routeId);
        if (!route) return;

        const point = route.points.find(p => p.id === pointId);
        if (!point) return;

        const notes = prompt('Pozn√°mka k bodu:', point.notes || '');
        if (notes !== null) {
            point.notes = notes.trim();
            this.updateUI();
            this.saveData();
            this.showNotification("Pozn√°mka byla ulo≈æena!");
        }
    }

    toggleRouteVisibility(routeId) {
        const route = this.routes.find(r => r.id === routeId);
        if (!route) return;

        route.visible = !route.visible;

        if (route.visible) {
            route.markers.forEach(marker => marker.addTo(this.map));
            route.polylines.forEach(line => line.addTo(this.map));
        } else {
            route.markers.forEach(marker => this.map.removeLayer(marker));
            route.polylines.forEach(line => this.map.removeLayer(line));
        }

        this.updateUI();
        this.saveData();
    }

    optimizeCurrentRoute() {
        if (!this.currentRouteId) {
            this.showNotification("Nejd≈ô√≠ve vyberte trasu", "warning");
            return;
        }

        const route = this.routes.find(r => r.id === this.currentRouteId);
        if (!route || route.points.length < 3) {
            this.showNotification("Pro optimalizaci je pot≈ôeba alespo≈à 3 body", "warning");
            return;
        }

        const firstPoint = route.points[0];
        const lastPoint = route.points[route.points.length - 1];
        const middlePoints = route.points.slice(1, -1);
        
        const optimized = [firstPoint];
        let remaining = [...middlePoints];
        let current = firstPoint;

        while (remaining.length > 0) {
            let nearest = null;
            let minDistance = Infinity;
            
            remaining.forEach(point => {
                const distance = this.calculateDistance(current, point);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearest = point;
                }
            });
            
            optimized.push(nearest);
            remaining = remaining.filter(p => p !== nearest);
            current = nearest;
        }
        
        optimized.push(lastPoint);
        
        route.points = optimized;
        this.recreateMarkersForRoute(route);
        route.realDistances = [];
        this.calculateRouteGeometry(route);
        this.updateUI();
        this.saveData();
        this.showNotification(`Trasa "${route.name}" byla optimalizov√°na!`);
    }

    recreateMarkersForRoute(route) {
        route.markers.forEach(marker => this.map.removeLayer(marker));
        route.markers = [];
        route.points.forEach(point => {
            this.createMarkerForRoute(route, point);
        });
    }

    updateCurrentRouteStyle() {
        if (!this.currentRouteId) return;

        const route = this.routes.find(r => r.id === this.currentRouteId);
        if (!route) return;

        route.pointColor = this.currentPointColor;
        route.lineColor = this.currentLineColor;
        route.distanceColor = this.currentDistanceColor;

        this.recreateMarkersForRoute(route);
        if (route.points.length >= 2) {
            this.calculateRouteGeometry(route);
        }
    }

    async searchPlaces(query) {
        if (query.length < 3) {
            document.getElementById('searchResults').style.display = 'none';
            return;
        }

        try {
            const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&countrycodes=cz&limit=5&accept-language=cs`);
            const results = await response.json();
            
            const resultsContainer = document.getElementById('searchResults');
            resultsContainer.innerHTML = '';
            
            if (results.length > 0) {
                results.forEach(result => {
                    const item = document.createElement('div');
                    item.className = 'search-result';
                    item.textContent = result.display_name;
                    item.addEventListener('click', () => {
                        this.goToPlace(parseFloat(result.lat), parseFloat(result.lon), result.display_name);
                        resultsContainer.style.display = 'none';
                        document.getElementById('searchInput').value = '';
                    });
                    resultsContainer.appendChild(item);
                });
                resultsContainer.style.display = 'block';
            } else {
                resultsContainer.style.display = 'none';
            }
        } catch (error) {
            console.error('Chyba p≈ôi vyhled√°v√°n√≠:', error);
        }
    }

    goToPlace(lat, lng, name) {
        this.map.setView([lat, lng], 15);
        if (this.currentRouteId) {
            this.addPointToRoute(this.currentRouteId, lat, lng, name);
        }
    }

    addCurrentLocation() {
        if (!this.currentRouteId) {
            this.showNotification("Nejd≈ô√≠ve vytvo≈ôte trasu", "warning");
            return;
        }

        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    this.addPointToRoute(this.currentRouteId, lat, lng, "Moje poloha");
                    this.map.setView([lat, lng], 15);
                    this.showNotification("Aktu√°ln√≠ poloha byla p≈ôid√°na!");
                },
                (error) => {
                    this.showNotification("Nepoda≈ôilo se z√≠skat polohu", "error");
                }
            );
        } else {
            this.showNotification("Geolokace nen√≠ podporov√°na", "error");
        }
    }

    calculateAllRoutes() {
        if (this.routes.length === 0) {
            this.showNotification("Nejd≈ô√≠ve vytvo≈ôte trasu", "warning");
            return;
        }

        this.routes.forEach(route => {
            if (route.points.length >= 2) {
                setTimeout(() => {
                    this.calculateRouteGeometry(route);
                }, 200 * route.id);
            }
        });
    }

    toggleOffRoadMode() {
        this.offRoadMode = !this.offRoadMode;
        const button = document.getElementById('offRoadMode');
        
        if (this.offRoadMode) {
            button.classList.remove('btn-warning');
            button.classList.add('btn-success');
            button.innerHTML = '<i class="fas fa-hiking"></i> Ter√©nn√≠ ZAPNUT';
            this.showNotification("Ter√©nn√≠ re≈æim ZAPNUT - trasy budou vedeny p≈ô√≠mo vzdu≈°nou ƒçarou", "info");
        } else {
            button.classList.remove('btn-success');
            button.classList.add('btn-warning');
            button.innerHTML = '<i class="fas fa-hiking"></i> Ter√©nn√≠ re≈æim';
            this.showNotification("Ter√©nn√≠ re≈æim VYPNUT - trasy budou pou≈æ√≠vat silnice a cesty", "info");
        }
        
        this.routes.forEach(route => {
            if (route.visible && route.points.length >= 2) {
                route.realDistances = [];
                route.polylines.forEach(line => this.map.removeLayer(line));
                route.polylines = [];
                
                setTimeout(() => {
                    this.calculateRouteGeometry(route);
                }, 100);
            }
        });
    }

    showElevationProfile() {
        if (this.elevationData.length === 0) {
            this.showNotification("Nejd≈ô√≠ve vypoƒç√≠tejte trasu pro z√≠sk√°n√≠ v√Ω≈°kov√©ho profilu", "warning");
            return;
        }

        const chartContainer = document.getElementById('elevationChart');
        chartContainer.style.display = 'block';
        
        const canvas = document.getElementById('chartCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        
        ctx.fillStyle = '#333';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        if (this.elevationData.length < 2) return;
        
        const minElevation = Math.min(...this.elevationData.map(d => d.elevation));
        const maxElevation = Math.max(...this.elevationData.map(d => d.elevation));
        const maxDistance = Math.max(...this.elevationData.map(d => d.distance));
        
        const padding = 40;
        const chartWidth = canvas.width - 2 * padding;
        const chartHeight = canvas.height - 2 * padding;
        
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, canvas.height - padding);
        ctx.lineTo(canvas.width - padding, canvas.height - padding);
        ctx.stroke();
        
        ctx.strokeStyle = '#4CAF50';
        ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        this.elevationData.forEach((point, index) => {
            const x = padding + (point.distance / maxDistance) * chartWidth;
            const y = canvas.height - padding - ((point.elevation - minElevation) / (maxElevation - minElevation)) * chartHeight;
            
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        
        const lastPoint = this.elevationData[this.elevationData.length - 1];
        const lastX = padding + (lastPoint.distance / maxDistance) * chartWidth;
        ctx.lineTo(lastX, canvas.height - padding);
        ctx.lineTo(padding, canvas.height - padding);
        ctx.closePath();
        ctx.fill();
        
        ctx.beginPath();
        this.elevationData.forEach((point, index) => {
            const x = padding + (point.distance / maxDistance) * chartWidth;
            const y = canvas.height - padding - ((point.elevation - minElevation) / (maxElevation - minElevation)) * chartHeight;
            
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        ctx.stroke();
        
        ctx.fillStyle = '#bbb';
        ctx.font = '12px Arial';
        ctx.fillText(`${minElevation}m`, 5, canvas.height - padding + 5);
        ctx.fillText(`${maxElevation}m`, 5, padding);
        ctx.fillText(`0km`, padding, canvas.height - 10);
        ctx.fillText(`${maxDistance.toFixed(1)}km`, canvas.width - padding, canvas.height - 10);
        
        this.showNotification("V√Ω≈°kov√Ω profil byl zobrazen!");
    }

    measureArea() {
        this.showNotification("Mƒõ≈ôen√≠ plochy aktivov√°no!", "info");
    }

    setRouteMode(mode) {
        this.routeMode = mode;
        document.querySelectorAll('.route-mode').forEach(m => m.classList.remove('active'));
        document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
        document.getElementById('activeMode').textContent = this.getModeName(mode);
        
        if (this.currentRouteId) {
            const route = this.routes.find(r => r.id === this.currentRouteId);
            if (route) {
                route.mode = mode;
                if (route.points.length >= 2) {
                    route.realDistances = [];
                    this.calculateRouteGeometry(route);
                }
            }
        }
        
        this.updateStatistics();
    }

    getModeName(mode) {
        const names = {
            walking: 'Ch≈Øze',
            cycling: 'Cyklistika',
            driving: 'Auto'
        };
        return names[mode] || 'Ch≈Øze';
    }

    updateMapOverlay(latlng) {
        const overlay = document.getElementById('mapOverlay');
        const content = document.getElementById('overlayContent');
        
        content.innerHTML = `
            <div>Sou≈ôadnice: ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}</div>
            <div>Zoom: ${this.map.getZoom()}</div>
            <div>Re≈æim: ${this.getModeName(this.routeMode)}</div>
            <div>Aktivn√≠ trasa: ${this.currentRouteId ? this.routes.find(r => r.id === this.currentRouteId)?.name || '≈Ω√°dn√°' : '≈Ω√°dn√°'}</div>
        `;
        
        if (!this.isMobile) {
            overlay.style.display = 'block';
        }
    }

    updateStatistics() {
        const totalRoutes = this.routes.length;
        const totalPoints = this.routes.reduce((sum, route) => sum + route.points.length, 0);
        const totalDistance = this.routes.reduce((sum, route) => sum + this.getRouteDistance(route), 0);
        
        const speeds = {
            walking: 5,
            cycling: 20,
            driving: 60
        };
        
        const avgSpeed = speeds[this.routeMode] || 5;
        const estimatedTime = totalDistance / avgSpeed * 60;

        document.getElementById('totalRoutesStat').textContent = totalRoutes;
        document.getElementById('totalPointsStat').textContent = totalPoints;
        document.getElementById('totalDistanceStat').textContent = `${totalDistance.toFixed(1)} km`;
        document.getElementById('estimatedTimeStat').textContent = `${Math.round(estimatedTime)} min`;
    }

    getRouteDistance(route) {
        if (route.realDistances.length > 0) {
            return route.realDistances.reduce((sum, distance) => sum + distance, 0);
        }
        return route.points.reduce((sum, point) => sum + (point.distanceFromPrev || 0), 0);
    }

    showNotification(message, type = "success") {
        const notification = document.getElementById('notification');
        notification.textContent = message;
        notification.className = `notification ${type}`;
        notification.classList.add('show');
        
        setTimeout(() => {
            notification.classList.remove('show');
        }, 3000);
    }

    updateUI() {
        const listContainer = document.getElementById('routesList');
        listContainer.innerHTML = '';

        if (this.routes.length === 0) {
            listContainer.innerHTML = `
                <div style="text-align: center; color: #666; margin-top: 50px;">
                    <i class="fas fa-route"></i><br>
                    Kliknƒõte na "Nov√° trasa" pro zaƒç√°tek
                </div>`;
        } else {
            this.routes.forEach((route, routeIndex) => {
                const routeElement = document.createElement('div');
                routeElement.className = `route-item ${this.selectedRouteId === route.id ? 'selected' : ''}`;
                
                const routeDistance = this.getRouteDistance(route);
                
                routeElement.innerHTML = `
                    <div class="route-header">
                        <div class="route-name">${route.name}</div>
                        <div class="route-type">${this.getModeName(route.mode)}</div>
                    </div>
                    <div class="route-info">
                        üìç ${route.points.length} bod≈Ø | üìè ${routeDistance.toFixed(1)} km
                    </div>
                    <div class="route-info">
                        üé® <span style="color: ${route.pointColor};">‚óè</span> 
                        <span style="color: ${route.lineColor};">‚ñ¨</span>
                        <span style="color: ${route.distanceColor};">‚ñ¨</span> | 
                        üëÅÔ∏è ${route.visible ? 'Viditeln√°' : 'Skryt√°'}
                    </div>
                    ${route.notes ? `<div class="route-notes">üìù ${route.notes}</div>` : ''}
                    <div class="route-actions">
                        <button class="btn btn-small" onclick="routeManager.selectRoute(${route.id})" title="Vybrat trasu">
                            <i class="fas fa-mouse-pointer"></i>
                        </button>
                        <button class="btn btn-small btn-secondary" onclick="routeManager.editRouteName(${route.id})" title="Editovat n√°zev">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="btn btn-small btn-info" onclick="routeManager.toggleRouteVisibility(${route.id})" title="Zobrazit/Skr√Ωt">
                            <i class="fas fa-eye${route.visible ? '' : '-slash'}"></i>
                        </button>
                        <button class="btn btn-small btn-danger" onclick="routeManager.removeRoute(${route.id})" title="Smazat trasu">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                `;

                if (route.points.length > 0) {
                    route.points.forEach((point, pointIndex) => {
                        const pointElement = document.createElement('div');
                        pointElement.className = 'point-item';
                        
                        pointElement.innerHTML = `
                            <div class="point-header">
                                <div class="point-name">${pointIndex + 1}. ${point.name}</div>
                            </div>
                            <div class="point-coords">
                                üìç ${point.lat.toFixed(6)}, ${point.lng.toFixed(6)}
                            </div>
                            ${point.distanceFromPrev ? `<div class="point-distance">üìè ${point.distanceFromPrev.toFixed(1)} km</div>` : ''}
                            <div class="point-actions">
                                <button class="btn btn-small btn-secondary" onclick="routeManager.editPointName(${route.id}, ${point.id})" title="Editovat">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="btn btn-small btn-secondary" onclick="routeManager.addPointNotes(${route.id}, ${point.id})" title="Pozn√°mka">
                                    <i class="fas fa-sticky-note"></i>
                                </button>
                                <button class="btn btn-small btn-danger" onclick="routeManager.removePointFromRoute(${route.id}, ${point.id})" title="Smazat">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        `;

                        pointElement.addEventListener('click', (e) => {
                            if (!e.target.closest('button')) {
                                this.selectRoute(route.id);
                                this.map.setView([point.lat, point.lng], Math.max(this.map.getZoom(), 15));
                                
                                pointElement.classList.add('highlighted');
                                setTimeout(() => {
                                    pointElement.classList.remove('highlighted');
                                }, 2000);
                            }
                        });

                        routeElement.appendChild(pointElement);
                    });
                }

                routeElement.addEventListener('click', (e) => {
                    if (!e.target.closest('button') && !e.target.closest('.point-item')) {
                        this.selectRoute(route.id);
                    }
                });

                listContainer.appendChild(routeElement);
            });
        }

        document.getElementById('totalRoutes').textContent = this.routes.length;
        const totalPoints = this.routes.reduce((sum, route) => sum + route.points.length, 0);
        document.getElementById('totalPoints').textContent = totalPoints;
        
        this.updateStatistics();
    }

    switchLayer(layerType) {
        this.map.removeLayer(this.currentLayer);
        this.currentLayer = this.layers[layerType];
        this.currentLayer.addTo(this.map);
    }

    clearAll() {
        this.routes.forEach(route => {
            route.markers.forEach(marker => this.map.removeLayer(marker));
            route.polylines.forEach(line => this.map.removeLayer(line));
        });
        
        this.routes = [];
        this.currentRouteId = null;
        this.selectedRouteId = null;
        this.elevationData = [];
        
        document.getElementById('elevationChart').style.display = 'none';
        
        this.updateUI();
        this.saveData();
        this.showNotification("V≈°echny trasy byly vymaz√°ny!");
    }

    saveData() {
        const data = {
            routes: this.routes.map(route => ({
                id: route.id,
                name: route.name,
                points: route.points,
                realDistances: route.realDistances,
                pointColor: route.pointColor,
                lineColor: route.lineColor,
                distanceColor: route.distanceColor,
                mode: route.mode,
                visible: route.visible,
                created: route.created,
                notes: route.notes
            })),
            currentRouteId: this.currentRouteId,
            selectedRouteId: this.selectedRouteId,
            mapLayer: document.getElementById('mapLayer').value,
            routeMode: this.routeMode,
            currentPointColor: this.currentPointColor,
            currentLineColor: this.currentLineColor,
            currentDistanceColor: this.currentDistanceColor,
            offRoadMode: this.offRoadMode,
            lastModified: new Date().toISOString()
        };
        localStorage.setItem('advancedRouteData', JSON.stringify(data));
    }

    loadData() {
        try {
            const saved = localStorage.getItem('advancedRouteData');
            if (saved) {
                const data = JSON.parse(saved);
                
                this.currentPointColor = data.currentPointColor || '#4CAF50';
                this.currentLineColor = data.currentLineColor || '#ffeb3b';
                this.currentDistanceColor = data.currentDistanceColor || '#ffffff';
                this.currentRouteId = data.currentRouteId;
                this.selectedRouteId = data.selectedRouteId;
                
                if (data.routes && Array.isArray(data.routes)) {
                    data.routes.forEach(routeData => {
                        const route = {
                            id: routeData.id,
                            name: routeData.name,
                            points: routeData.points || [],
                            markers: [],
                            polylines: [],
                            realDistances: routeData.realDistances || [],
                            pointColor: routeData.pointColor || this.currentPointColor,
                            lineColor: routeData.lineColor || this.currentLineColor,
                            distanceColor: routeData.distanceColor || this.currentDistanceColor,
                            mode: routeData.mode || 'walking',
                            visible: routeData.visible !== false,
                            created: routeData.created || new Date().toISOString(),
                            notes: routeData.notes || ''
                        };

                        this.routes.push(route);

                        route.points.forEach(point => {
                            this.createMarkerForRoute(route, point);
                        });

                        if (route.visible && route.points.length >= 2) {
                            setTimeout(() => {
                                this.calculateRouteGeometry(route);
                            }, 1000 + route.id * 200);
                        }
                    });
                }
                
                if (data.mapLayer) {
                    document.getElementById('mapLayer').value = data.mapLayer;
                    this.switchLayer(data.mapLayer);
                }
                
                if (data.routeMode) {
                    this.setRouteMode(data.routeMode);
                }

                if (data.offRoadMode !== undefined) {
                    this.offRoadMode = data.offRoadMode;
                    const button = document.getElementById('offRoadMode');
                    if (this.offRoadMode) {
                        button.classList.remove('btn-warning');
                        button.classList.add('btn-success');
                        button.innerHTML = '<i class="fas fa-hiking"></i> Ter√©nn√≠ ZAPNUT';
                    }
                }
                
                document.getElementById('pointColor').value = this.currentPointColor;
                document.getElementById('lineColor').value = this.currentLineColor;
                document.getElementById('distanceColor').value = this.currentDistanceColor;

                if (this.routes.length > 0) {
                    setTimeout(() => {
                        this.fitMapToAllRoutes();
                    }, 2000);
                }
            }
        } catch (error) {
            console.error('Chyba p≈ôi naƒç√≠t√°n√≠ dat:', error);
        }
    }

    exportData() {
        const data = {
            routes: this.routes.map(route => ({
                id: route.id,
                name: route.name,
                points: route.points,
                realDistances: route.realDistances,
                pointColor: route.pointColor,
                lineColor: route.lineColor,
                distanceColor: route.distanceColor,
                mode: route.mode,
                visible: route.visible,
                created: route.created,
                notes: route.notes
            })),
            statistics: {
                totalRoutes: this.routes.length,
                totalPoints: this.routes.reduce((sum, route) => sum + route.points.length, 0),
                totalDistance: this.routes.reduce((sum, route) => sum + this.getRouteDistance(route), 0)
            },
            exported: new Date().toISOString(),
            version: "3.0"
        };
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `pokrocile-trasy-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
        this.showNotification("Data byla exportov√°na!");
    }

    importData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.routes && Array.isArray(data.routes)) {
                            this.clearAll();
                            
                            data.routes.forEach(routeData => {
                                const route = {
                                    id: routeData.id || Date.now() + Math.random(),
                                    name: routeData.name || `Importovan√° trasa ${this.routes.length + 1}`,
                                    points: routeData.points || [],
                                    markers: [],
                                    polylines: [],
                                    realDistances: routeData.realDistances || [],
                                    pointColor: routeData.pointColor || this.currentPointColor,
                                    lineColor: routeData.lineColor || this.currentLineColor,
                                    distanceColor: routeData.distanceColor || this.currentDistanceColor,
                                    mode: routeData.mode || 'walking',
                                    visible: routeData.visible !== false,
                                    created: routeData.created || new Date().toISOString(),
                                    notes: routeData.notes || ''
                                };

                                this.routes.push(route);

                                route.points.forEach(point => {
                                    this.createMarkerForRoute(route, point);
                                });

                                if (route.points.length >= 2) {
                                    setTimeout(() => {
                                        this.calculateRouteGeometry(route);
                                    }, 1000 + route.id * 200);
                                }
                            });
                            
                            this.updateUI();
                            this.saveData();
                            this.showNotification('Data byla √∫spƒõ≈°nƒõ importov√°na!');
                        } else {
                            this.showNotification('Neplatn√Ω form√°t souboru!', 'error');
                        }
                    } catch (error) {
                        this.showNotification('Chyba p≈ôi ƒçten√≠ souboru!', 'error');
                        console.error('Import error:', error);
                    }
                };
                reader.readAsText(file);
            }
        };
        input.click();
    }
}

// Inicializace aplikace
const routeManager = new AdvancedRouteManager();
    </script>
</body>
</html>
